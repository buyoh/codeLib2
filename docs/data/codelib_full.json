[{"title":"幾何頂点","overview":"二次元座標上の点を表す構造体","usage":"","require":"#include <cmath>\nusing namespace std;","verified":[],"references":[],"words":[],"code":"struct P {\n  using value_t = double;\n  value_t x, y;\n  P(value_t _x = 0, value_t _y = 0) : x(_x), y(_y) {}\n  inline void normalize() {\n    if (x != 0 || y != 0)\n      x /= hypot(), y /= hypot();\n  }\n  inline value_t hypot() const { return std::hypot(x, y); }\n  inline value_t hypot(P p) const { return std::hypot(x - p.x, y - p.y); }\n  inline value_t dot(P p) const { return x * p.x + y * p.y; }\n  inline value_t cross(P p) const { return x * p.y - y * p.x; }\n  inline P normalized() const { return x != 0 || y != 0 ? P(x / hypot(), y / hypot()) : P(0, 0); }\n  inline P operator+(P p) const { return P(x + p.x, y + p.y); }\n  inline P operator-(P p) const { return P(x - p.x, y - p.y); }\n  inline P& operator+=(P p) {\n    x += p.x;\n    y += p.y;\n    return *this;\n  }\n  inline P& operator-=(P p) {\n    x -= p.x;\n    y -= p.y;\n    return *this;\n  }\n};\nP operator*(P::value_t a, P p) {\n  return P(a * p.x, a * p.y);\n}","path":"/src/cpp/2d/datastructure/basic.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"凸包","overview":"凸包を求める。","usage":"pair<P, int> になっているが、secondのintには何を入れてもok（多分）。\nインデックス情報が入ることを期待している。","require":"#include <vector>\nusing namespace std;\n// #include \"src/cpp/2d/datastructure/basic.hpp\" // duplicate\n#include \"src/cpp/2d/method/ccw.hpp\"","verified":["atcoder"],"references":["http://www.prefield.com/algorithm/geometry/convex_hull.html"],"words":["convex"],"code":"vector<pair<P, int>> convex_hull(const vector<pair<P, int>>& points) {\n  // pointsはソート済みであること\n  const int n = points.size();\n  vector<pair<P, int>> ch(2 * n);\n  int k = 0;\n  for (int i = 0; i < n; ch[k] = points[i], ++k, ++i)  // lower-hull\n    while (k >= 2 && ccw(ch[k - 2].first, ch[k - 1].first, points[i].first) <= 0)\n      --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k] = points[i], ++k, --i)  // upper-hull\n    while (k >= t && ccw(ch[k - 2].first, ch[k - 1].first, points[i].first) <= 0)\n      --k;\n  ch.resize(k - 1);\n  return ch;\n}","path":"/src/cpp/2d/method/convex_hull.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"ccw(進行方向)","overview":"二次元座標上の点を表す構造体\na -> b -> c と進むときの方向を判定する。","usage":"","require":"#include \"src/cpp/2d/datastructure/basic.hpp\"","verified":[],"references":["http://www.prefield.com/algorithm/geometry/ccw.html"],"words":["ccw"],"code":"int ccw(P a, P b, P c) {\n  b.x -= a.x;\n  b.y -= a.y;\n  c.x -= a.x;\n  c.y -= a.y;\n  if (b.x * c.y - b.y * c.x > 0)\n    return +1;  // 半時計周り\n  if (b.x * c.y - b.y * c.x < 0)\n    return -1;  // 時計回り\n  if (b.x * c.x + b.y * c.y < 0)\n    return +2;  // c - a - b\n  if (b.hypot() < c.hypot())\n    return -2;  // a - b - c\n  return 0;     // a - c - b\n}","path":"/src/cpp/2d/method/ccw.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"XorShift","overview":"高速な乱数生成器．64bit版を実装した．\n一部のrandomヘッダの関数(uniform_int_distribution等)にも使える．","usage":"XorShift randdev;\nint motivation = uniform_int_distribution<int>(-9, 9)(randdev);","require":"#include <limits>\n#include <cstdint>\nusing namespace std;","verified":["目視"],"references":["https://ja.wikipedia.org/wiki/Xorshift"],"code":"struct XorShift {\n  using result_type = uint64_t;\n  result_type x_;\n  XorShift(result_type x = 88172645463325252ull) : x_(x){};\n  static constexpr inline result_type min() { return 0ull; }\n  static constexpr inline result_type max() { return numeric_limits<result_type>::max(); }\n  inline result_type operator()() {\n    x_ ^= x_ << 7;\n    return x_ ^= x_ >> 9;\n  }\n  inline void discard(unsigned long long z) {\n    while (z--)\n      operator()();\n  }\n};\nXorShift randdev;","path":"/src/cpp/random/datastructure/xorshift.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"禁止可能な一様分布の乱数","overview":"一部の整数を取り出せないようにできるような，一様分布の乱数を生成する．\ninvalidな引数を与えた場合の動作は未定義．\n空間計算量 O(size) に注意する．","usage":"RandChooser(int size)\n; [0, size-1] の範囲の整数の乱数を生成するようなインスタンスの生成\ninline int RandChooser::operator()(RANDOM &rd)\nrd : 乱数生成器．\n; 乱数生成する．\ninline int RandChooser::disable(int idx)\n; 整数idxを次回以降の乱数生成で選ばれないように設定する．\n; 既にdisableした値をもう一度disableする操作はinvalid．","require":"#include <vector>\n#include <random>\nusing namespace std;","verified":[],"references":[],"code":"class RandChooser {\n  int size;\n  int left_size;\n  vector<int> swapper;\n  vector<int> unswapper;\n\n public:\n  RandChooser(int s) : size(s), left_size(s), swapper(s), unswapper(s) {\n    for (int i = 0; i < s; ++i) {\n      swapper[i] = unswapper[i] = i;\n    }\n  }\n  inline int left() { return left_size; }\n\n  template <typename RANDOM>\n  inline int operator()(RANDOM& rd) {\n    uniform_int_distribution<int> rand_int(0, left_size - 1);\n    return swapper[rand_int(rd)];\n  }\n\n  inline int disable(int idx) {\n    swap(swapper[unswapper[idx]], swapper[left_size - 1]);\n    unswapper[swapper[unswapper[idx]]] = unswapper[idx];\n    return --left_size;\n  }\n};","path":"/src/cpp/random/datastructure/rand_chooser.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"1からnまでの乱数をm個重複せずランダムに選ぶ","overview":"1からnまでの乱数をm個重複せずランダムに選ぶ．\nこのアルゴリズムは空間計算量O(m)，時間計算量O(m)で済む（ハッシュ操作をO(1)とする）．\n簡単な実装方法として\n- 重複しないm個を取り出すまで乱数を引く (n>>m なら衝突しにくいので高速)\n- iotaしてshuffleしてeraseする（空間O(n)，時間O(n)）\nがあるが，計算量的には両者のどちらよりも優れていることが分かる．\nm/nの比でアルゴリズムを選択するハイブリッド実装でも良さそうである．\n\n[TODO] rand_int の除去","usage":"void pick_multirand(int n, int m, vector<int>& out)\n; 1からnまでの乱数をm個重複せずランダムに選びoutにpush_backする\ninline int RandChooser::operator()(RANDOM &rd)\nrd : 乱数生成器．\n; 乱数生成する．\ninline int RandChooser::disable(int idx)\n; 整数idxを次回以降の乱数生成で選ばれないように設定する．\n; 既にdisableした値をもう一度disableする操作はinvalid．","require":"#include <vector>\n#include <unordered_map>\nusing namespace std;\n// rand_int の実装\nint rand_int(int, int);","verified":[],"references":[],"code":"//\nvoid pick_multirand(int n, int m, vector<int>& out) {\n  out.clear();\n  unordered_map<int, int> memo;\n  if (n < m)\n    m = n;\n  for (int low = 1; low <= m; ++low) {\n    int r = rand_int(low, n);\n    if (!memo[r]) {\n      out.emplace_back(r);\n    } else {\n      out.emplace_back(memo[r]);\n    }\n    int e = memo[low];\n    memo[r] = e ? e : low;\n  }\n}","path":"/src/cpp/random/method/rand_multi.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"二分探索（実数）","overview":"境界を探す．func(x)==trueとなるxの中で，最も小さなxを探す．\nテンプレートを使うと，ラムダを引数に持てなくなるので，typedefで何とかしてある．[TODO]\nfunctionでwrapすれば済むだけの話だが，競技では面倒なので．","usage":"bsearch_t binarySearch(bsearch_t low, bsearch_t high, function<bool(bsearch_t)> func)\nlow  : 探索区間．型bsearch_tは整数．区間はlow,highを含む\nhigh :\nfunc : ある定数tを持ち，(t<=x)を返す関数func(x)\n@ret :","require":"#include <functional>\nusing namespace std;","verified":[],"references":[],"code":"const double EPS = 1e-9;\ndouble binarySearchReal(double false_value, double true_value, function<bool(double)> func) {\n  for (int i = 0; i < 99; ++i) {\n    double mid = (true_value + false_value) / 2;\n    (func(mid) ? true_value : false_value) = mid;\n  }\n  return true_value;\n}","path":"/src/cpp/search/method/bin_search_real.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"並び替えないソート","overview":"- i番目の要素はソート後何番目の要素になるか？\n- ソート後i番目の要素はソート前何番目の要素だったか？\nを求める","usage":"void sortedIndex(const ITER begin, const ITER end, vector<int> &idx, vector<int> &idxr)\n; ITERはランダムアクセスイテレータ","require":"#include <vector>\nusing namespace std;","verified":["atcoder"],"references":[],"code":"// ソートしてi番目の値は 元々idx[i]番目の値\n// 元々i番目の値は ソートするとidxr[i]番目の値\ntemplate <typename ITER>\nvoid sortedIndex(const ITER begin, const ITER end, vector<int>& idx, vector<int>& idxr) {\n  size_t n = end - begin;\n  idx.resize(n);\n  idxr.resize(n);\n  for (int i = 0; i < n; ++i)\n    idx[i] = i;\n  sort(idx.begin(), idx.end(), [&begin](int l, int r) { return begin[l] < begin[r]; });\n  for (int i = 0; i < n; ++i)\n    idxr[idx[i]] = i;\n}","path":"/src/cpp/search/method/sort.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"二分探索","overview":"境界を探す．func(x)==trueとなるxの中で，最も小さなxを探す．\nテンプレートを使うと，ラムダを引数に持てなくなるので，typedefで何とかしてある．[TODO]\nfunctionでwrapすれば済むだけの話だが，競技では面倒なので．","usage":"bsearch_t binarySearch(bsearch_t low, bsearch_t high, function<bool(bsearch_t)> func)\nlow  : 探索区間．型bsearch_tは整数．区間はlow,highを含む\nhigh :\nfunc : ある定数tを持ち，(t<=x)を返す関数func(x)．二分探索はtを探す．\n@ret :","require":"#include <functional>\nusing namespace std;","verified":["ABC020-C"],"references":["めぐる式"],"code":"using bsearch_t = long long;\nbsearch_t binarySearch(bsearch_t false_val, bsearch_t true_val, function<bool(bsearch_t)> func) {\n  while (abs(true_val - false_val) > 1) {\n    bsearch_t c = (true_val + false_val) / 2;\n    (func(c) ? true_val : false_val) = c;\n  }\n  return true_val;\n}","path":"/src/cpp/search/method/bin_search.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"三分探索","overview":"minimize y = func(x)．ただし，func(x)は下に凸な関数．\nテンプレートを使うと，ラムダを引数に持てなくなるので，typedefで何とかしてある．[TODO]\nfunctionでwrapすれば済むだけの話だが，競技では面倒なので．","usage":"tsearch_t ternarySearchMinimize(tsearch_t left, tsearch_t right, function<fval_t(tsearch_t)>\nfunc) left : 探索区間．型tsearch_tは整数．区間は low,high を含む right: func :\n下に凸な関数func(x)\n@ret :","require":"#include <functional>\nusing namespace std;","verified":[],"references":[],"code":"using tsearch_t = long long;\nusing fval_t = long long;\ntsearch_t ternarySearchMinimize(tsearch_t left, tsearch_t right, function<fval_t(tsearch_t)> func) {\n  for (int lop = 0; lop < 60; ++lop) {\n    tsearch_t l = right - (2 * right - 2 * left) / 3;\n    tsearch_t r = right - (right - left) / 3;\n    fval_t lval = func(l);\n    fval_t rval = func(r);\n\n    if (lval <= rval)\n      right = r;\n    else\n      left = l;\n\n    if (right - left <= 2)\n      break;\n  }\n  fval_t best = func(left);\n  tsearch_t bestidx = left;\n  for (tsearch_t t = left + 1; t <= right; ++t) {\n    tsearch_t f = func(t);\n    if (best > f) {\n      best = f;\n      bestidx = t;\n    }\n  }\n  return bestidx;\n}","path":"/src/cpp/search/method/tri_search.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"getc,putcによる入出力実装．","overview":"_WIN64 OR _WIN32 環境なら _getc_nolock を，\n__GNUC__         環境なら getc_unlocked を，\nそれ以外の環境なら getc を使う．(codeforcesでも使える)\n実数には対応しない．対応したとしてもscanf,printfでごまかします．\n\nstringを読み込む際，変数をクリアしない．\nこれを使って，入力値を文字で囲むことができる．\nstring str = \"#\"; scanner >> str; str.push_back('#');\n\nFILE* 型の外部ファイル読み込みにも対応した．\nMaiScanner sc(fp); と書く．","usage":"scanner >> var\nscanner.in(IT begin, IT end)\nprinter << var\nprinter.join(IT begin, IT end, char separator)\n; unsigned long long には対応していない．\n; printer << (ll)(v.size()) << '\\n' とするか，\n; printer.output_integer<unsigned long long>(var_ull); と書く(こちらの書き方は保証外)．","require":"#include <cstdio>\n#include <string>\nusing namespace std;","verified":["http://codeforces.com/contest/71/submission/33012760","https://csacademy.com/contest/archive/task/addition/","https://yukicoder.me/submissions/221925"],"words":["io"],"references":["cLay"],"code":"#if defined(_WIN32) || defined(_WIN64)\n#define getc_x _getc_nolock\n#define putc_x _putc_nolock\n#elif defined(__GNUC__)\n#define getc_x getc_unlocked\n#define putc_x putc_unlocked\n#else\n#define getc_x getc\n#define putc_x putc\n#endif\nclass MaiScanner {\n  FILE* fp_;\n  constexpr bool isvisiblechar(char c) noexcept { return (0x21 <= (c) && (c) <= 0x7E); }\n\n public:\n  inline MaiScanner(FILE* fp) : fp_(fp) {}\n  template <typename T>\n  void input_integer(T& var) noexcept {\n    var = 0;\n    T sign = 1;\n    int cc = getc_x(fp_);\n    for (; cc < '0' || '9' < cc; cc = getc_x(fp_))\n      if (cc == '-')\n        sign = -1;\n    for (; '0' <= cc && cc <= '9'; cc = getc_x(fp_))\n      var = (var << 3) + (var << 1) + cc - '0';\n    var = var * sign;\n  }\n  inline int c() noexcept { return getc_x(fp_); }\n  template <typename T, typename enable_if<is_integral<T>::value, nullptr_t>::type = nullptr>\n  inline MaiScanner& operator>>(T& var) noexcept {\n    input_integer<T>(var);\n    return *this;\n  }\n  inline MaiScanner& operator>>(string& var) {\n    int cc = getc_x(fp_);\n    for (; !isvisiblechar(cc); cc = getc_x(fp_))\n      ;\n    for (; isvisiblechar(cc); cc = getc_x(fp_))\n      var.push_back(cc);\n    return *this;\n  }\n  template <typename IT>\n  inline void in(IT begin, IT end) {\n    for (auto it = begin; it != end; ++it)\n      *this >> *it;\n  }\n};\nclass MaiPrinter {\n  FILE* fp_;\n\n public:\n  inline MaiPrinter(FILE* fp) : fp_(fp) {}\n  template <typename T>\n  void output_integer(T var) noexcept {\n    if (var == 0) {\n      putc_x('0', fp_);\n      return;\n    }\n    if (var < 0)\n      putc_x('-', fp_), var = -var;\n    char stack[32];\n    int stack_p = 0;\n    while (var)\n      stack[stack_p++] = '0' + (var % 10), var /= 10;\n    while (stack_p)\n      putc_x(stack[--stack_p], fp_);\n  }\n  inline MaiPrinter& operator<<(char c) noexcept {\n    putc_x(c, fp_);\n    return *this;\n  }\n  template <typename T, typename enable_if<is_integral<T>::value, nullptr_t>::type = nullptr>\n  inline MaiPrinter& operator<<(T var) noexcept {\n    output_integer<T>(var);\n    return *this;\n  }\n  inline MaiPrinter& operator<<(char* str_p) noexcept {\n    while (*str_p)\n      putc_x(*(str_p++), fp_);\n    return *this;\n  }\n  inline MaiPrinter& operator<<(const string& str) {\n    const char* p = str.c_str();\n    const char* l = p + str.size();\n    while (p < l)\n      putc_x(*p++, fp_);\n    return *this;\n  }\n  template <typename IT>\n  void join(IT begin, IT end, char sep = ' ') {\n    for (bool b = 0; begin != end; ++begin, b = 1)\n      b ? *this << sep << *begin : *this << *begin;\n  }\n};\nMaiScanner scanner(stdin);\nMaiPrinter printer(stdout);","path":"/src/cpp/implements/datastructure/io/stdio.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"Tag","overview":"std::pairに似ているが，secondは比較の対象にならない．\nTag.firstが等価であれば，構造体も等価であるとみなされる．\nマラソンマッチ用","require":"#include <utility>\nusing namespace std;","words":["kyopuro"],"code":"template <typename T1, typename T2>\nstruct Tag {\n  T1 first;\n  T2 second;\n\n  Tag(T1 t1, T2 t2) : first(t1), second(t2) {}\n  Tag(const pair<T1, T2>& p) : first(p.first), second(p.second) {}\n  Tag(const pair<T1, T2>&& p) : first(p.first), second(p.second) {}\n\n  inline bool operator==(const Tag& t) const { return first == t.first; }\n  inline bool operator<(const Tag& t) const { return first < t.first; }\n};","path":"/src/cpp/implements/datastructure/tag.hpp","verified":[],"references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"std::hashの追加定義","overview":"std::hashに定義を追加することでunordered_setが扱える型を増やす．\nstd::pair<T1,T2> のみ","usage":"","require":"#include <unordered_set>\n#include <unordered_map>\nusing namespace std;","verified":[],"code":"namespace std {\ntemplate <typename T1, typename T2>\nstruct hash<pair<T1, T2>> {\n  constexpr inline size_t operator()(const pair<T1, T2>& x) const {\n    return hash<T1>()(x.first) ^ hash<T2>()(x.second);\n  }\n};\n}  // namespace std","path":"/src/cpp/implements/datastructure/hashes.hpp","words":[],"references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"ぐるぐるイテレータ","overview":"正方形限定","usage":"for (pair<int,int> xy : DreamcastScan(20)){}","require":"#include <algorithm>\nusing namespace std;","words":["yuyuko"],"verified":[],"code":"struct DreamcastScan {\n  const int Width;\n  constexpr DreamcastScan(int _w) : Width(_w) {}\n  struct Iterator {\n    int w;     // width\n    int i, o;  // index, offset\n    constexpr Iterator(int _w, int _i, int _o) : w(_w), i(_i), o(_o) {}\n\n    inline pair<int, int> operator*() const {\n      if (i < w - 1)\n        return make_pair(o + i, o);\n      else if (i < (w - 1) * 2)\n        return make_pair(o + w - 1, o + i - (w - 1));\n      else if (i < (w - 1) * 3)\n        return make_pair(o + (w - 1) * 3 - i, o + w - 1);\n      else\n        return make_pair(o, o + (w - 1) * 4 - i);\n    }\n    inline Iterator& operator++() {\n      if (++i >= (w - 1) * 4)\n        i = 0, w -= 2, o += 1;\n      return *this;\n    }\n    inline bool operator!=(const Iterator& it) const { return w != it.w || i != it.i; }\n  };\n  constexpr inline Iterator begin() const { return Iterator(Width, 0, 0); }\n  constexpr inline Iterator end() const { return Iterator(-(Width & 1), 0, 0); }\n};","path":"/src/cpp/implements/datastructure/iterator/dreamcast.hpp","references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"iterator with index","overview":"イテレータにインデックスを付け加える．","usage":"vector<int> x = {3,1,4,1,5,9,2,6,5,3,5};\nfor (auto p : make_IteratorWithIndex(ALL(x))){\ncout << p.first << ',' << p.second << endl;\n}","require":"#include <algorithm>\nusing namespace std;","words":["iterator","index"],"verified":[],"code":"template <typename ITER>\nclass IteratorWithIndex {\n  // using ITER = int*;\n  const ITER begin_;\n  const ITER end_;\n\n public:\n  IteratorWithIndex(ITER _begin, ITER _end) : begin_(move(_begin)), end_(move(_end)) {}\n  struct Iterator {\n    ITER it;\n    int i;\n    Iterator(ITER _it, int _i) : it(move(_it)), i(_i) {}\n    inline pair<int, decltype(*it)> operator*() const { return pair<int, decltype(*it)>(i, *it); }\n    inline Iterator& operator++() {\n      ++it, ++i;\n      return *this;\n    }\n    inline auto operator!=(const Iterator& another) const -> decltype(it != another.it) {\n      return it != another.it;\n    }\n  };\n  inline Iterator begin() const { return Iterator(begin_, 0); }\n  inline Iterator end() const { return Iterator(end_, 0); }\n};\ntemplate <typename ITER>\ninline IteratorWithIndex<ITER> make_IteratorWithIndex(ITER _begin, ITER _end) {\n  return IteratorWithIndex<ITER>(_begin, _end);\n}","path":"/src/cpp/implements/datastructure/iterator/iteratorwithindex.hpp","references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"競技プログラミング用デバッグ・効率化","overview":"悪しき慣例であるrepマクロ等をまとめたもの．","words":["kyopuro"," rep"],"require":"","tags":"nolint","code":"#pragma GCC optimize(\"O3\")\n#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long int;\n\n#define debugos cout\n#define debug(v)                       \\\n  {                                    \\\n    printf(\"L%d %s > \", __LINE__, #v); \\\n    debugos << (v) << endl;            \\\n  }\n#define debugv(v)                      \\\n  {                                    \\\n    printf(\"L%d %s > \", __LINE__, #v); \\\n    for (auto e : (v)) {               \\\n      debugos << e << \" \";             \\\n    }                                  \\\n    debugos << endl;                   \\\n  }\n#define debuga(m, w)                   \\\n  {                                    \\\n    printf(\"L%d %s > \", __LINE__, #m); \\\n    for (int x = 0; x < (w); x++) {    \\\n      debugos << (m)[x] << \" \";        \\\n    }                                  \\\n    debugos << endl;                   \\\n  }\n#define debugaa(m, h, w)                \\\n  {                                     \\\n    printf(\"L%d %s >\\n\", __LINE__, #m); \\\n    for (int y = 0; y < (h); y++) {     \\\n      for (int x = 0; x < (w); x++) {   \\\n        debugos << (m)[y][x] << \" \";    \\\n      }                                 \\\n      debugos << endl;                  \\\n    }                                   \\\n  }\n#define all(v) (v).begin(), (v).end()\n#define repeat(cnt, l) for (auto cnt = remove_reference<decltype(l)>::type(); (cnt) < (l); ++(cnt))\n#define rrepeat(cnt, l) for (auto cnt = (l)-1; 0 <= (cnt); --(cnt))\n#define iterate(cnt, b, e) for (auto cnt = (b); (cnt) != (e); ++(cnt))\n#define diterate(cnt, b, e) for (auto cnt = (b); (cnt) != (e); --(cnt))\nconst ll MD = 1000000007ll;\nconst long double PI = 3.1415926535897932384626433832795L;\ninline void assert_call(bool assertion, function<void()> f) {\n  if (!assertion) {\n    cerr << \"assertion fault:\" << endl;\n    f();\n    abort();\n  }\n}\ntemplate <typename T1, typename T2>\ninline ostream& operator<<(ostream& o, const pair<T1, T2> p) {\n  o << '(' << p.first << ':' << p.second << ')';\n  return o;\n}\ntemplate <typename Vec>\ninline ostream& _ostream_vecprint(ostream& os, const Vec& a) {\n  os << '[';\n  for (const auto& e : a)\n    os << ' ' << e << ' ';\n  os << ']';\n  return os;\n}\ntemplate <typename T>\ninline ostream& operator<<(ostream& o, const vector<T>& v) {\n  return _ostream_vecprint(o, v);\n}\ntemplate <typename T, size_t S>\ninline ostream& operator<<(ostream& o, const array<T, S>& v) {\n  return _ostream_vecprint(o, v);\n}\ntemplate <typename T>\ninline T& chmax(T& to, const T& val) {\n  return to = max(to, val);\n}\ntemplate <typename T>\ninline T& chmin(T& to, const T& val) {\n  return to = min(to, val);\n}\nvoid bye(string s, int code = 0) {\n  cout << s << endl;\n  exit(code);\n}\nmt19937_64 randdev(8901016);\ntemplate <typename T,\n          typename Random = decltype(randdev),\n          typename enable_if<is_integral<T>::value>::type* = nullptr>\ninline T rand(T l, T h, Random& rand = randdev) {\n  return uniform_int_distribution<T>(l, h)(rand);\n}\ntemplate <typename T,\n          typename Random = decltype(randdev),\n          typename enable_if<is_floating_point<T>::value>::type* = nullptr>\ninline T rand(T l, T h, Random& rand = randdev) {\n  return uniform_real_distribution<T>(l, h)(rand);\n}\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getc_x _getc_nolock\n#define putc_x _putc_nolock\n#elif defined(__GNUC__)\n#define getc_x getc_unlocked\n#define putc_x putc_unlocked\n#else\n#define getc_x getc\n#define putc_x putc\n#endif\n#define isvisiblechar(c) (0x21 <= (c) && (c) <= 0x7E)\nclass MaiScanner {\n  FILE* fp_;\n\n public:\n  inline MaiScanner(FILE* fp) : fp_(fp) {}\n  template <typename T>\n  void input_integer(T& var) noexcept {\n    var = 0;\n    T sign = 1;\n    int cc = getc_x(fp_);\n    for (; cc < '0' || '9' < cc; cc = getc_x(fp_))\n      if (cc == '-')\n        sign = -1;\n    for (; '0' <= cc && cc <= '9'; cc = getc_x(fp_))\n      var = (var << 3) + (var << 1) + cc - '0';\n    var = var * sign;\n  }\n  inline int c() noexcept { return getc_x(fp_); }\n  inline MaiScanner& operator>>(int& var) noexcept {\n    input_integer<int>(var);\n    return *this;\n  }\n  inline MaiScanner& operator>>(long long& var) noexcept {\n    input_integer<long long>(var);\n    return *this;\n  }\n  inline MaiScanner& operator>>(string& var) {\n    int cc = getc_x(fp_);\n    for (; !isvisiblechar(cc); cc = getc_x(fp_))\n      ;\n    for (; isvisiblechar(cc); cc = getc_x(fp_))\n      var.push_back(cc);\n    return *this;\n  }\n  template <typename IT>\n  inline void in(IT begin, IT end) {\n    for (auto it = begin; it != end; ++it)\n      *this >> *it;\n  }\n};\nclass MaiPrinter {\n  FILE* fp_;\n\n public:\n  inline MaiPrinter(FILE* fp) : fp_(fp) {}\n  template <typename T>\n  void output_integer(T var) noexcept {\n    if (var == 0) {\n      putc_x('0', fp_);\n      return;\n    }\n    if (var < 0)\n      putc_x('-', fp_), var = -var;\n    char stack[32];\n    int stack_p = 0;\n    while (var)\n      stack[stack_p++] = '0' + (var % 10), var /= 10;\n    while (stack_p)\n      putc_x(stack[--stack_p], fp_);\n  }\n  inline MaiPrinter& operator<<(char c) noexcept {\n    putc_x(c, fp_);\n    return *this;\n  }\n  inline MaiPrinter& operator<<(int var) noexcept {\n    output_integer<int>(var);\n    return *this;\n  }\n  inline MaiPrinter& operator<<(long long var) noexcept {\n    output_integer<long long>(var);\n    return *this;\n  }\n  inline MaiPrinter& operator<<(char* str_p) noexcept {\n    while (*str_p)\n      putc_x(*(str_p++), fp_);\n    return *this;\n  }\n  inline MaiPrinter& operator<<(const string& str) {\n    const char* p = str.c_str();\n    const char* l = p + str.size();\n    while (p < l)\n      putc_x(*p++, fp_);\n    return *this;\n  }\n  template <typename IT>\n  void join(IT begin, IT end, char sep = ' ') {\n    for (bool b = 0; begin != end; ++begin, b = 1)\n      b ? *this << sep << *begin : *this << *begin;\n  }\n};\nMaiScanner scanner(stdin);\nMaiPrinter printer(stdout);","path":"/src/cpp/implements/compe.hpp","verified":[],"references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"浮動小数点の高速入出力","overview":"やるだけ","usage":"output_float<double>(M_PI, 6);\n; piを小数点以下6桁までoutput","require":"#include \"src/cpp/implements/datastructure/io/stdio.hpp\"","verified":["https://yukicoder.me/submissions/285892"],"words":["io"],"code":"template <typename T>\nvoid output_float(T var, int d) noexcept {\n  if (var < 0)\n    putchar_unlocked('-'), var = -var;\n  T i = floor(var);\n  printer << (long long)i;\n  var -= i;\n  putchar_unlocked('.');\n  while (d-- > 0 && var > 0) {\n    var *= 10.0;\n    int i = floor(var);\n    putchar_unlocked('0' + i);\n    var -= i;\n  }\n}","path":"/src/cpp/implements/method/io/stdio_float.hpp","references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"ビット演算","overview":"1単位の整数に対して，立っているビットの数を数えたりする．\nコンパイラ組込み関数があれば，なるべくそれを使うようにする．\n計算量は最悪でもlog(bitsize)時間．\n\nnote: __lzcntはCPU依存なので実装から除外","usage":"","require":"#include <cstdint>\nusing namespace std;","verified":["乱数"],"references":["http://naoyat.hatenablog.jp/entry/2014/05/12/143650","http://www.nminoru.jp/~nminoru/programming/bitcount.html","http://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html","https://docs.microsoft.com/ja-jp/cpp/intrinsics/alphabetical-listing-of-intrinsic-functions"],"code":"namespace BitAlgo {\n// 1が立っている数(f(1) = 1, f(6) = 2)\ninline int popcount32(uint32_t v) noexcept {\n#if defined(__GNUC__)\n  return __builtin_popcount(v);\n#elif defined(_MSC_VER)\n  return __popcnt(v);\n#else\n  v = (v & 0x55555555) + (v >> 1 & 0x55555555);\n  v = (v & 0x33333333) + (v >> 2 & 0x33333333);\n  v = (v & 0x0f0f0f0f) + (v >> 4 & 0x0f0f0f0f);\n  v = (v & 0x00ff00ff) + (v >> 8 & 0x00ff00ff);\n  return (v & 0x0000ffff) + (v >> 16 & 0x0000ffff);\n#endif\n}\n// 1が立っている数(f(1) = 1, f(6) = 2)\ninline int popcount64(uint64_t v) noexcept {\n#if defined(__GNUC__)\n  return __builtin_popcountll(v);\n#elif defined(_MSC_VER)\n  return __popcnt64(v);\n#else\n  v = (v & 0x5555555555555555ll) + (v >> 1 & 0x5555555555555555ll);\n  v = (v & 0x3333333333333333ll) + (v >> 2 & 0x3333333333333333ll);\n  v = (v & 0x0f0f0f0f0f0f0f0fll) + (v >> 4 & 0x0f0f0f0f0f0f0f0fll);\n  v = (v & 0x00ff00ff00ff00ffll) + (v >> 8 & 0x00ff00ff00ff00ffll);\n  v = (v & 0x0000ffff0000ffffll) + (v >> 16 & 0x0000ffff0000ffffll);\n  return (v & 0x00000000ffffffffll) + (v >> 32 & 0x00000000ffffffffll);\n#endif\n}\n// popcount % 2\ninline int parity32(uint32_t v) noexcept {\n#if defined(__GNUC__)\n  return __builtin_parity(v);\n#else\n  return popcount32(v) & 1;\n#endif\n}\n// popcount % 2\ninline int parity64(uint64_t v) noexcept {\n#if defined(__GNUC__)\n  return __builtin_parityll(v);\n#else\n  return popcount32(v) & 1;\n#endif\n}\n// 2進で表した場合に小さい方から何桁目に初めて1が現れるか\n// (f(3) = 1, f(8) = 4, f(0) = 0)\n// 関連：__builtin_ctz\ninline int ffs32(uint32_t v) noexcept {\n#if defined(__GNUC__)\n  return __builtin_ffs(v);\n#else\n  int c = 1;\n  if (v == 0)\n    return 0;\n  if (!(v & 0xFFFF))\n    c += 16, v >>= 16;\n  if (!(v & 0x00FF))\n    c += 8, v >>= 8;\n  if (!(v & 0x000F))\n    c += 4, v >>= 4;\n  if (!(v & 0x0003))\n    c += 2, v >>= 2;\n  if (!(v & 0x0001))\n    c += 1;\n  return c;\n#endif\n}\n// 2進で表した場合に小さい方から何桁目に初めて1が現れるか\n// (f(3) = 1, f(8) = 4, f(0) = 0)\n// 関連：__builtin_ctzll\ninline int ffs64(uint64_t v) noexcept {\n#if defined(__GNUC__)\n  return __builtin_ffsll(v);\n#else\n  int c = 1;\n  if (v == 0)\n    return 0;\n  if (!(v & 0xFFFFFFFFll))\n    c += 32, v >>= 32;\n  if (!(v & 0x0000FFFFll))\n    c += 16, v >>= 16;\n  if (!(v & 0x00FF))\n    c += 8, v >>= 8;\n  if (!(v & 0x000F))\n    c += 4, v >>= 4;\n  if (!(v & 0x0003))\n    c += 2, v >>= 2;\n  if (!(v & 0x0001))\n    c += 1;\n  return c;\n#endif\n}\n// 末尾から続く0の個数\n// (f(2) = 30, f(0) = 32)\ninline int clz32(uint32_t x) noexcept {\n#if defined(__GNUC__)\n  return x == 0 ? 32 : __builtin_clz(x);\n// #elif defined(_MSC_VER)\n//         return __lzcnt(x); // _BitScanReverse\n#else\n  union {\n    uint32_t i;\n    float f;\n  } data;\n  data.f = (float)x + 0.5;\n  return 158 - (data.i >> 23);\n#endif\n}\n// 末尾から続く0の個数\n// (f(2) = 62, f(0) = 64)\ninline int clz64(uint64_t x) noexcept {\n#if defined(__GNUC__)\n  return x == 0 ? 64 : __builtin_clzll(x);\n// #elif defined(_MSC_VER)\n//         return __lzcnt64(x);\n#else\n  union {\n    uint64_t i;\n    double f;\n  } datad;\n  datad.f = (double)x + 0.5;\n  return int(1086 - (datad.i >> 52));\n#endif\n}\n}  // namespace BitAlgo","path":"/src/cpp/implements/method/bitalgo.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"時間計測用マクロ","overview":"ticで開始、tocで経過時間を返す。\ntic/tocという名称はmatlabで使われている。","usage":"","require":"#include <chrono>\n#include <ostream>","words":["time","tic","toc"],"verified":[],"code":"template <typename C = std::chrono::milliseconds>\nclass Timer {\n  std::chrono::system_clock::time_point tp_;\n\n public:\n  static inline auto now() { return std::chrono::system_clock::now(); }\n  inline void tic() { tp_ = now(); }\n  inline auto toc() const { return std::chrono::duration_cast<C>(now() - tp_).count(); }\n  inline Timer() : tp_(now()) {}\n};\ninline std::ostream& operator<<(std::ostream& o, const Timer<>& t) {\n  return o << (long long)t.toc();\n}","path":"/src/cpp/implements/method/time/tictoc.hpp","references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"SuffixArray","overview":"","usage":"","require":"#include <vector>\n#include <string>\n#include <cassert>\nusing namespace std;","verified":["tested"],"references":["蟻本","http://wk1080id.hatenablog.com/entry/2018/12/25/005926v"],"code":"class SuffixArray {\n  const char* str;\n  int size;\n  vector<const char*> sa;\n  string keeper;\n\n public:\n  SuffixArray() {}\n  SuffixArray(const string& d) {\n    str = d.c_str();\n    size = d.size();\n    assert(str[size] == 0);\n    ++size;\n  }\n  SuffixArray(string&& d) {\n    keeper = move(d);\n    str = keeper.c_str();\n    size = keeper.size();\n    assert(str[size] == 0);\n    ++size;\n  }\n\n  void build() {\n    const int Alpha = 128;\n    vector<int> sfx(size);                  // suffix array permutation\n    vector<int> div(size);                  // division\n    vector<int> cnt(max(size + 1, Alpha));  // counter\n\n    for (int i = 0; i < size; ++i)\n      cnt[str[i]] += 1;\n    for (int i = 1; i < Alpha; ++i)\n      cnt[i] += cnt[i - 1];\n    for (int i = 0; i < size; ++i)\n      sfx[--cnt[str[i]]] = i;\n\n    div[sfx[0]] = 0;\n    for (int i = 1; i < size; ++i)\n      div[sfx[i]] = div[sfx[i - 1]] + (str[sfx[i - 1]] < str[sfx[i]]);\n\n    for (int d = 1; d < size; d *= 2) {\n      vector<int> sfx2(size);\n      {\n        fill(cnt.begin(), cnt.end(), 0);\n        for (int i = 0; i < size; ++i)\n          cnt[div[(sfx[i] - d + size) % size]] += 1;\n        for (int i = 1; i <= size; ++i)\n          cnt[i] += cnt[i - 1];\n        for (int i = size - 1; 0 <= i; --i) {\n          sfx2[--cnt[div[(sfx[i] - d + size) % size]]] = (sfx[i] - d + size) % size;\n        }\n      }\n      sfx2.swap(sfx);\n      vector<int> div2(size);\n      div2[sfx[0]] = 0;\n      int acc = 0;\n      for (int i = 1; i < size; ++i) {\n        pair<int, int> curr = {div[sfx[i]], div[(sfx[i] + d) % size]};\n        pair<int, int> prev = {div[sfx[i - 1]], div[(sfx[i - 1] + d) % size]};\n        div2[sfx[i]] = div2[sfx[i - 1]] + (curr != prev);\n      }\n      div2.swap(div);\n    }\n    sa.resize(size);\n    for (int i = 0; i < size; ++i)\n      sa[i] = str + sfx[i];\n  }\n\n  pair<bool, pair<int, int>> find(const string& keyword) {\n    auto n = keyword.size();\n\n    if (n == 0)\n      return make_pair(false, make_pair(0, -1));\n\n    int low = 0;\n    int high = sa.size() - 1;\n\n    for (int i = 0; i < n; ++i) {\n      int ng, ok;\n      ng = low - 1;\n      ok = high;\n      while (ok - ng > 1) {\n        int m = (ok + ng) / 2;\n        if (keyword[i] <= *(sa[m] + i))\n          ok = m;\n        else\n          ng = m;\n      }\n      low = ok;\n\n      ng = high + 1;\n      ok = low;\n      while (ng - ok > 1) {\n        int m = (ok + ng) / 2;\n        if (keyword[i] >= *(sa[m] + i))\n          ok = m;\n        else\n          ng = m;\n      }\n      high = ok;\n\n      if (low > high || keyword[i] != *(sa[low] + i) || keyword[i] != *(sa[high] + i))\n        return make_pair(false, make_pair(0, -1));\n    }\n    return make_pair(true, make_pair(low, high));\n  }\n\n  inline int foundToIdx(int found) { return sa[found] - str; }\n};","path":"/src/cpp/string/datastructure/suffixarray.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"manacher(一括回文判定)","overview":"manacher\ncount_num() はO(|S|)で動作するので注意 [TODO]","usage":"bool operator()(int left, int right)\nleft  : 文字列のインデックスを指定する．\nright :\n@ret : 部分文字列str[left..right]が回文かどうか．","require":"#include <vector>\n#include <string>\nusing namespace std;","verified":["https://yukicoder.me/submissions/139334"],"references":["http://snuke.hatenablog.com/entry/2014/12/02/235837","https://yukicoder.me/problems/no/464/editorial"],"code":"class Manacher {\n public:\n  vector<int> radius_;\n\n  Manacher() {}\n  Manacher(const string& str) { build(str); }\n\n  void build(const string& str) {\n    int length = str.size() * 2 - 1;\n    radius_.resize(length);\n\n    int c = 0;\n    for (int i = 0; i < length; i++) {\n      int l = c - (i - c);\n      if (i + radius_[l] < c + radius_[c]) {\n        radius_[i] = radius_[l];\n      } else {\n        int j = c + radius_[c] - i;\n        for (; i - j >= 0 && i + j < length; j++) {\n          if (((i ^ j) & 1) == 1)\n            continue;\n          if (str[(i - j) / 2] != str[(i + j) / 2])\n            break;\n        }\n        radius_[i] = j;\n        c = i;\n      }\n    }\n  }\n\n  inline int operator[](int idx) const { return radius_[idx]; }\n  inline size_t size() const { return radius_.size(); }\n\n  // 部分文字列str[left..right]が回文かどうか．計算量O(1)\n  // left,rightに指定するインデックスは，基の文字列のインデックスを指定する．\n  inline bool operator()(int left, int right) { return radius_[left + right] > right - left; }\n\n  // 回文の個数を求める．\n  long long count_num() {\n    long long r = 0;\n    for (auto it = radius_.begin(); it < radius_.end(); ++it, ++it) {\n      r += (*it + 1ll) / 2ll;\n    }\n    for (auto it = radius_.begin() + 1; it < radius_.end(); ++it, ++it) {\n      r += (*it) / 2ll;\n    }\n    return r;\n  }\n\n  // void print(const string& str) {\n  //   for (int i = 0; i < str.size(); i++) {\n  //     cout << str[i] << \" \";\n  //   }\n  //   cout << endl;\n  //   for (int i = 0; i < radius_.size(); i++) {\n  //     cout << radius_[i];\n  //   }\n  //   cout << endl;\n  // }\n};","path":"/src/cpp/string/datastructure/manacher.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"ローリングハッシュ","overview":"連続した部分文字列のハッシュをO(N)で求める．\n2つのハッシュで撃墜をなるべく避ける．","usage":"pair<rh_t, rh_t> rollinghash::operator()(int begin, int end)\n連続した部分文字列str[begin,end)のハッシュの組を取得する","require":"#include <vector>\n#include <string>\nusing namespace std;","verified":["csaで使ったはず"],"references":["プログラミングチャレンジブック"],"code":"class RollingHash {\n public:\n  using rh_t = unsigned long long;\n\n private:\n  static const rh_t MD_1 = (rh_t)(1e9 + 21);\n  static const rh_t PW = (rh_t)(1e9 + 7);\n  static vector<rh_t> pow_table__[2];\n\n public:\n  vector<rh_t> hashes_[2];\n\n  RollingHash() {}\n  RollingHash(const string& s) { build(s); }\n\n  inline pair<rh_t, rh_t> operator()(int begin, int end) {\n    return pair<rh_t, rh_t>(\n        (hashes_[0][end] - hashes_[0][begin] * pow_table__[0][end - begin]),\n        (hashes_[1][end] - (hashes_[1][begin] * pow_table__[1][end - begin]) % MD_1 + MD_1) % MD_1);\n  }\n\n  void build_pow(size_t size) {\n    ++size;\n    if (pow_table__[0].size() < size) {\n      pow_table__[0].reserve(size);\n      pow_table__[1].reserve(size);\n      if (pow_table__[0].empty())\n        pow_table__[0].push_back(1), pow_table__[1].push_back(1);\n      for (size_t i = pow_table__[0].size(); i < size; ++i) {\n        pow_table__[0].push_back(pow_table__[0].back() * PW);\n        pow_table__[1].push_back(pow_table__[1].back() * PW % MD_1);\n      }\n    }\n  }\n  void build(const string& src) {\n    size_t m = src.size() + 1;\n    build_pow(m);\n    hashes_[0].resize(m);\n    hashes_[1].resize(m);\n    hashes_[0][0] = hashes_[1][0] = 0;\n    for (size_t i = 1; i < m; ++i) {\n      rh_t c = src[i - 1];\n      hashes_[0][i] = hashes_[0][i - 1] * PW + c;\n      hashes_[1][i] = (hashes_[1][i - 1] * PW + c) % MD_1;\n    }\n  }\n};\nvector<RollingHash::rh_t> RollingHash::pow_table__[2];","path":"/src/cpp/string/datastructure/rollinghash.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"正規表現[TODO]","overview":"簡単に書いてみた．TODOリストとして追加．","usage":"\"+*?.\" を特殊文字扱いする．","require":"#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n#include <tuple>\nusing namespace std;","verified":[],"references":[],"code":"struct RegExp {\n  template <typename T>\n  struct Range {\n    T begin, tail;\n    inline Range(T _begin, T _end) : begin(_begin), tail(_end) {}\n    inline explicit Range(T _single) : begin(_single), tail(_single) {}\n    inline Range() : begin(0), tail(0) {}\n\n    inline bool cover(T x) const noexcept { return begin <= x && x <= tail; }\n  };\n\n  struct CharSet {\n    vector<pair<Range<char>, bool>> ranges_;\n    inline CharSet() {}\n    inline CharSet(const CharSet& cs) : ranges_(cs.ranges_) {}\n    inline CharSet(CharSet&& cs) : ranges_(move(cs.ranges_)) {}\n    inline explicit CharSet(const Range<char>& r) { push(r); }\n    inline explicit CharSet(char c) { push(Range<char>(c)); }\n\n    void push(const Range<char>& r, bool negative = false) { ranges_.emplace_back(r, negative); }\n    inline bool cover(char c) const {\n      return any_of(ranges_.begin(), ranges_.end(), [c](const pair<Range<char>, bool>& p) {\n        return p.second ^ (p.first.cover(c));\n      });\n    }\n    static const CharSet Any;\n  };\n\n  enum struct ERep {\n    J1,  // 1個\n    M1,  // 1個以上\n    M0,  // 0個以上\n    L1,  // 1個以下\n  };\n\n  struct Node {\n    CharSet chr;\n    ERep type;\n    inline explicit Node(CharSet&& _chr, ERep _type = ERep::J1) : chr(_chr), type(_type) {}\n    inline explicit Node(const CharSet& _chr, ERep _type = ERep::J1) : chr(_chr), type(_type) {}\n    inline bool match(char c) const { return chr.cover(c); }\n    // 0文字の一致を認めるか\n    inline bool isOk0() const noexcept { return type == ERep::L1 || type == ERep::M0; }\n    // 2文字以上の一致を認めるか\n    inline bool isOkMany() const noexcept { return type == ERep::M1 || type == ERep::M0; }\n  };\n\n  vector<Node> pattern_;  // TODO: Link NFA\n\n  tuple<size_t, CharSet> parseCharSet(const string& rawPattern, size_t startPtr = 0) {\n    int escape = 0;\n\n    CharSet charset;\n    bool enable_range = false;\n    bool enable_holderLastChr = false;\n    char holderLastChr;\n    bool negative = false;\n\n    for (size_t i = startPtr; i < rawPattern.size(); ++i) {\n      char c = rawPattern[i];\n      char cL = rawPattern[i - 1];  // C++11\n      char cP = rawPattern[i + 1];\n\n      if (escape == 0 && c == ']') {\n        assert(enable_range == false);\n        if (enable_holderLastChr)  // charが余っているならばcharsetに入れる\n          charset.push(Range<char>(holderLastChr));\n        return make_tuple(i, charset);\n      } else if (escape == 0 && c == '-') {\n        assert(enable_holderLastChr == true);\n        assert(enable_range == false);\n        enable_range = true;\n      } else if (escape == 0 && c == '^') {\n        assert(negative == false);\n        negative = true;\n      } else if (escape == 0 && c == '/') {\n        escape = 1;\n      } else {\n        if (enable_range) {\n          assert(enable_holderLastChr == true);\n          if (holderLastChr > c)\n            charset.push(Range<char>(c, holderLastChr));\n          else\n            charset.push(Range<char>(holderLastChr, c));\n          enable_holderLastChr = false;\n          enable_range = false;\n          negative = false;\n        } else {\n          if (enable_holderLastChr)  // charが余っているならばcharsetに入れる\n            charset.push(Range<char>(holderLastChr), negative), negative = false;\n          enable_holderLastChr = true;\n          holderLastChr = c;  // holderLastChrに値を入れておく\n        }\n        escape = 0;\n      }\n    }\n    abort();\n  }\n\n  int parse(const string& rawPattern, size_t startPtr = 0) {\n    int escape = 0;\n\n    for (size_t ptr = startPtr; ptr < rawPattern.size(); ++ptr) {\n      char c = rawPattern[ptr];\n      // char cL = rawPattern[ptr - 1]; // C++11\n      // char cP = rawPattern[ptr + 1];\n\n      // open\n      if (escape == 1) {\n        // escaped\n        // 特定の文字として解釈\n        pattern_.emplace_back(CharSet(c));\n        escape = 0;\n      } else if (c == '+') {\n        // 1つ以上\n        if (pattern_.empty())\n          abort();\n        pattern_.back().type = ERep::M1;  // TODO:\n      } else if (c == '*') {\n        // 0個以上\n        if (pattern_.empty())\n          abort();\n        pattern_.back().type = ERep::M0;\n      } else if (c == '?') {\n        // 0か1つ\n        if (pattern_.empty())\n          abort();\n        pattern_.back().type = ERep::L1;\n      } else if (c == '.') {\n        // 任意の文字\n        pattern_.emplace_back(CharSet::Any);\n      } else if (c == '[') {\n        // 特定の範囲の文字\n        auto ret = parseCharSet(rawPattern, ptr + 1);\n        ptr = get<0>(ret);\n        pattern_.emplace_back(move(get<1>(ret)));\n      } else if (c == '/') {\n        // escape\n        escape = 1;\n      } else {\n        // 特定の文字\n        pattern_.emplace_back(CharSet(c));\n      }\n    }\n  }\n\n  RegExp(const string& rawPattern) { parse(rawPattern); }\n\n  bool match(const string& text) {\n    vector<bool> dp1(pattern_.size() + 1);  // current dp\n    vector<bool> dp2(pattern_.size() + 1);  // next dp\n    dp1[0] = true;\n\n    for (char c : text) {\n      for (size_t pi = 0; pi < pattern_.size(); ++pi) {\n        if (!dp1[pi])\n          continue;\n\n        if (pattern_[pi].match(c)) {\n          dp2[pi + 1ull] = true;  // 次のパターンに進む\n          if (pattern_[pi].isOkMany())\n            dp2[pi] = true;  // 次のパターンに進まなくても良い\n        }\n        if (pattern_[pi].isOk0())\n          dp1[pi + 1ull] = true;  // 今のパターンをスキップする\n      }\n      dp1.swap(dp2);\n      fill(dp2.begin(), dp2.end(), false);\n    }\n\n    for (size_t pi = 0; pi < pattern_.size(); ++pi) {\n      if (!dp1[pi])\n        continue;\n      if (pattern_[pi].isOk0())\n        dp1[pi + 1ull] = true;  // 今のパターンをスキップする\n    }\n\n    return dp1[pattern_.size()];\n  }\n};\nconst RegExp::CharSet RegExp::CharSet::Any =\n    RegExp::CharSet(RegExp::Range<char>(numeric_limits<char>::min(), numeric_limits<char>::max()));\n\nvoid test() {\n  {\n    RegExp r(\"a.c\");\n    assert(r.match(\"abc\") == true);\n    assert(r.match(\"acc\") == true);\n    assert(r.match(\"abb\") == false);\n    assert(r.match(\"acd\") == false);\n    assert(r.match(\"ac\") == false);\n    assert(r.match(\"\") == false);\n  }\n  {\n    RegExp r(\"a+c\");\n    assert(r.match(\"aac\") == true);\n    assert(r.match(\"ac\") == true);\n    assert(r.match(\"c\") == false);\n    assert(r.match(\"acc\") == false);\n    assert(r.match(\"a\") == false);\n  }\n  {\n    RegExp r(\"a*c\");\n    assert(r.match(\"aac\") == true);\n    assert(r.match(\"ac\") == true);\n    assert(r.match(\"c\") == true);\n    assert(r.match(\"acc\") == false);\n    assert(r.match(\"a\") == false);\n  }\n  {\n    RegExp r(\"ab?c\");\n    assert(r.match(\"abc\") == true);\n    assert(r.match(\"ac\") == true);\n    assert(r.match(\"adc\") == false);\n    assert(r.match(\"acc\") == false);\n  }\n  {\n    RegExp r(\".\");\n    assert(r.match(\"a\") == true);\n    assert(r.match(\"z\") == true);\n    assert(r.match(\"aa\") == false);\n    assert(r.match(\"zz\") == false);\n    assert(r.match(\"\") == false);\n  }\n  {\n    RegExp r(\"..\");\n    assert(r.match(\"aa\") == true);\n    assert(r.match(\"zz\") == true);\n    assert(r.match(\"a\") == false);\n    assert(r.match(\"zzz\") == false);\n  }\n  {\n    RegExp r(\".*foo.*\");\n    assert(r.match(\"barfoobaz\") == true);\n    assert(r.match(\"foobaz\") == true);\n    assert(r.match(\"foo\") == true);\n    assert(r.match(\"fo\") == false);\n    assert(r.match(\"\") == false);\n  }\n  {\n    RegExp r(\".+a.*b.?\");\n    assert(r.match(\"xaybz\") == true);\n    assert(r.match(\"xxayybz\") == true);\n    assert(r.match(\"xwxab\") == true);\n    assert(r.match(\"aaab\") == true);\n    assert(r.match(\"aab\") == true);\n    assert(r.match(\"aabbbbb\") == true);\n    assert(r.match(\"abababa\") == true);\n    assert(r.match(\"abababaa\") == false);\n    assert(r.match(\"ab\") == false);\n    assert(r.match(\"abb\") == false);\n    assert(r.match(\"a\") == false);\n    assert(r.match(\"b\") == false);\n  }\n  {\n    RegExp r(\"b[b-dx]d\");\n    assert(r.match(\"bbd\") == true);\n    assert(r.match(\"bcd\") == true);\n    assert(r.match(\"bdd\") == true);\n    assert(r.match(\"bxd\") == true);\n    assert(r.match(\"bad\") == false);\n    assert(r.match(\"bed\") == false);\n    assert(r.match(\"ddd\") == false);\n    assert(r.match(\"bbb\") == false);\n  }\n  {\n    RegExp r(\"[a-z][a-z0-9]*\");\n    assert(r.match(\"regexp\") == true);\n    assert(r.match(\"mt19937\") == true);\n    assert(r.match(\"destr0yer\") == true);\n    assert(r.match(\"1024\") == false);\n    assert(r.match(\"200ok\") == false);\n    assert(r.match(\"a\") == true);\n    assert(r.match(\"1\") == false);\n  }\n  {\n    RegExp r(\"/[[o/-x]+/]\");\n    assert(r.match(\"[o-x]\") == true);\n    assert(r.match(\"[oo]\") == true);\n    assert(r.match(\"[-]\") == true);\n    assert(r.match(\"[]\") == false);\n    assert(r.match(\"[xx\") == false);\n    assert(r.match(\"[\") == false);\n    assert(r.match(\"[[ooxx]\") == false);\n  }\n\n  // cout << \"ok\" << endl;\n}","path":"/src/cpp/string/datastructure/regexp.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"trie tree","overview":"文字列(あるいは配列)の集合を管理する．\nmap<string,int> みたいなイメージ","usage":"TVAL& operator()(IBEGIN begin, IEND end)\n配列[begin,end)に対応するTVALの参照を返す","require":"#include <map>\nusing namespace std;","verified":["(旧) : http://yukicoder.me/submissions/123054"],"references":["プログラミングチャレンジブック"],"code":"template <typename TKEY = char, typename TVAL = int>\nstruct TrieTree {\n  TVAL value;\n  map<TKEY, TrieTree> trie;\n  TrieTree(TVAL v) : value(v) {}\n  TrieTree() : value(0) {}\n\n  template <typename IBEGIN, typename IEND>\n  TVAL& operator()(IBEGIN begin, IEND end) {\n    auto begin_succ = begin;\n    return (begin == end) ? value : trie[*begin](++begin_succ, end);\n  }\n};","path":"/src/cpp/string/datastructure/trie.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"Wavelet Tree (Wavelet Matrix)","overview":"試作品．メソッドは殆ど実装していない．\n完備辞書の代わりにBITを使っている","usage":"","require":"#include <vector>\n#include <string>\n#include \"src/cpp/container/likermq/bit.hpp\"\nusing namespace std;","verified":[],"references":["岡之原大輔，高速文字列解析の世界，岩波書店．"],"code":"class Wavelet {\n public:\n  const int kChrSizeLg = 5;\n  const int kChrSize = 1 << kChrSizeLg;\n\n  const int size_;\n  vector<Bitree<int>> tree_;\n  vector<int> zerocnt_;\n\n  void build(const vector<char>& _raw) {\n    tree_.reserve(kChrSizeLg);\n    for (int i = 0; i < kChrSizeLg; ++i)\n      tree_.emplace_back(size_);\n    zerocnt_.resize(kChrSizeLg);\n\n    vector<char> stac = _raw;\n    vector<char> stac0, stac1;\n    stac0.reserve(size_);\n    stac1.reserve(size_);\n\n    for (int d = 0; d < kChrSizeLg; ++d) {\n      stac0.clear();\n      stac1.clear();\n      int cnt = 0;\n      for (char c : stac) {\n        int bit = (c & (1 << d)) >> d;\n        tree_[d].add(cnt + 1, bit);\n        if (bit)\n          stac1.push_back(c);\n        else\n          stac0.push_back(c);\n        ++cnt;\n      }\n      stac.clear();\n      stac.insert(stac.end(), stac0.begin(), stac0.end());\n      stac.insert(stac.end(), stac1.begin(), stac1.end());\n      zerocnt_[d] = stac0.size();\n    }\n  }\n\n  // void dump() {\n  //   for (int d = 0; d < kChrSizeLg; ++d) {\n  //     for (int i = 0; i < size_; ++i)\n  //       cout << tree_[d].get(i + 1);\n  //     cout << endl;\n  //   }\n  // }\n\n  Wavelet(const vector<char>& _raw) : size_(_raw.size()) { build(_raw); }\n\n  char get(int i) {\n    char data = 0;\n    for (int d = 0; d < kChrSizeLg; ++d) {\n      char b = tree_[d].get(i + 1);  // 0 or 1\n      data |= b << d;\n      i = b ? zerocnt_[d] + tree_[d].sum(i) : i - tree_[d].sum(i);\n    }\n    return data;\n  }\n\n  // [0,i)の文字cの出現回数\n  int rank(int i, char c) { return 0; }  // TODO:\n};","path":"/src/cpp/string/datastructure/wavelet.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"回文判定","overview":"コピペと手打ちどっちが速いかな","usage":"","require":"#include <string>\nusing namespace std;","verified":[],"references":[],"code":"bool iskaibun(const string& str) {\n  for (int left = 0, right = (int)str.size() - 1; left < right; ++left, --right)\n    if (str[left] != str[right])\n      return false;\n  return true;\n}","path":"/src/cpp/string/method/palindrome.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"行列の基本操作","overview":"行列同士の+-*，スカラーとの+-*/，べき乗を実装","usage":";定数配列を指定する時は，\nMatrix<ll> mat(3, 3, {\n1, 2, 3,\n3, 1, 2,\n2, 3, 1\n});","require":"#include <iomanip>\n#include <valarray>\n#include <ostream>\nusing namespace std;","verified":["https://beta.atcoder.jp/contests/arc027/submissions/3095831","など"],"code":"template <typename T>\n// using T = double;\nclass Matrix {\n public:\n  size_t height_, width_;\n  valarray<T> data_;\n  Matrix(size_t height = 1, size_t width = 1)\n      : height_(height), width_(width), data_(height * width) {}\n  template <typename V>\n  Matrix(size_t height, size_t width, const V& data)\n      : height_(height), width_(width), data_(data) {}\n  Matrix(size_t height, size_t width, initializer_list<T> init)\n      : height_(height), width_(width), data_(init) {}\n\n  inline T& operator()(size_t y, size_t x) { return data_[y * width_ + x]; }\n  inline T operator()(size_t y, size_t x) const { return data_[y * width_ + x]; }\n  inline T& at(size_t y, size_t x) { return data_[y * width_ + x]; }\n  inline T at(size_t y, size_t x) const { return data_[y * width_ + x]; }\n  inline void resize(size_t h, size_t w) {\n    height_ = h;\n    width_ = w;\n    data_.resize(h * w);\n  }\n  inline void resize(size_t h, size_t w, T val) {\n    height_ = h;\n    width_ = w;\n    data_.resize(h * w, val);\n  }\n  inline void fill(T val) { data_ = val; }\n  Matrix<T>& setDiag(T val) {\n    for (size_t i = 0, en = min(width_, height_); i < en; ++i)\n      at(i, i) = val;\n    return *this;\n  }\n\n  void print(ostream& os) {\n    os << \"- - -\" << endl;  //  << setprecision(3)\n    for (size_t y = 0; y < height_; ++y) {\n      for (size_t x = 0; x < width_; ++x) {\n        os << setw(7) << at(y, x) << ' ';\n      }\n      os << endl;\n    }\n  }\n};\ntemplate <typename T>\ninline ostream& operator<<(ostream& os, Matrix<T> mat) {\n  mat.print(os);\n  return os;\n}\n\ntemplate <typename T>\nMatrix<T> multiply(const Matrix<T>& mat1, const Matrix<T>& mat2) {\n  assert(mat1.width_ == mat2.height_);\n  Matrix<T> result(mat1.height_, mat2.width_);\n  for (size_t i = 0; i < mat1.height_; ++i)\n    for (size_t j = 0; j < mat2.width_; ++j)\n      for (size_t k = 0; k < mat1.width_; ++k)\n        result(i, j) += mat1(i, k) * mat2(k, j);\n  return result;\n}\ntemplate <typename T, typename V>\nV multiply(const Matrix<T>& mat1, const V& vec2) {\n  assert(mat1.width_ == vec2.size());\n  V result(mat1.height_);\n  for (size_t i = 0, j; i < mat1.height_; ++i)\n    for (j = 0; j < mat1.width_; ++j)\n      result[i] += mat1(i, j) * vec2[j];\n  return result;\n}\n\ntemplate <typename T>\ninline Matrix<T>& operator+=(Matrix<T>& mat, T val) {\n  mat.data_ += val;\n  return mat;\n}\ntemplate <typename T>\ninline Matrix<T>& operator-=(Matrix<T>& mat, T val) {\n  mat.data_ -= val;\n  return mat;\n}\ntemplate <typename T>\ninline Matrix<T>& operator*=(Matrix<T>& mat, T val) {\n  mat.data_ *= val;\n  return mat;\n}\ntemplate <typename T>\ninline Matrix<T>& operator/=(Matrix<T>& mat, T val) {\n  mat.data_ /= val;\n  return mat;\n}\ntemplate <typename T>\ninline Matrix<T>& operator^=(Matrix<T>& mat, T val) {\n  mat.data_ ^= val;\n  return mat;\n}\ntemplate <typename T>\ninline Matrix<T>& operator+=(Matrix<T>& mat1, const Matrix<T>& mat2) {\n  mat1.data_ += mat2.data_;\n  return mat1;\n}\ntemplate <typename T>\ninline Matrix<T> operator+(Matrix<T>& mat1, const Matrix<T>& mat2) {\n  return Matrix<T>(mat1.height_, mat1.width_, mat1.data_ + mat2.data_);\n}\ntemplate <typename T>\ninline Matrix<T>& operator-=(Matrix<T>& mat1, const Matrix<T>& mat2) {\n  mat1.data_ -= mat2.data_;\n  return mat1;\n}\ntemplate <typename T>\ninline Matrix<T> operator-(Matrix<T>& mat1, const Matrix<T>& mat2) {\n  return Matrix<T>(mat1.height_, mat1.width_, mat1.data_ - mat2.data_);\n}\ntemplate <typename T>\ninline Matrix<T>& operator*=(Matrix<T>& mat1, const Matrix<T>& mat2) {\n  mat1 = multiply(mat1, mat2);\n  return mat1;\n}\ntemplate <typename T>\ninline Matrix<T> operator*(const Matrix<T>& mat1, const Matrix<T>& mat2) {\n  return multiply(mat1, mat2);\n}\ntemplate <typename T, typename V>\ninline V operator*(const Matrix<T>& mat1, const V& vec2) {\n  return multiply(mat1, vec2);\n}\n\ntemplate <typename T>\nMatrix<T> pow(Matrix<T> a, long long p) {\n  assert(a.height_ == a.width_);\n  Matrix<T> b(a.height_, a.height_);\n  b.setDiag(1);\n  while (0 < p) {\n    if (p & 1)\n      b *= a;\n    a *= a;\n    p >>= 1;\n  }\n  return b;\n}","path":"/src/cpp/math/datastructure/matrix.hpp","words":[],"references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"剰余演算付き整数型(llmod)","overview":"MODを法として計算する．\nMODを超える値の引き算を行う際に値を拾うと，負になることがある．\njustifyを呼ぶことで，llmod::val_を[0,MOD) の範囲に収める．","usage":"[TODO]","require":"#include <ostream>","verified":["verify: https://yukicoder.me/submissions/183521","verify: https://yukicoder.me/submissions/183523"],"code":"class llmod {\n private:\n  using value_type = long long;\n  value_type val_;\n  // inline ll cut(ll v) const { return ((v%MOD) + MOD) % MOD; } // safe\n public:\n  static const value_type MOD = 1000000007;  // <=\n\n  llmod() : val_(0) {}\n  llmod(value_type num) : val_(((num % MOD) + MOD) % MOD) {}\n\n  inline operator value_type() const { return val_; }\n  inline value_type operator*() const { return val_; }\n  inline llmod& operator=(const llmod& lm) {\n    val_ = lm.val_;\n    return *this;\n  }\n  inline llmod& operator=(value_type v) {\n    val_ = (v) % MOD;\n    return *this;\n  }\n\n  inline llmod& operator+=(value_type v) {\n    val_ = (val_ + v) % MOD;\n    return *this;\n  }\n  inline llmod& operator+=(const llmod& l) {\n    val_ = (val_ + l.val_) % MOD;\n    return *this;\n  }\n  inline llmod& operator-=(value_type v) {\n    val_ = (val_ - v + MOD) % MOD;\n    return *this;\n  }\n  inline llmod& operator-=(const llmod& l) {\n    val_ = (val_ - l.val_ + MOD) % MOD;\n    return *this;\n  }\n  inline llmod& operator*=(value_type v) {\n    val_ = (val_ * v) % MOD;\n    return *this;\n  }\n  inline llmod& operator*=(const llmod& l) {\n    val_ = (val_ * l.val_) % MOD;\n    return *this;\n  }\n  inline llmod& operator++() {\n    val_ = (val_ + 1) % MOD;\n    return *this;\n  }\n  inline llmod operator++(int) {\n    llmod t = *this;\n    val_ = (val_ + 1) % MOD;\n    return t;\n  }\n  inline llmod& justify() {\n    val_ = ((val_ % MOD) + MOD) % MOD;\n    return *this;\n  }\n  friend llmod pow(llmod, long long);\n};\ninline std::ostream& operator<<(std::ostream& os, const llmod& l) {\n  os << *l;\n  return os;\n}\n\ninline llmod operator+(llmod t, const llmod& r) {\n  return t += r;\n}\ninline llmod operator-(llmod t, const llmod& r) {\n  return t -= r;\n}\ninline llmod operator*(llmod t, const llmod& r) {\n  return t *= r;\n}\n\n// MEMO : 逆元...pow(n,MD-2)\nllmod pow(llmod x, long long p) {\n  llmod::value_type y = 1;\n  llmod::value_type xval = x.justify();\n  while (0 < p) {\n    if (p & 1)\n      y = (xval * y) % llmod::MOD;\n    xval = (xval * xval) % llmod::MOD;\n    p >>= 1;\n  }\n  return llmod(y);\n}\n\ninline llmod& operator/=(llmod& l, const llmod& r) {\n  return l *= pow(r, llmod::MOD - 2);\n}","path":"/src/cpp/math/datastructure/llmod.hpp","words":[],"references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"回転角","overview":"1周をmodで表現するような角度の単位系で，\n角度xから角度yへ向きを変えるとき，xに加算するべき値\n例えば，mod=360の時，\nx=45, y=135ならば，return=90\nx=45, y=315ならば，return=-90\nx=45, y=450ならば，return=45\nx=45, y=-45ならば，return=-90","usage":"","require":"#include <cmath>\nusing namespace std;","verified":[],"code":"// 1周をmodで表現するような角度の単位系で，\n// 角度xから角度yへ向きを変えるとき，xに加算するべき値\ninline double diffangle(double x, double y, double mod) {\n  double a1 = fmod(y - x, mod), a2 = fmod(y - x + mod, mod), a3 = fmod(y - x - mod, mod);\n  return abs(a2) < abs(a1) ? (abs(a3) < abs(a2) ? a3 : a2) : (abs(a3) < abs(a1) ? a3 : a1);\n}","path":"/src/cpp/math/method/diffangle.hpp","words":[],"references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"組合せ計算(都度計算)","overview":"","usage":"T pow_md(T x, T p, T mod = MD)\n; xのp乗をmodで割ったもの．時間O(logp)\nT fact_md(T n, T mod = MD)\n; n!をmodで割ったもの．時間O(n)\nT nPr_md(T n, T r, T mod = MD)\nT nCr_md(T n, T r, T mod = MD)\nT nHr_md(T n, T r, T mod = MD)","require":"const long long MD = 1000000007;","words":["pow","fact","ncr","npr","nhr","nck","npk","nhk"],"verified":[],"code":"// MEMO : 逆元...pow_md(n,MOD-2,MOD)\ntemplate <typename T>\nT pow_md(T x, T p, T mod = MD) {\n  T y = 1;\n  x = x % mod;\n  for (; 0 < p; p >>= 1) {\n    if (p & 1)\n      y = y * x % mod;\n    x = x * x % mod;\n  }\n  return y;\n}\ntemplate <typename T>\nT fact_md(T n, T mod = MD) {\n  T p = 1;\n  for (; 1 < n; p = (p * n--) % mod)\n    ;\n  return p;\n}\ntemplate <typename T>\nT nPr_md(T n, T r, T mod = MD) {\n  T p = 1;\n  for (r = n - r; r < n; p = (p * n--) % mod)\n    ;\n  return p;\n}\ntemplate <typename T>\nT nCr_md(T n, T r, T mod = MD) {\n  if (n < 0 || r < 0 || n < r)\n    return 0;\n  if (n / 2 < r)\n    return nCr_md(n, n - r, mod);\n  T num = 1, den = 1;\n  for (; 0 < r; --r, --n)\n    num = num * n % mod, den = den * r % mod;\n  return num * pow_md(den, mod - 2, mod) % mod;\n}\ntemplate <typename T>\ninline T nHr_md(T n, T r, T mod = MD) {\n  return nCr_md(n - 1 + r, n - 1, mod);\n}\n\ntemplate <typename T>\nT nCr(T n, T r) {\n  if (n / 2 < r)\n    return nCr(n, n - r);\n  T p = 1;\n  for (T t = 1; t <= r; ++t)\n    p = p * (n - t + 1) / t;\n  return p;\n}\ntemplate <typename T>\ninline T nHr(T n, T r) {\n  return nCr(n - 1 + r, n - 1);\n}","path":"/src/cpp/math/method/combinatorics.hpp","references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"約数列挙","overview":"約数を列挙してvectorに格納する。\nソートはされていない。","usage":"","require":"#include <vector>","verified":["10..20"],"references":[],"words":["divisor"],"code":"std::vector<long long> generateDivisor(long long n) {\n  std::vector<long long> divs;\n  for (long long d = 1; d <= n / d; ++d) {\n    if (n / d * d == n) {\n      divs.push_back(d);\n      divs.push_back(n / d);\n    }\n  }\n  if (divs.size() >= 2 && divs[divs.size() - 1] == divs[divs.size() - 2])\n    divs.pop_back();\n  return divs;\n}","path":"/src/cpp/math/method/prime/generatedivisor.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"エラトステネスの篩","overview":"エラトステネスの篩\n生成する素数の数を静的に決めてしまう．\nコンパイルが異様に遅くなるので(compile TLE)，\n競技プログラミングではconstexprを付けないほうが無難","usage":"constexpr IsPrimeC<9999> ipc;\n; `ipc[x] == true` なら，xは!!素数!!\n\nconstexpr PrimeListC<9999> plc;\n; `plc[i]` i 番目の素数\n; イテレータあるよ\nmap<ll, int> PrimeListC::divison(ll);\n; 素因数分解する．","require":"#include <map>","verified":["[TODO]"],"references":[],"code":"template <int Max = 2000>\nclass IsPrimeC {\n  bool d_[Max + 1];\n\n  template <typename T>\n  static constexpr T cesqrt(T s) {\n    double x = s / 2.0;\n    double prev = 0.0;\n    while (x != prev) {\n      prev = x;\n      x = (x + s / x) / 2.0;\n    }\n    return x;\n  }\n\n public:\n  constexpr IsPrimeC() : d_() {\n    d_[0] = d_[1] = 1;\n    int sqh = cesqrt<int>(Max);\n    for (int i = 2; i <= sqh; i++) {\n      if (d_[i] == 0) {\n        for (int j = i * i; j <= Max; j += i) {  // i*i\n          d_[j] = 1;\n        }\n      }\n    }\n    for (int i = 0; i <= Max; ++i)\n      d_[i] = !d_[i];\n  }\n  constexpr inline bool operator[](int x) const { return d_[x]; }\n};\n\ntemplate <int Max = 2000>\nclass PrimeListC {\n  int d_[Max];\n\n public:\n  constexpr PrimeListC() : d_() {\n    int n = 1;\n    d_[0] = 2;\n    for (int x = 3; n < Max; ++x) {\n      bool f = true;\n      for (int i = 0; d_[i] * d_[i] <= x; ++i)\n        if (x / d_[i] * d_[i] == x) {\n          f = false;\n          break;\n        }\n      if (f)\n        d_[n++] = x;\n    }\n  }\n  constexpr inline int operator[](int x) const { return d_[x]; }\n  template <int _Max>\n  class iterator {\n    const PrimeListC<_Max>& pl;\n    int ptr = 0;\n\n   public:\n    constexpr iterator(const decltype(pl)& _pl, int _ptr = 0) : pl(_pl), ptr(_ptr) {}\n    constexpr int operator*() const { return pl[ptr]; }\n    constexpr iterator<_Max>& operator++() {\n      ptr++;\n      return *this;\n    }  // prefix\n    constexpr inline bool operator!=(const iterator<_Max>& it) const {\n      return ptr != it.ptr ? !(_Max < ptr && _Max < it.ptr) : false;\n    }\n    constexpr inline bool operator==(const iterator<_Max>& it) const {\n      return ptr != it.ptr ? (_Max < ptr && _Max < it.ptr) : true;\n    }\n  };\n  constexpr PrimeListC::iterator<Max> begin() const { return PrimeListC::iterator<Max>(*this, 0); }\n  constexpr PrimeListC::iterator<Max> end() const { return PrimeListC::iterator<Max>(*this, Max); }\n\n  std::map<long long, int> division(long long number) const {\n    std::map<long long, int> div;\n    for (int i = 0; number > 1 && i < Max; ++i) {\n      long long p = d_[i];\n      int c = 0;\n      while (number / p * p == number)\n        ++c, number /= p;\n      if (c > 0)\n        div[p] = c;\n    }\n    return div;\n  }\n};","path":"/src/cpp/math/method/prime/primesieve.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"エラトステネスの篩(動的生成)","overview":"エラトステネスの篩\nTODO: primesieve.cpp を動的にする","usage":"","verified":[],"references":[],"code":";\n// TODO!!","path":"/src/cpp/math/method/prime/primesieve_dynamic.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"素因数分解","overview":"素因数分解やるだけ。\n素数情報を必要としない。（素数情報を使うと早くなるはず）\n計算量は O(HlogH),H=sqrt(N)","usage":"map<ll, int> primeDivision(num);\n; <素数, 個数> の map として格納","require":"#include <map>","verified":[],"code":"std::map<long long, int> primeDivision(const long long _num) {\n  std::map<long long, int> result;\n  long long num = _num;\n  while ((num & 1) == 0) {\n    num /= 2;\n    ++result[2];\n  }\n  for (long long i = 3; 1 < num && i <= _num; i += 2) {\n    while (num / i * i == num) {\n      num /= i;\n      ++result[i];\n    }\n  }\n  return result;\n}","path":"/src/cpp/math/method/prime/primedivision.hpp","words":[],"references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"Miller窶迭abin primality test","overview":"素数判定する．\n2^63でも素数判定可能だが，__int128型を使う．","usage":"bool isprime_mr(ll val)\nx : N\n@ret : is N prime?","require":"using ll = long long;","verified":["https://yukicoder.me/submissions/210977"],"references":["https://qiita.com/gushwell/items/ff9ed83ba55350aaa369","https://yukicoder.me/submissions/210680"],"code":"ll powm_strict(ll x, ll p, ll mod = 1000000007ll) {\n  using ll128 = __int128_t;\n  ll y = 1;\n  x = x % mod;\n  while (0 < p) {\n    if ((p & 1) == 1)\n      y = (ll)((((ll128)y) * x) % mod);\n    x = (ll)((((ll128)x) * x) % mod);\n    p /= 2;\n  }\n  return y;\n}\n\n// Miller窶迭abin primality test\nbool isprime_MillerRabin(ll val) {\n  using ll128 = __int128_t;\n  static const ll test[12] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};\n  if (val <= 1 || (val & 1) == 0)\n    return val == 2;\n  for (auto t : test)\n    if (val % t == 0)\n      return val == t;\n  if (val < test[11] * test[11])\n    return true;\n  ll d = val - 1, s = 0;\n  while (!(d & 1)) {\n    ++s;\n    d >>= 1;\n  }  // d*2**s\n  for (auto t : test) {\n    ll z = powm_strict(t, d, val);\n    if (z == 1 || z == val - 1)\n      continue;\n    for (ll r = 1; r < s; ++r) {\n      z = (ll)((ll128)(z)*z % val);\n      if (z == val - 1)\n        goto l_isprime_mr_ct;\n    }\n    return false;\n  l_isprime_mr_ct:;\n  }\n  return true;\n}","path":"/src/cpp/math/method/prime/millerrabin.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"回文数の数え上げ","overview":"1以上val以下の整数で回文数が何個あるか数える．\nかなり甘い実装\n[TODO] 文字列に対しても実装する．","usage":"ll kaibunsu(ll val)","require":"using ll = long long;","code":"// 1以上10^i-1以下の整数\nll _kaibunsu_dec(int keta) {\n  if (keta <= 1)\n    return 9;\n  ll r = 1;\n  for (int i = 0; i < (keta + 1) / 2; ++i)\n    r *= 10;\n  return r - (r / 10) + _kaibunsu_dec(--keta);\n}\n// dfs列挙\nll _kaibunsu_dfs(ll low, ll high, ll kcl, ll kch, ll num = 0) {\n  if (kcl > kch) {\n    return (low <= num && num <= high);\n  }\n  ll result = 0;\n  for (ll k = (kcl == 1); k <= 9; ++k) {\n    result += _kaibunsu_dfs(low, high, kcl * 10, kch / 10, num + kcl * k + kch * k * (kcl != kch));\n  }\n  return result;\n}\n\n// 1以上val以下の整数で回文数が何個あるか\nll kaibunsu(ll val) {\n  if (val <= 9)\n    return val;\n  ll dec = 1;\n  int keta = 0;\n  while (val >= dec) {\n    dec *= 10;\n    ++keta;\n  }\n  dec /= 10;\n\n  return _kaibunsu_dfs(dec, val, 1, dec) + _kaibunsu_dec(--keta);\n}\n\n// 以下愚直．デバッグ用\n// --------------------------------------------------------------------------------\n//\nbool iskaibun(int val) {\n  if (val <= 9)\n    return 1;\n  int t, u;\n  t = 0;\n  u = val;\n  while (u) {\n    t = (t * 10) + (u % 10);\n    u /= 10;\n  }\n  while (t) {\n    if (val % 10 != t % 10)\n      return false;\n    val /= 10;\n    t /= 10;\n  }\n  return true;\n}\nint hetakuso(int val) {\n  int count = 0;\n  while (val) {\n    if (iskaibun(val--))\n      ++count;\n  }\n  return count;\n}","path":"/src/cpp/math/method/palindrome_number.hpp","words":[],"verified":[],"references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"高速ゼータ変換（メビウス逆変換）","overview":"ゼータ変換は，集合関数f(2^S)=Nを\ng(X) = sum{X⊆Y}(f(Y))\nに変換する．\nプログラミング上では，f,gは多くの場合，\n関数ではなく配列として表現される．\n高速ゼータ変換は，愚直に計算すると4^Nになるところ，\nN2^Nで計算するシンプルなDPである．","usage":"vector<value_t> zeta_transform(int n, vector<value_t> func);\nvector<value_t> mebius_transform(int n, vector<value_t> func)\n; 集合はビットで表現．\n; func.size() >= (1 << n) を満たす．","require":"#include <vector>\nusing namespace std;","verified":["unverified!!!"],"references":["https://topcoder.g.hatena.ne.jp/iwiwi/20120422/1335065228","https://naoyat.hatenablog.jp/entry/zeta-moebius","講義資料"],"words":["zeta"," mebius"],"code":"using value_t = int;\nvector<value_t> zeta_transform(int n, vector<value_t> func) {\n  for (int i = 0; i < n; ++i)\n    for (int b = 0; b < (1 << n); ++b)\n      if (~b & (1 << i))\n        func[b] += func[b | (1 << i)];\n  return func;\n}\n\nusing value_t = int;\nvector<value_t> mebius_transform(int n, vector<value_t> func) {\n  for (int i = 0; i < n; ++i)\n    for (int b = 0; b < (1 << n); ++b)\n      if (~b & (1 << i))\n        func[b] -= func[b | (1 << i)];\n  return func;\n}","path":"/src/cpp/math/method/zeta.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"組合せ計算(前計算)","overview":"inverse, conbination, permutation, factorial を構築時に計算する\\","usage":"Combinatorics<2000100, Mod> wakame;","words":["fact","ncr","npr","nck","npk"],"verified":["https://yukicoder.me/submissions/286997"],"code":"template <int MaxN, long long Mod>\nclass Combinatorics {\n  using value_type = long long;\n  value_type fact_[MaxN + 1];\n  // value_type inv_[MaxN + 1]; // iranai\n\n public:\n  constexpr value_type pow(value_type x, value_type p) const {\n    value_type y = 1;\n    x = x % Mod;\n    for (; 0 < p; p >>= 1) {\n      if (p & 1)\n        y = y * x % Mod;\n      x = x * x % Mod;\n    }\n    return y;\n  }\n\n  constexpr Combinatorics() : fact_() {\n    fact_[0] = 1;\n    fact_[1] = 1;\n    for (value_type n = 2; n <= MaxN; ++n)\n      fact_[n] = (fact_[n - 1] * n) % Mod;\n    // inv_[Max] := calculate;\n    // iterate => inv_[i] = inv_[i+1] * (i+1) % Mod;\n  }\n  constexpr value_type fact(int n) const { return fact_[n]; }\n\n  constexpr value_type inv(value_type n) const { return pow(n, Mod - 2); }\n\n  constexpr value_type nPr(value_type n, value_type r) const {\n    if (r < 0 || n < r)\n      return 0;\n    return fact_[n] * inv(fact_[n - r]) % Mod;\n  }\n  constexpr value_type nCr(value_type n, value_type r) const {\n    if (n < r)\n      return 0;\n    return ((fact_[n] * inv(fact_[n - r]) % Mod) * inv(fact_[r])) % Mod;\n  }\n  constexpr value_type nHr(value_type n, value_type r) const {\n    if (n == 0 && r == 0)\n      return 1;\n    if (n == 0)\n      return 0;\n    return nCr(n - 1 + r, n - 1);\n  }\n};","path":"/src/cpp/math/method/combinatorics_static.hpp","references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"一次方程式","overview":"焼きなましの近似式など．","usage":"double lerp(double px, double py, double qx, double qy, double x)\n; (px,py) (qx,qy) を通る直線の関数 y=f(x) の値．","code":"inline double lerp(double px, double py, double qx, double qy, double x) {\n  return py + (qy - py) * (x - px) / (qx - px);\n}\n// inline double lerp(const d2::Point& p, const d2::Point& q, double x) {\n//   return lerp(p.x, p.y, q.x, q.y, x);\n// }","path":"/src/cpp/math/method/lerp.hpp","words":[],"verified":[],"references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"最大公約数・最小公倍数","overview":"","usage":"T gcd(T a, T b)\n; a,bの最大公約数\nT lcm(T a, T b)\n; a,bの最小公倍数","verified":[],"references":[],"words":["gcd","lcm"],"code":"template <typename T>\ninline T gcd(T a, T b) {\n  while (b) {\n    T t = a % b;\n    a = b;\n    b = t;\n  }\n  return a;\n}\ntemplate <typename T>\ninline T lcm(T a, T b) {\n  return a * b / gcd(a, b);\n}","path":"/src/cpp/math/method/gcdlcm.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"簡易線形計画問題ソルバー[TODO]","overview":"等式形の線形計画問題を単体法で解く．","usage":"; 一番下のmain関数を見てください．","require":"#include <vector>\n#include <cstdio>\nusing namespace std;","verified":["http://www.fujilab.dnj.ynu.ac.jp/lecture/system2.pdf","https://yukicoder.me/submissions/213095","http://dic.nicovideo.jp/a/%E7%B7%9A%E5%BD%A2%E8%A8%88%E7%94%BB%E5%95%8F%E9%A1%8C","[TODO]"],"references":[],"code":"class EasyLP {\n public:\n  const int dimension;\n  // 左辺\n  vector<vector<double>> equation;\n  // 定数項\n  vector<double> offset;\n  // 目的関数\n  vector<double> objective;\n  // 求まった目的関数の値\n  double objective_c;\n\n  EasyLP(int n) : dimension(n), objective(n) {}\n\n  // 目的関数を最小化する．\n  // 式の情報は書き換えられる．\n  double minimize() {\n    while (true) {\n      // printTableau();\n      // 目的関数の値を減少させることができる変数を探す\n      int idx = 0;\n      {\n        double val = objective[0];\n        for (int i = 1; i < dimension; ++i) {\n          if (val > objective[i]) {\n            val = objective[i];\n            idx = i;\n          }\n        }\n        // 無いなら最適解が得られた\n        if (val >= 0)\n          break;\n      }\n\n      // どの程度まで増やせば良いだろうか\n      int target = -1;\n      {\n        double val, lim = 0;\n        for (int i = 0; i < equation.size(); ++i) {\n          if (equation[i][idx] == 0)\n            continue;  // 0除算防止\n          val = offset[i] / equation[i][idx];\n          if (0 < val && (target == -1 || val < lim)) {\n            lim = val;\n            target = i;\n          }\n        }\n      };\n      if (target == -1)\n        break;\n      {\n        // ピボット係数\n        double p = equation[target][idx];\n\n        // ピボット係数を p で除算\n        for (double& e : equation[target])\n          e /= p;\n        offset[target] /= p;\n\n        // ピボット列の掃き出し\n        for (int i = 0; i < equation.size(); ++i) {\n          if (i == target)\n            continue;\n\n          double d = equation[i][idx];\n          for (int j = 0; j < dimension; j++) {\n            if (j != idx)\n              equation[i][j] -= d * equation[target][j];\n            else\n              equation[i][j] = 0;\n          }\n\n          offset[i] -= d * offset[target];\n        }\n        {\n          double d = objective[idx];\n          for (int j = 0; j < dimension; j++) {\n            if (j != idx)\n              objective[j] -= d * equation[target][j];\n            else\n              objective[j] = 0;\n          }\n\n          objective_c += d * offset[target];\n        }\n      }\n    }\n    return -objective_c;\n  }\n\n  void printTableau() {\n    for (int i = 0; i < equation.size(); ++i) {\n      for (double a : equation[i]) {\n        printf(\" %7.2f\", a);\n      }\n      printf(\" | %7.2f\\n\", offset[i]);\n    }\n    for (int i = equation.size(); 0 <= i; --i) {\n      printf(\"---------\");\n    }\n    printf(\"\\n\");\n    for (double a : objective) {\n      printf(\" %7.2f\", a);\n    }\n    printf(\" %7.2f\\n#####\\n\", objective_c);\n  }\n};\n\nint main() {\n  {\n      // EasyLP lp(5);\n      // lp.equation.push_back({ 60.0, 40.0,  1.0,  0.0, 0.0 }); lp.offset.push_back(3800.0);\n      // lp.equation.push_back({ 20.0, 30.0,  0.0,  1.0, 0.0 }); lp.offset.push_back(2100.0);\n      // lp.equation.push_back({ 20.0, 10.0,  0.0,  0.0, 1.0 }); lp.offset.push_back(1200.0);\n      // lp.objective = { -400.0, -300.0, 0.0, 0.0, 0.0 };   lp.objective_c = 0.0;\n      //\n      // printf(\"%.7f\\n\", lp.minimize());\n  } {\n    EasyLP lp(6);\n    lp.equation.push_back({5.0, 1.0, 2.0, 1.0, 0.0, 0.0});\n    lp.offset.push_back(20.0);\n    lp.equation.push_back({2.0, 2.0, 6.0, 0.0, 1.0, 0.0});\n    lp.offset.push_back(30.0);\n    lp.equation.push_back({2.0, 6.0, 4.0, 0.0, 0.0, 1.0});\n    lp.offset.push_back(40.0);\n    lp.objective = {-1.0, -1.0, -1.0, 0.0, 0.0};\n    lp.objective_c = 0.0;\n\n    printf(\"%.7f\\n\", lp.minimize());\n  }\n  return 0;\n}","path":"/src/cpp/math/solver/lp.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"永続配列","overview":"通常の固定長配列の機能に加えて，undoを持つ．\nundoした操作をundo出来る．","usage":"void undo(int count)\n; count回数もとに戻る\nvector<value_t> get()\n; 現在の配列を取得する","require":"#include <vector>\n#include <cassert>\nusing namespace std;","verified":["[TODO]"],"references":[],"words":["persistent","stack","eizoku"],"tag":"wip","code":"struct PersistentArray {\n  using value_t = int;\n  struct Node {\n    enum Type { UPDATE, NONE };\n    Type type;\n    int index;\n    value_t val;\n    int next_idx;\n    Node(Type t = Type::NONE, int i = 0, value_t v = 0) : type(t), index(i), val(v) {}\n  };\n\n  int n;\n  vector<Node> history;\n\n  PersistentArray(int _size) : n(_size) { history.emplace_back(Node::Type::NONE); }\n\n  inline void update(int index, value_t val) {\n    Node node = Node(Node::Type::UPDATE, val);\n    node.next_idx = history.size() - 1;\n    history.push_back(node);\n  }\n\n  inline void undo(int count) {\n    int n = history.size();\n    assert(0 <= (n - 1 - count));\n    history.push_back(history[n - 1 - count]);\n  }\n\n  inline vector<value_t> get() {\n    int it = history.size() - 1;\n\n    vector<int> wrote(n);\n    vector<value_t> res(n);\n\n    while (history[it].type != Node::Type::NONE) {\n      const Node& node = history[it];\n      if (node.type == Node::Type::UPDATE) {\n        if (!wrote[node.index]) {\n          wrote[node.index] = true;\n          res[node.index] = node.val;\n        }\n      }\n      it = history[it].next_idx;\n    }\n\n    return res;\n  }\n};","path":"/src/cpp/container/persistent/parray.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"永続スタック","overview":"通常のスタックの機能に加えて，undoを持つ．\nundoした操作をundo出来る．","usage":"void undo(int count)\n; count回数もとに戻る\nvector<value_t> get()\n; 現在のスタックの状態を取得する","require":"#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;","verified":["乱数"],"references":["https://www.slideshare.net/qnighy/re-15443018"],"words":["persistent","stack","eizoku"],"code":"struct PersistentStack {\n  using value_t = int;\n  struct Node {\n    enum Type { PUSH, POP, NONE };\n    Type type;\n    value_t val;\n    int next_idx;\n    Node(Type t = PUSH, value_t v = 0) : type(t), val(v) {}\n  };\n\n  vector<Node> history;\n\n  PersistentStack() { history.emplace_back(Node::Type::NONE); }\n\n  inline void push(value_t val) {\n    Node node = Node(Node::Type::PUSH, val);\n    node.next_idx = history.size() - 1;\n    history.push_back(node);\n  }\n  inline void pop() {\n    Node node = Node(Node::Type::POP);\n    node.next_idx = history.size() - 1;\n    history.push_back(node);\n  }\n\n  inline void undo(int count) {\n    int n = history.size();\n    assert(0 <= (n - 1 - count));\n    history.push_back(history[n - 1 - count]);\n  }\n\n  inline vector<value_t> get() {\n    Node* p = &(history.back());\n\n    vector<value_t> res;\n    int popcount = 0;\n    while (p->type != Node::Type::NONE) {\n      if (p->type == Node::Type::PUSH) {\n        if (popcount > 0)\n          --popcount;\n        else\n          res.push_back(p->val);\n      } else if (p->type == Node::Type::POP) {\n        ++popcount;\n      }\n      p = &(history[p->next_idx]);\n    }\n    reverse(res.begin(), res.end());\n    return res;\n  }\n};","path":"/src/cpp/container/persistent/pstack.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"可変長bitset","overview":"乱数で雑に性能評価したがあんまり速度差が無い(環境によって若干速い・遅い)\nvector<bool> がバグる環境用","require":"#include <cstdint>\n#include <memory>\n#include <limits>\nusing namespace std;","usage":"","verified":["resizeが出来ていない"],"code":"class BitSet64 {\n public:\n  using allocator_type = std::allocator<uint64_t>;\n\n private:\n  allocator_type alloc_;\n  int nBlock_;\n  uint64_t* mem_;\n\n public:\n  inline BitSet64(int _n = 1) : nBlock_((_n + 63) >> 6) {\n    mem_ = allocator_traits<allocator_type>::allocate(alloc_, nBlock_);\n  }\n  inline BitSet64(const BitSet64& another) : nBlock_(another.nBlock_) {\n    mem_ = allocator_traits<allocator_type>::allocate(alloc_, nBlock_);\n    std::copy(another.mem_, another.mem_ + nBlock_, mem_);\n  }\n  inline BitSet64(BitSet64&& another)\n      : alloc_(another.alloc_), nBlock_(another.nBlock_), mem_(another.mem_) {\n    another.mem_ = nullptr;\n  }\n  ~BitSet64() {\n    if (mem_ != nullptr) {\n      allocator_traits<allocator_type>::deallocate(alloc_, mem_, nBlock_);\n      mem_ = nullptr;\n    }\n  }\n  inline bool operator[](uint64_t index) const { return (mem_[index >> 6] >> (index & 0x3f)) & 1; }\n  inline void set(uint64_t index, bool v) {\n    if (v)\n      mem_[index >> 6] |= uint64_t(1) << (index & 0x3f);\n    else\n      mem_[index >> 6] &= ~(uint64_t(1) << (index & 0x3f));\n  }\n  inline void set(uint64_t index) { mem_[index >> 6] |= uint64_t(1) << (index & 0x3f); }\n  inline void reset(uint64_t index) { mem_[index >> 6] &= ~(uint64_t(1) << (index & 0x3f)); }\n  inline void fill(bool v) {\n    std::fill(mem_, mem_ + nBlock_, v ? numeric_limits<uint64_t>::max() : (uint64_t)0);\n  }\n  inline void resize(int newSize) {\n    newSize >>= 6;\n    uint64_t* newmem_ = allocator_traits<allocator_type>::allocate(alloc_, nBlock_);\n    std::copy(mem_, mem_ + min(newSize, nBlock_), newmem_);\n    allocator_traits<allocator_type>::deallocate(alloc_, mem_, nBlock_);\n    nBlock_ = newSize;\n  }\n};","path":"/src/cpp/container/basic/bitset.hpp","words":[],"references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"SparseTable(区間最小)","overview":"構築済みの配列に対して，次のクエリを処理できる．\n- 区間の最小値を計算する．\n0-indexedで，[begin,end)．beginを含み，endを含まない．\n何度も加減算を繰り返すと内部でオーバーフローを起こす可能性．\nO(log^2N)．最大値のみの機能なら出来そう．[TODO]","usage":"SparseTable<typename T>(int n)\n; [0,n) の配列を確保する．\nT& SparseTable::operator[](size_t i)\n; i の要素の参照を得る．build後に更新してはならない．\nvoid SparseTable::build()\n; クエリに応えられるように準備する．\nvoid SparseTable::getminrangeIdx(int begin, int end)\n; 区間[begin,end)の最小値を計算する","require":"#include <vector>\nusing namespace std;","verified":["http://yukicoder.me/submissions/172470"],"references":["http://tookunn.hatenablog.com/entry/2016/07/13/211148"],"code":"template <typename T>\nclass SparseTable {\n public:\n  int size;\n  vector<int> log2;\n  vector<T> data;\n  vector<T> dp;\n\n  SparseTable(int size) : size(size), log2(size + 1), data(size) {\n    // for fast calculate log2\n    for (int i = 2; i <= size; ++i) {\n      log2[i] = log2[i >> 1] + 1;\n    }\n\n    dp.resize(size * (log2[size] + 1));\n  }\n\n  inline T& operator[](size_t i) { return data[i]; }\n  inline T operator[](size_t i) const { return data[i]; }\n\n  void build() {\n    int l, i, f, b;\n    for (i = 0; i < size; i++) {\n      dp[i] = i;\n    }\n    for (l = 1; (1 << l) <= size; l++) {\n      for (i = 0; i + (1 << l) <= size; i++) {\n        f = dp[i + size * (l - 1)];\n        b = dp[(i + (1 << (l - 1))) + size * (l - 1)];\n\n        dp[i + size * l] = (data[f] <= data[b]) ? f : b;  // minimum\n      }\n    }\n  }\n\n  // range [l,r)\n  int getminrangeIdx(int l, int r) const {\n    int lg = log2[r - l];\n    int i1 = dp[l + size * lg];\n    int i2 = dp[r - (1 << lg) + size * lg];\n    return (data[i1] <= data[i2]) ? i1 : i2;  // minimum\n  }\n};","path":"/src/cpp/container/likermq/rmq_sparsetable.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"Binary Indexed Tree(単独加算，区間総和)","overview":"次のクエリを処理できる．\n- １つの要素を加算・減算する．\n- 区間の要素の総和を計算する．\n1-indexedの実装に注意．\n何度も加減算を繰り返すと内部でオーバーフローを起こす可能性．","usage":"Bitree<typename T>(int n)\n; [1..n] の配列を確保する．\nT Bitree::sum(int r)\n; [1..r]の範囲の値の和を求める．\nT Bitree::add(int idx, T val)\n; idx の要素の値をval増やす\n; 1-indexed．","require":"#include <vector>\n#include <cstdint>\nusing namespace std;","verified":["二分探索が未だ出来ていない"],"references":["プログラミングコンテストチャレンジブック"],"code":"template <typename T = long long>\nclass Bitree {\n  const int size_;\n  vector<T> data_;\n  static int nlz(uint32_t x) {\n    union {\n      uint32_t i;\n      float f;\n    } data;\n    data.f = (float)x + 0.5;\n    return 158 - (data.i >> 23);\n  }\n\n public:\n  Bitree(int size_) : size_(size_), data_(size_ + 1) {}\n\n  // 1..rの範囲の値の和を求める．\n  T sum(int r) const {\n    T s = 0;\n    while (r) {\n      s += data_[r];\n      r -= r & -r;  //  r&-r と書くことで最下のビットを得る\n    }\n    return s;\n  }\n  // l..rの範囲の値の和を求める\n  inline T sum(int l, int r) const { return sum(r) - sum(l - 1); }\n  // i番目の値を求める(1index)\n  T get(int i) const {\n    int j = i - 1;\n    T s = 0;\n    while (i != j) {\n      s += data_[i] - data_[j];\n      i -= i & -i;\n      j -= j & -j;\n    }\n    return s;\n  }\n  // idxの要素の値をval増やす\n  void add(int idx, T val) {\n    while (idx <= size_) {\n      data_[idx] += val;\n      idx += idx & -idx;\n    }\n  }\n  // sum(i)がvalを超える最初のiを返す\n  // get(j)<0となるjが存在すると正しく動作しない\n  int upper_bound(T val) const {\n    int li = 1 << (31 - nlz(size_));\n    int p = 0;\n    T d = 0;\n    while (li && p < size_) {\n      T k = data_[p | li];\n      if (!(val < d + k))\n        p |= li, d += k;\n      li >>= 1;\n    }\n    if (p > size_)\n      p = size_;\n    return p + 1;\n  }\n  // sum(i)がval以上である最初のiを返す\n  // get(j)<0となるjが存在すると正しく動作しない\n  int lower_bound(T val) const {\n    int li = 1 << (31 - nlz(size_));\n    int p = 0;\n    T d = 0;\n    while (li && p < size_) {\n      T k = data_[p | li];\n      if (d + k < val)\n        p |= li, d += k;\n      li >>= 1;\n    }\n    if (p > size_)\n      p = size_;\n    return p + 1;\n  }\n};","path":"/src/cpp/container/likermq/bit.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"セグメント木","overview":"次のクエリを処理できる．時間計算量O(log_2(N))\n- 1つの要素を書き換える\n- 1つの要素に加算する\n- 1つの要素の値を求める\n- 区間の要素すべてを1つの値で埋める\n- 区間の要素すべてに加算する\n- 区間の要素の和を求める\n- 区間の要素の最大値を計算する\n0-indexedで，[begin,end)．beginを含み，endを含まない．\n空間計算量はO(4NX+NC)．X は sizeof(T)，C は sizeof(struct{int;bool;})．\n何度も加減算を繰り返すと内部でオーバーフローを起こす可能性．\nインデックスは size_t ではなく int で扱う．","usage":"","require":"#include <vector>\nusing namespace std;","verified":["http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208770#1","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208769#1","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208768#1","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208771#1","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208772#1","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208773#1","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208777#1"],"references":["プログラミングコンテストチャレンジブック","https://www.slideshare.net/kazumamikami1/ss-15160153"],"code":"template <typename T>\n// using T = ll;\nclass SegmentTree {\n public:\n  struct IdxVal {\n    int index;\n    T value;\n    inline IdxVal(int _i = 0, const T& _v = T()) : index(_i), value(_v) {}\n    inline void set(int i, const T& v) {\n      index = i;\n      value = v;\n    }\n    inline bool operator<(const T& t) const { return value < t; }\n    inline bool operator==(const T& t) const { return value == t; }\n    inline bool operator<(const IdxVal& iv) const {\n      return value < iv.value || (value == iv.value && index < iv.index);\n    }\n    inline bool operator==(const IdxVal& iv) const {\n      return index == iv.index && value == iv.value;\n    }\n  };\n\n  enum struct Cmd { None, Add, Flat };\n\n  struct Node {\n    T sum, lazyValue;\n    IdxVal max;\n    Cmd lazyType;\n  };\n\n private:\n  const int size_;\n  vector<T> leaf_data_;\n  vector<Node> node_data_;\n  T* leaf_;\n  Node* node_;\n\n  void _resize() {\n    leaf_data_.resize(size_);\n    node_data_.resize(size_ - 1);\n\n    leaf_ = &leaf_data_[0];\n    node_ = &node_data_[0] - 1;\n  }\n\n  void _init() {\n    for (int i = size_ - 1; 0 < i; --i) {\n      int c = i << 1;\n      if (size_ <= c)\n        node_[i].max.set(c - size_, leaf_[c - size_]);\n      else\n        node_[i].max = node_[c].max;\n      node_[i].lazyType = Cmd::None;\n      node_[i].sum = node_[i].lazyValue = 0;\n    }\n  }\n\n public:\n  inline void fill(T val) {\n    std::fill(leaf_data_.begin(), leaf_data_.end(), val);\n    _init();\n  }\n\n  SegmentTree(int _n)\n      : size_([](int _n) {\n          int s = 8;\n          while (s < _n)\n            s <<= 1;\n          return s;\n        }(_n)) {\n    _resize();\n    _init();\n  }\n  SegmentTree(int _n, const T& _fillVal)\n      : size_([](int _n) {\n          int s = 8;\n          while (s < _n)\n            s <<= 1;\n          return s;\n        }(_n)) {\n    _resize();\n    fill(_fillVal);\n  }\n\n private:\n  // lazyを適応する(子を呼ぶ前に呼ぶ)\n  // width: ptrが担当するnodeの範囲の大きさ(ptr = 1 ならば size_)\n  inline void _applyDown(int ptr, int width) {\n    width >>= 1;\n    // if (size_ <= ptr) return;\n    if (node_[ptr].lazyType == Cmd::Add) {\n      int c = ptr << 1;\n\n      if (size_ <= c) {\n        leaf_[c - size_] += node_[ptr].lazyValue;\n        leaf_[c + 1 - size_] += node_[ptr].lazyValue;\n      } else {\n        node_[c].sum += node_[ptr].lazyValue * width;\n        node_[c].max.value += node_[ptr].lazyValue;\n        node_[c].lazyValue += node_[ptr].lazyValue;\n        if (node_[c].lazyType == Cmd::None)\n          node_[c].lazyType = Cmd::Add;\n\n        node_[c + 1].sum += node_[ptr].lazyValue * width;\n        node_[c + 1].max.value += node_[ptr].lazyValue;\n        node_[c + 1].lazyValue += node_[ptr].lazyValue;\n        if (node_[c + 1].lazyType == Cmd::None)\n          node_[c + 1].lazyType = Cmd::Add;\n      }\n\n      node_[ptr].lazyType = Cmd::None;\n      node_[ptr].lazyValue = 0;\n    } else if (node_[ptr].lazyType == Cmd::Flat) {\n      node_[ptr].lazyType = Cmd::None;\n      int c = ptr << 1;\n\n      if (size_ <= c) {\n        leaf_[c - size_] = node_[ptr].lazyValue;\n        leaf_[c + 1 - size_] = node_[ptr].lazyValue;\n      } else {\n        node_[c].sum = node_[ptr].lazyValue * width;\n        node_[c].max.value = node_[ptr].lazyValue;\n        node_[c].lazyValue = node_[ptr].lazyValue;\n        node_[c].lazyType = Cmd::Flat;\n\n        node_[c + 1].sum = node_[ptr].lazyValue * width;\n        node_[c + 1].max.value = node_[ptr].lazyValue;\n        node_[c + 1].lazyValue = node_[ptr].lazyValue;\n        node_[c + 1].lazyType = Cmd::Flat;\n      }\n\n      node_[ptr].lazyType = Cmd::None;\n      node_[ptr].lazyValue = 0;\n    }\n  }\n\n  // lazyを適応する(子を呼んだ後に呼ぶ)\n  inline void _applyUp(int ptr) {\n    if (size_ <= ptr << 1) {\n      int i = (ptr << 1) - size_;\n      if (leaf_[i] < leaf_[i + 1])\n        node_[ptr].max.set(i + 1, leaf_[i + 1]);\n      else\n        node_[ptr].max.set(i, leaf_[i]);\n      node_[ptr].sum = leaf_[i] + leaf_[i + 1];\n    } else {\n      if (node_[(ptr << 1)].max.value < node_[(ptr << 1) + 1].max.value)\n        node_[ptr].max = node_[(ptr << 1) + 1].max;\n      else\n        node_[ptr].max = node_[(ptr << 1)].max;\n      node_[ptr].sum = node_[ptr << 1].sum + node_[(ptr << 1) + 1].sum;\n    }\n  }\n\n  // _downward_applyDown(ptr1): leaf[ptr1]の値を正しくする．\n  void _downward_applyDown(int ptr1, int width = 1) {\n    if (1 < ptr1)\n      _downward_applyDown(ptr1 >> 1, width << 1);\n    _applyDown(ptr1, width);\n  }\n\n  void _setValueRange(int begin, int end, T val, int ptr, int rangebegin, int rangeend) {\n    if (rangeend <= begin || end <= rangebegin)\n      return;  // note:範囲外\n    if (begin <= rangebegin && rangeend <= end) {\n      if (size_ <= ptr) {\n        leaf_[rangebegin] = val;\n      } else {\n        node_[ptr].sum = val * (rangeend - rangebegin);\n        node_[ptr].max.value = val;\n        node_[ptr].lazyType = Cmd::Flat;\n        node_[ptr].lazyValue = val;\n      }\n      return;\n    }\n\n    _applyDown(ptr, rangeend - rangebegin);\n\n    _setValueRange(begin, end, val, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n    _setValueRange(begin, end, val, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n    _applyUp(ptr);\n  }\n\n  void _addValueRange(int begin, int end, T val, int ptr, int rangebegin, int rangeend) {\n    if (rangeend <= begin || end <= rangebegin)\n      return;  // note:範囲外\n    if (begin <= rangebegin && rangeend <= end) {\n      if (size_ <= ptr) {\n        leaf_[rangebegin] += val;\n      } else {\n        node_[ptr].sum += val * (rangeend - rangebegin);\n        node_[ptr].max.value += val;\n        node_[ptr].lazyValue += val;\n        if (node_[ptr].lazyType == Cmd::None)\n          node_[ptr].lazyType = Cmd::Add;\n      }\n      return;\n    }\n\n    _applyDown(ptr, rangeend - rangebegin);\n\n    _addValueRange(begin, end, val, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n    _addValueRange(begin, end, val, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n    _applyUp(ptr);\n  }\n\n  T _getSumRange(int begin, int end, int ptr, int rangebegin, int rangeend) {\n    if (rangeend <= begin || end <= rangebegin)\n      return 0;  // note:範囲外\n    if (begin <= rangebegin && rangeend <= end) {\n      if (size_ <= ptr)\n        return leaf_[rangebegin];\n      else\n        return node_[ptr].sum;\n    }\n\n    _applyDown(ptr, rangeend - rangebegin);\n\n    return _getSumRange(begin, end, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1) +\n           _getSumRange(begin, end, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n  }\n\n  IdxVal _getMaxRange(int begin, int end, int ptr, int rangebegin, int rangeend) {\n    if (rangeend <= begin || end <= rangebegin)\n      return IdxVal(-1);  // note:範囲外\n    if (begin <= rangebegin && rangeend <= end) {\n      if (size_ <= ptr)\n        return IdxVal(rangebegin, leaf_[rangebegin]);\n      else\n        return node_[ptr].max;\n    }\n\n    _applyDown(ptr, rangeend - rangebegin);\n\n    auto l = _getMaxRange(begin, end, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n    auto r = _getMaxRange(begin, end, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n    if (l.index == -1)\n      return move(r);\n    if (r.index == -1)\n      return move(l);\n    return l.value < r.value ? move(r) : move(l);\n  }\n\n public:\n  // [index] の値を求める\n  inline T getValue(int index) {\n    _downward_applyDown((index + size_) >> 1);\n    return leaf_[index];\n  }\n\n  // [index] の値を書き換える\n  inline void setValue(int index, T val) {\n    _downward_applyDown((index + size_) >> 1);\n    T diff = val - leaf_[index];\n    leaf_[index] = val;\n\n    for (int ptr = (index + size_); 1 < ptr;) {\n      ptr >>= 1;\n      node_[ptr].sum -= diff;\n      _applyUp(ptr);\n    }\n  }\n\n  // [index] の値に加算する\n  inline void addValue(int index, T val) {\n    _downward_applyDown((index + size_) >> 1);\n    leaf_[index] += val;\n\n    for (int ptr = (index + size_); 1 < ptr;) {\n      ptr >>= 1;\n      node_[ptr].sum += val;\n      _applyUp(ptr);\n    }\n  }\n\n  // 区間[begin,end)全てにvalをセットする\n  inline void setValueRange(int begin, int end, T val) {\n    _setValueRange(begin, end, val, 1, 0, size_);\n  }\n\n  // 区間[begin,end)に一様にvalを加算する\n  inline void addValueRange(int begin, int end, T val) {\n    _addValueRange(begin, end, val, 1, 0, size_);\n  }\n\n  // 区間[begin,end)の和を求める\n  inline T getSumRange(int begin, int end) { return _getSumRange(begin, end, 1, 0, size_); }\n\n  // 区間[begin,end)の最大値とその位置を求める\n  inline IdxVal getMaxRange(int begin, int end) { return _getMaxRange(begin, end, 1, 0, size_); }\n};","path":"/src/cpp/container/likermq/segmenttree/segmenttree.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"遅延セグメント木(bitset風味)","overview":"次のクエリを処理できる．\n- 区間の要素をすべて1にする\n- 区間の要素をすべて0にする．\n- 1になっている区間の要素の個数を求める．\n0-indexedで，[begin,end)．beginを含み，endを含まない．\n反転クエリも書ける。","usage":"","require":"#include <vector>\nusing namespace std;","verified":["乱数テスト"],"references":[],"code":"struct SegmentTree {\n  struct LZ {\n    bool enable;\n    int fillval;\n  };\n  vector<int> data;\n  vector<LZ> lazy;\n  int n;\n\n  SegmentTree(int _n) {\n    n = 8;\n    while (n < _n)\n      n <<= 1;\n    data.resize(n << 1);\n    lazy.resize(n << 1);\n  }\n\n  inline void _setup_lazy(int idx, int fillval) {\n    if (idx < n) {\n      lazy[idx * 2].enable = true;\n      lazy[idx * 2].fillval = fillval;\n      lazy[idx * 2 + 1].enable = true;\n      lazy[idx * 2 + 1].fillval = fillval;\n    }\n  }\n\n  inline void _apply_lazy(int idx, int size) {\n    if (lazy[idx].enable) {\n      lazy[idx].enable = false;\n      data[idx] = size * lazy[idx].fillval;\n      if (idx < n) {\n        _setup_lazy(idx, lazy[idx].fillval);\n      }\n    }\n  }\n\n  void _set_range(int begin, int end, int idx, int left, int right) {\n    _apply_lazy(idx, right - left);\n    if (end <= left || right <= begin)\n      return;  // out of range\n    if (begin <= left && right <= end) {\n      data[idx] = right - left;\n      _setup_lazy(idx, 1);\n      return;\n    }\n    int center = (right + left) / 2;\n    _set_range(begin, end, idx * 2, left, center);\n    _set_range(begin, end, idx * 2 + 1, center, right);\n    data[idx] = data[idx * 2] + data[idx * 2 + 1];\n  }\n\n  inline void set_range(int begin, int end) { return _set_range(begin, end, 1, 0, n); }\n\n  void _reset_range(int begin, int end, int idx, int left, int right) {\n    _apply_lazy(idx, right - left);\n    if (end <= left || right <= begin)\n      return;  // out of range\n    if (begin <= left && right <= end) {\n      data[idx] = 0;\n      _setup_lazy(idx, 0);\n      return;\n    }\n    int center = (right + left) / 2;\n    _reset_range(begin, end, idx * 2, left, center);\n    _reset_range(begin, end, idx * 2 + 1, center, right);\n    data[idx] = data[idx * 2] + data[idx * 2 + 1];\n  }\n\n  inline void reset_range(int begin, int end) { return _reset_range(begin, end, 1, 0, n); }\n\n  inline int _count_range(int begin, int end, int idx, int left, int right) {\n    if (end <= left || right <= begin)\n      return 0;  // out of range\n    _apply_lazy(idx, right - left);\n    if (begin <= left && right <= end)\n      return data[idx];\n\n    int center = (right + left) / 2;\n    return _count_range(begin, end, idx * 2, left, center) +\n           _count_range(begin, end, idx * 2 + 1, center, right);\n  }\n\n  inline int count_range(int begin, int end) { return _count_range(begin, end, 1, 0, n); }\n};","path":"/src/cpp/container/likermq/segmenttree/hatopoppo.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"遅延セグメント木(bitset風味)(sparse)","overview":"次のクエリを処理できる．\n- 区間の要素をすべて1にする\n- 区間の要素をすべて0にする．\n- 1になっている区間の要素の個数を求める．\n0-indexedで，[begin,end)．beginを含み，endを含まない．\n反転クエリも書ける。","usage":"","require":"#include <memory>\nusing namespace std;\nusing ll = long long;","verified":["https://yukicoder.me/submissions/251514","速度が出てない"],"references":[],"code":"struct SegmentTreeS {\n  struct Node {\n    ll val_;\n    bool lazy_ = false;\n    unique_ptr<Node> bottom[2];\n\n    Node(ll v, bool lz = false) : val_(v), lazy_(lz) {}\n\n    inline void setup_bottom() {\n      if (!bottom[0])\n        bottom[0].reset(new Node(0));\n      if (!bottom[1])\n        bottom[1].reset(new Node(0));\n    }\n\n    inline void apply_lazy() {\n      bottom[0]->lazy_ = true;\n      bottom[0]->val_ = val_ / 2;\n      bottom[1]->lazy_ = true;\n      bottom[1]->val_ = val_ / 2;\n    }\n\n    void set_range(ll begin, ll end, ll left, ll right) {\n      if (end <= left || right <= begin)\n        return;  // out of range\n      if (begin <= left && right <= end) {\n        val_ = right - left;\n        lazy_ = true;\n        return;\n      }\n      setup_bottom();\n      if (lazy_)\n        apply_lazy();\n\n      ll center = (right + left) / 2;\n      bottom[0]->set_range(begin, end, left, center);\n      bottom[1]->set_range(begin, end, center, right);\n      val_ = (bottom[0]->val_ + bottom[1]->val_);\n    }\n\n    void reset_range(ll begin, ll end, ll left, ll right) {\n      if (end <= left || right <= begin)\n        return;  // out of range\n      if (begin <= left && right <= end) {\n        val_ = right - left;\n        lazy_ = true;\n        return;\n      }\n      setup_bottom();\n      if (lazy_)\n        apply_lazy();\n\n      ll center = (right + left) / 2;\n      bottom[0]->reset_range(begin, end, left, center);\n      bottom[1]->reset_range(begin, end, center, right);\n      val_ = (bottom[0]->val_ + bottom[1]->val_);\n    }\n\n    ll count_range(ll begin, ll end, ll left, ll right) {\n      if (end <= left || right <= begin)\n        return 0;\n      if (begin <= left && right <= end)\n        return val_;\n      if (val_ == 0 || val_ == right - left)\n        return val_;\n      ll center = (right + left) / 2;\n      return bottom[0]->count_range(begin, end, left, center) +\n             bottom[1]->count_range(begin, end, center, right);\n    }\n  };\n\n  ll width;\n  Node root;\n\n  SegmentTreeS(ll w) : root(0, false) {\n    width = 8;\n    while (width < w)\n      width <<= 1;\n  }\n\n  inline void set_range(ll begin, ll end) { root.set_range(begin, end, 0, width); }\n  inline void reset_range(ll begin, ll end) { root.reset_range(begin, end, 0, width); }\n  inline ll count_range(ll begin, ll end) { return root.count_range(begin, end, 0, width); }\n};","path":"/src/cpp/container/likermq/segmenttree/hatopoppoS.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"セグメント木(単独書き換え，区間演算)","overview":"次のクエリを処理できる．\n- １つの要素を書き換える．\n- 区間の要素全てにfunc_を適応した値を求める．\n十分な高速化が施されている．と思われる．","usage":"; 非負整数，区間最大値の場合．\nSegmentTreeQ<int> s(10, [](int x, int y) {return max(x, y); }, 0);","require":"#include <vector>\n#include <functional>\nusing namespace std;","verified":["https://beta.atcoder.jp/contests/dwacon2018-final-open/submissions/2050384"],"references":["http://d.hatena.ne.jp/komiyam/20131202/1385992406","http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/","https://beta.atcoder.jp/contests/dwacon2018-final-open/submissions/2049865"],"code":"template <typename T>\n// typedef int T;\nclass SegmentTreeQ {\n  int size_;\n  vector<T> data_;\n  const function<T(T, T)> func_;\n  const T zero_;\n\n public:\n  SegmentTreeQ(int n, function<T(T, T)> f, T z) : func_(f), zero_(z) {\n    size_ = 8;\n    while (size_ < n)\n      size_ <<= 1;\n    data_.resize(size_ * 2, zero_);\n  }\n\n  void fill(T val) { std::fill(data_.begin(), data_.end(), val); }\n\n  inline T get_val(int index) const { return data_[index + size_]; }\n\n  void set_val(int index, const T e) {\n    index += size_;\n    data_[index] = e;\n    while (1 < index) {\n      data_[index >> 1] =\n          func_(data_[index], data_[index ^ 1]);  // TODO : この部分の計算順序は正確か？\n      index >>= 1;\n    }\n  }\n\n  inline int get_range(int begin, int end) const {\n    T rl = zero_, rr = zero_;\n    begin += size_;\n    end += size_;\n    for (; begin < end; begin >>= 1, end >>= 1) {\n      if (begin & 1)\n        rl = func_(data_[begin++], rl);\n      if (end & 1)\n        rr = func_(rr, data_[--end]);\n    }\n    return func_(rl, rr);\n  }\n};","path":"/src/cpp/container/likermq/segmenttree/updrange_plain.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"セグメント木(区間加算，区間最大，区間総和)[deprecated]","overview":"次のクエリを処理できる．\n- 区間の要素すべてに加算する．\n- 区間の要素の最大値を計算する．\n- 区間の要素の総和を計算する．\n0-indexedで，[begin,end)．beginを含み，endを含まない．\nインデックスは size_t ではなく int で扱う．[TODO]\n要リファクタリング[TODO]\n必ずfillを呼んでから使う．","usage":"getsumrange(range) getval(index) getmaxrange(range)\naddvalrange(range)","require":"#include <vector>\nusing namespace std;","verified":["http://yukicoder.me/submissions/170798","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2521353#1 (addvalrange, getsumrange)"],"references":["プログラミングコンテストチャレンジブック"],"code":"template <typename T>\n// typedef int T;\nclass SegmentTree {\n  int size;\n\n public:\n  struct VI {\n    T val;\n    int idx;\n    VI(T val = 0, int idx = 0) : val(val), idx(idx) {}\n\n    static inline const VI& max(const VI& a, const VI& b) {\n      return a.val == b.val ? (a.idx < b.idx ? a : b) : (a.val >= b.val ? a : b);\n    }\n    static inline const VI& min(const VI& a, const VI& b) {\n      return a.val == b.val ? (a.idx < b.idx ? a : b) : (a.val <= b.val ? a : b);\n    }\n\n    inline bool operator==(const VI& e) const { return val == e.val && idx == e.idx; }\n    inline bool operator<(const VI& e) const { return (val < e.val) || (idx > e.idx); }\n  };\n\n private:\n  vector<int> mark;\n  vector<T> single;            // max(min)遅延伝搬用\n  vector<pair<T, T>> addtree;  // sum,lazy\n  vector<VI> maxtree;          // val,idx\n public:\n  SegmentTree(int n) {\n    size = 8;\n    while (size < n)\n      size <<= 1;\n\n    addtree.resize(size * 2);\n    mark.resize(size * 2);\n    single.resize(size * 2);\n    maxtree.resize(size * 2);\n    _flat();\n  }\n\n  void _flat() {\n    for (int i = 0; i < size; ++i) {\n      maxtree[i + size - 1] = VI(0, i);\n    }\n    for (int i = size - 2; 0 <= i; --i) {\n      int c = 2 * i + 1;\n      maxtree[i] = maxtree[c];\n    }\n  }\n\n  // 区間[begin,end)に一様にvalを加算する(private)\n  void _addvalrange(int begin, int end, T val, int ptr, int rangebegin, int rangeend) {\n    if (rangeend <= begin || end <= rangebegin)\n      return;  // note:範囲外\n    if (begin <= rangebegin && rangeend <= end) {\n      addtree[ptr].first += val * (rangeend - rangebegin);\n      addtree[ptr].second += val * (rangeend - rangebegin) / 2;\n      mark[ptr] |= 3;\n      maxtree[ptr].val += val;\n      single[ptr] += val;\n\n      // if (rangeend - rangebegin > 1) { // せっかくだから\n      //    _applyDown(ptr);\n      //}\n      return;\n    }\n    //_applyDown(ptr);\n\n    int rangemid = (rangebegin + rangeend) / 2;\n    _addvalrange(begin, end, val, ptr * 2 + 1, rangebegin, rangemid);\n    _addvalrange(begin, end, val, ptr * 2 + 2, rangemid, rangeend);\n    addtree[ptr].first += val * (min(rangeend, end) - max(rangebegin, begin));\n    maxtree[ptr] = VI::max(maxtree[ptr * 2 + 1], maxtree[ptr * 2 + 2]);\n  }\n  // 区間[begin,end)に一様にvalを加算する\n  inline void addvalrange(int begin, int end, T val) { _addvalrange(begin, end, val, 0, 0, size); }\n\n  inline void _applyDown(int ptr) {\n    // if (size - 1 <= ptr) return;\n    if (mark[ptr] & 1) {\n      mark[ptr] ^= 1;\n      int c1 = ptr * 2 + 1;\n      int c2 = ptr * 2 + 2;\n      addtree[c1].first += addtree[ptr].second;\n      addtree[c1].second += addtree[ptr].second / 2;\n      mark[c1] |= 1;\n      addtree[c2].first += addtree[ptr].second;\n      addtree[c2].second += addtree[ptr].second / 2;\n      mark[c2] |= 1;\n      addtree[ptr].second = 0;\n    }\n    if (mark[ptr] & 2) {\n      mark[ptr] ^= 2;\n      int c1 = ptr * 2 + 1;\n      int c2 = ptr * 2 + 2;\n      maxtree[c1].val += single[ptr];\n      single[c1] += single[ptr];\n      mark[c1] |= 2;\n      maxtree[c2].val += single[ptr];\n      single[c2] += single[ptr];\n      mark[c2] |= 2;\n      single[ptr] = 0;\n    }\n  }\n\n  inline void _downward_applyDown(int ptr1) {\n    if (1 < ptr1)\n      _downward_applyDown(ptr1 >> 1);\n    _applyDown(ptr1 - 1);\n  }\n\n  T getval(int index) {\n    T sum = 0;\n    _downward_applyDown((index + size) >> 1);\n    return addtree[index + size - 1].first;\n  }\n\n  // 区間[begin,end)の和を求める(private)\n  T _getsumrange(int begin, int end, int ptr, int rangebegin, int rangeend) {\n    if (rangeend <= begin || end <= rangebegin)\n      return 0;  // note:範囲外\n    if (begin <= rangebegin && rangeend <= end)\n      return addtree[ptr].first;\n\n    _applyDown(ptr);\n\n    int rangemid = (rangebegin + rangeend) / 2;\n    return _getsumrange(begin, end, ptr * 2 + 1, rangebegin, rangemid) +\n           _getsumrange(begin, end, ptr * 2 + 2, rangemid, rangeend);\n  }\n  // 区間[begin,end)の和を求める\n  inline T getsumrange(int begin, int end) { return _getsumrange(begin, end, 0, 0, size); }\n\n  // 区間[begin,end)の最大値とその位置を求める(private)\n  VI _getmaxrange(int begin, int end, int ptr, int rangebegin, int rangeend) {\n    if (rangeend <= begin || end <= rangebegin)\n      return VI(0, -1);  // note:範囲外\n    if (begin <= rangebegin && rangeend <= end)\n      return maxtree[ptr];\n\n    _applyDown(ptr);\n\n    int rangemid = (rangebegin + rangeend) / 2;\n    VI l = _getmaxrange(begin, end, ptr * 2 + 1, rangebegin, rangemid);\n    VI r = _getmaxrange(begin, end, ptr * 2 + 2, rangemid, rangeend);\n\n    if (l.idx == -1)\n      return r;\n    if (r.idx == -1)\n      return l;\n    return VI::max(l, r);\n  }\n  // 区間[begin,end)の最大値とその位置を求める\n  inline VI getmaxrange(int begin, int end) { return _getmaxrange(begin, end, 0, 0, size); }\n};","path":"/src/cpp/container/likermq/segmenttree/sumrange_addrange.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"セグメント木(区間加算，区間最大，単独書換)[deprecated]","overview":"次のクエリを処理できる．\n- １つの要素を書き換える．\n- 区間の要素すべてに加算する．\n- 区間の要素の最大値を計算する．\n0-indexedで，[begin,end)．beginを含み，endを含まない．\n何度も加減算を繰り返すと内部でオーバーフローを起こす可能性．\nインデックスは size_t ではなく int で扱う．\nコピーを繰り返すため，T に指定する型はプリミティブ型か小さな構造体だと嬉しい","usage":"SegmentTree<typename T>(int n)\n; [0,n) の配列を確保する．\nT SegmentTree::get_val(int idx)\n; idx の要素の値を取得する．\nvoid SegmentTree::set_val(int idx, T e)\n; idx の要素の値をeに書き換える．\nvoid SegmentTree::add_valrange(int begin, int end, T e)\n; 区間[begin,end)にeを加算する\nvoid SegmentTree::get_maxrange(int idx, T e)\n; 区間[begin,end)の最大値を計算する\nvoid SegmentTree::get_maxrangeIdx(int idx, T e)\n; 区間[begin,end)の最大値が存在する要素のインデックスを取得する","require":"#include <vector>\nusing namespace std;","verified":["http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208410#1 (setval, getminrange)","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208412#1 (addvalrange, getval)","https://yukicoder.me/submissions/294581 (addvalrange, getminrange)","Legacy:","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2521389#1 (setval, getminrange)","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2521434#1 (addvalrange, getval)","https://yukicoder.me/submissions/227863 (addvalrange, getminrange)"],"references":["プログラミングコンテストチャレンジブック","https://www.slideshare.net/kazumamikami1/ss-15160153"],"code":"template <typename T>\n// using T = ll;\nclass SegmentTree {\n public:\n  struct IdxVal {\n    int index;\n    T value;\n    inline IdxVal(int _i = 0, const T& _v = T()) : index(_i), value(_v) {}\n    inline void set(int i, const T& v) {\n      index = i;\n      value = v;\n    }\n    inline bool operator<(const T& t) const { return value < t; }\n    inline bool operator==(const T& t) const { return value == t; }\n    inline bool operator<(const IdxVal& iv) const {\n      return value < iv.value || (value == iv.value && index < iv.index);\n    }\n    inline bool operator==(const IdxVal& iv) const {\n      return index == iv.index && value == iv.value;\n    }\n  };\n\n  struct Node {\n    T add;\n    IdxVal max;\n  };\n\n private:\n  const int size_;\n  vector<T> leaf_data_;\n  vector<Node> node_data_;\n  T* leaf_;\n  Node* node_;\n\n  void _resize() {\n    leaf_data_.resize(size_);\n    node_data_.resize(size_ - 1);\n\n    leaf_ = &leaf_data_[0];\n    node_ = &node_data_[0] - 1;\n  }\n\n  void _init() {\n    for (int i = size_ - 1; 0 < i; --i) {\n      int c = i << 1;\n      if (size_ <= c)\n        node_[i].max.set(c - size_, leaf_[c - size_]);\n      else\n        node_[i].max = node_[c].max;\n      node_[i].add = 0;\n    }\n  }\n\n public:\n  inline void fill(T val) {\n    std::fill(leaf_data_.begin(), leaf_data_.end(), val);\n    _init();\n  }\n\n  SegmentTree(int _n)\n      : size_([](int _n) {\n          int s = 8;\n          while (s < _n)\n            s <<= 1;\n          return s;\n        }(_n)) {\n    _resize();\n    _init();\n  }\n  SegmentTree(int _n, const T& _fillVal)\n      : size_([](int _n) {\n          int s = 8;\n          while (s < _n)\n            s <<= 1;\n          return s;\n        }(_n)) {\n    _resize();\n    fill(_fillVal);\n  }\n\n  // idx の要素の値を取得する\n  inline T getValue(int index) const {\n    T sum = leaf_[index];\n    index += size_;\n    while (1 < index) {\n      index = index >> 1;  // 親へ移動\n      sum += node_[index].add;\n    }\n    return sum;\n  }\n\n  // idx の要素の値をeに書き換える\n  void setValue(int index, const T e) {\n    leaf_[index] = e;\n\n    for (int i = index + size_; 1 < i;) {\n      i >>= 1;\n      leaf_[index] -= node_[i].add;\n    }\n    // bottom nodes\n    {\n      int c1 = index >> 1 << 1;\n      int c2 = index >> 1 << 1;\n      if (leaf_[c1] < leaf_[c2])\n        node_[(index + size_) >> 1].max.set(c2, leaf_[c2]);\n      else\n        node_[(index + size_) >> 1].max.set(c1, leaf_[c1]);\n    }\n    for (int i = (index + size_) >> 1; 1 < i;) {\n      i >>= 1;\n      if (node_[i << 1].max.value < node_[(i << 1) + 1].max.value)\n        node_[i].max = node_[(i << 1) + 1].max;\n      else\n        node_[i].max = node_[i << 1].max;\n    }\n  }\n\n private:\n  void _addValueRange(int begin, int end, const T e, int ptr, int rangebegin, int rangeend) {\n    if (rangeend <= begin || end <= rangebegin)\n      return;\n    if (begin <= rangebegin && rangeend <= end) {\n      if (size_ <= ptr)\n        leaf_[ptr - size_] += e;\n      else\n        node_[ptr].add += e, node_[ptr].max.value += e;\n      return;\n    }\n\n    _addValueRange(begin, end, e, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n    _addValueRange(begin, end, e, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n    if (size_ <= ptr << 1) {\n      int i = (ptr << 1) - size_;\n      if (leaf_[i] < leaf_[i + 1])\n        node_[ptr].max.set(i + 1, leaf_[i + 1]);\n      else\n        node_[ptr].max.set(i, leaf_[i]);\n    } else {\n      if (node_[ptr << 1].max.value < node_[(ptr << 1) + 1].max.value)\n        node_[ptr].max = node_[(ptr << 1) + 1].max;\n      else\n        node_[ptr].max = node_[ptr << 1].max;\n    }\n    node_[ptr].max.value += node_[ptr].add;\n  }\n\n private:\n  IdxVal _getMaxRange(int begin, int end, int ptr, int rangebegin, int rangeend) const {\n    if (rangeend <= begin || end <= rangebegin)\n      return IdxVal(-1);\n    if (begin <= rangebegin && rangeend <= end) {\n      if (size_ <= ptr)\n        return IdxVal(rangebegin, leaf_[rangebegin]);\n      else\n        return node_[ptr].max;\n    }\n\n    auto l = _getMaxRange(begin, end, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n    auto r = _getMaxRange(begin, end, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n    if (l.index == -1)\n      return move(r);\n    if (r.index == -1)\n      return move(l);\n    return l.value < r.value ? move(r) : move(l);\n  }\n\n public:\n  // 区間[begin,end)にeを加算する\n  inline void addValueRange(int begin, int end, const T e) {\n    _addValueRange(begin, end, e, 1, 0, size_);\n  }\n\n  // 区間[begin,end)の最大値を計算する\n  inline IdxVal getMaxRange(int begin, int end) const {\n    if (end - begin <= 1)\n      return IdxVal(begin, getValue(begin));\n    return _getMaxRange(begin, end, 1, 0, size_);\n  }\n};","path":"/src/cpp/container/likermq/segmenttree/maxrange_addrange.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"IntervalHeap","overview":"両端優先キュー．\nHeapの各ノードは1~2つの要素を持つ．この2つの要素は順序関係によって区間とみなすことができる．\n子⊆親を満たすようにHeapを保つことで，data_.front()には常に最小値と最大値が格納される．\n\nうーん相当無駄な実装が多いような．","usage":"push\nmin\nmax\npopmin\npopmax\nsize\nclear\nreserve","require":"#include <vector>\nusing namespace std;","verified":["rand"],"references":["https://topcoder.g.hatena.ne.jp/spaghetti_source/20121006/1349491389"],"code":"template <typename T>\nclass IntervalHeap {\n  using TT = pair<T, T>;  // first <= second\n\n  vector<TT> data_;  // data_の配列要素は2つの要素を持つ．data_.size() は (size_ + 1) / 2 と等価\n  int size_;  // データ構造が持つ要素の数\n\n  // data_[ptr]は1つの要素しか持っていない？\n  inline bool one(int ptr) const noexcept {\n    // ptr == 末尾 かつ 末尾を1要素しか持たない\n    return ptr == (size_ - 1) / 2 && (size_ & 1) == 1;\n  }\n\n  void fixup(int ptr) {\n    if (ptr <= 0)\n      return;\n    // ptr == 末尾 かつ 末尾を1要素しか持たない場合\n    if (one(ptr)) {\n      int parent = (ptr - 1) / 2;\n      if (data_[ptr].first < data_[parent].first)\n        swap(data_[ptr].first, data_[parent].first);  // 左端\n      else if (data_[ptr].first > data_[parent].second)\n        swap(data_[ptr].first, data_[parent].second);  // 右端\n      ptr = parent;\n    }\n    while (ptr > 0) {\n      int parent = (ptr - 1) / 2;\n      if (data_[ptr].first < data_[parent].first)\n        swap(data_[ptr].first, data_[parent].first);  // 左端\n      if (data_[ptr].second > data_[parent].second)\n        swap(data_[ptr].second, data_[parent].second);  // 右端\n      ptr = parent;\n    }\n  }\n\n  void fixdown(int ptr) {\n    // ptr == 末尾 かつ 末尾を1要素しか持たない場合\n    if (one(ptr))\n      return;\n\n    // ptrの整合\n    if (data_[ptr].first > data_[ptr].second)\n      swap(data_[ptr].first, data_[ptr].second);\n\n    int child = ptr * 2 + 1;       // 左の子のid\n    if (child >= (size_ + 1) / 2)  // 左の子が居ない\n      return;\n\n    if (child + 1 >= (size_ + 1) / 2) {  // 左の子しか居ない\n      if (data_[child].first < data_[ptr].first)\n        swap(data_[child].first, data_[ptr].first);  // 左端\n      if (!one(child) && data_[child].second > data_[ptr].second)\n        swap(data_[child].second, data_[ptr].second);  // 右端\n      // childの整合\n      if (!one(child) && data_[child].first > data_[child].second)\n        swap(data_[child].first, data_[child].second);\n      return;\n    }\n    bool leftfix = false, rightfix = false;\n    if (data_[child].first < data_[child + 1].first) {  // 左の子が右の子より小さい\n      if (data_[child].first < data_[ptr].first)\n        swap(data_[child].first, data_[ptr].first);  // 左端\n      leftfix = true;\n    } else {  // 右の子が左の子より小さい\n      if (data_[child + 1].first < data_[ptr].first)\n        swap(data_[child + 1].first, data_[ptr].first);  // 左端\n      rightfix = true;\n    }\n    if (one(child + 1) ||\n        data_[child].second >\n            data_[child + 1]\n                .second) {  // 左の子が右の子より大きい または 右の子は1要素しかもっていない\n      if (data_[child].second > data_[ptr].second)\n        swap(data_[child].second, data_[ptr].second);  // 右端\n      leftfix = true;\n    } else {  // 右の子が左の子より大きい\n      if (data_[child + 1].second > data_[ptr].second)\n        swap(data_[child + 1].second, data_[ptr].second);  // 右端\n      rightfix = true;\n    }\n    if (leftfix)\n      fixdown(child);\n    if (rightfix)\n      fixdown(child + 1);\n  }\n\n public:\n  inline IntervalHeap() : size_(0) {}\n\n  inline void reserve(size_t s) { data_.reserve(s); }\n  inline size_t size() const noexcept { return size_; }\n  inline void clear() {\n    size_ = 0;\n    data_.clear();\n  }\n\n  // TODO forward\n  void push(const T& elem) {\n    // 1. とりあえず末尾に追加\n    if ((size_ & 1) == 0) {\n      data_.emplace_back(elem, T());\n    } else {\n      data_.back().second = elem;\n      if (data_.back().first > data_.back().second)\n        swap(data_.back().first, data_.back().second);\n    }\n    ++size_;\n    // 2. 整合\n    fixup((size_ - 1) / 2);\n  }\n\n  const T& min() const { return data_.front().first; }\n\n  const T& max() const { return size_ <= 1 ? data_.front().first : data_.front().second; }\n\n  void popmin() {\n    if (size_ <= 0) {\n      //\n    } else if (size_ == 1) {\n      --size_;\n      data_.pop_back();\n    } else if (size_ == 2) {\n      --size_;\n      swap(data_.front().first, data_.front().second);\n    } else if ((size_ & 1) == 0) {\n      // 現在偶数個あり，奇数個に減る\n      // 1. 末尾と交換\n      swap(data_.front().first, data_.back().second);\n      // 2. delete\n      --size_;\n      // 3. 整合\n      fixdown(0);\n    } else {\n      // 現在奇数個あり，偶数個に減る\n      // 1. 末尾と交換\n      swap(data_.front().first, data_.back().first);\n      data_.pop_back();\n      // 2. delete\n      --size_;\n      // 3. 整合\n      fixdown(0);\n    }\n  }\n\n  void popmax() {\n    if (size_ <= 0) {\n      //\n    } else if (size_ == 1) {\n      --size_;\n      data_.pop_back();\n    } else if (size_ == 2) {\n      --size_;\n    } else if ((size_ & 1) == 0) {\n      // 現在偶数個あり，奇数個に減る\n      // 1. 末尾と交換\n      swap(data_.front().second, data_.back().second);\n      // 2. delete\n      --size_;\n      // 3. 整合\n      fixdown(0);\n    } else {\n      // 現在奇数個あり，偶数個に減る\n      // 1. 末尾と交換\n      swap(data_.front().second, data_.back().first);\n      data_.pop_back();\n      // 2. delete\n      --size_;\n      // 3. 整合\n      fixdown(0);\n    }\n  }\n};","path":"/src/cpp/container/array/intervalheap.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"RadixHeap(simple)","overview":"priority_queueに次の制約を与えたもの\n- 最後に取り出した値より小さな値を追加出来ない\n計算量はならし O(logD) (D:=max data_value) らしい","usage":"","require":"#include <vector>\n#include <cassert>\n#include <type_traits>\n#include <algorithm>\n#include <limits>\nusing namespace std;","verified":["todo"],"references":["https://www.slideshare.net/yosupo/ss-46612984"],"code":"class RadixHeap {\n public:\n  using value_type = long long;\n\n private:\n  value_type last_;\n  int size_;\n  int lastcnt_ = 0;\n  vector<value_type> vec[64];\n\n  // 一番左のbitの位置\n  static inline int bsr(value_type x) noexcept {\n#ifdef __GNUC__\n    return 63 - __builtin_clz(x);  // x == 0 の時，未定義\n#else\n    int r = -1, i = 0;\n    while (x)\n      x >>= 1, r = i++;\n    return r;\n#endif\n  }\n\n public:\n  inline RadixHeap() : last_(0), size_(0) {}\n\n  inline bool empty() const noexcept { return size_ == 0; }\n  inline int size() const noexcept { return size_; }\n\n  inline void push(value_type val) {\n    assert(last_ <= val);\n    ++size_;\n    if (val == last_)\n      ++lastcnt_;\n    else\n      vec[bsr(val ^ last_)].push_back(val);\n  }\n\n  inline value_type top() {\n    if (lastcnt_)\n      return last_;\n    for (int i = 0; i < 64; ++i)\n      if (!vec[i].empty())\n        return *min_element(vec[i].begin(), vec[i].end());\n    assert(true && \"RadixHeap is empty.\");\n    return numeric_limits<value_type>::max();\n  }\n\n  void pop() {\n    if (lastcnt_ == 0) {\n      for (int i = 0; i < 64; ++i) {\n        if (vec[i].empty())\n          continue;\n        last_ = *min_element(vec[i].begin(), vec[i].end());\n        for (auto val : vec[i]) {\n          if (val == last_)\n            ++lastcnt_;\n          else\n            vec[bsr(val ^ last_)].push_back(val);\n        }\n        vec[i].clear();\n        break;\n      }\n    }\n    --size_;\n    --lastcnt_;\n  }\n};","path":"/src/cpp/container/array/radixheap_simple.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"RadixHeap","overview":"priority_queueに次の制約を与えたもの\n- 最後に取り出した値より小さな値を追加出来ない\n計算量はならし O(logD) (D:=max data_value) らしい","usage":"","require":"#include <vector>\n#include <cassert>\n#include <type_traits>\n#include <algorithm>\n#include <limits>\nusing namespace std;","verified":["todo"],"references":["https://www.slideshare.net/yosupo/ss-46612984"],"code":"template <typename T>\n// using T = int;\nclass RadixHeap {\n public:\n  using value_type = unsigned long long;\n\n private:\n  using pair_type = pair<value_type, T>;\n  value_type last_;\n  int size_;\n  int lastcnt_ = 0;\n  vector<pair_type> vec[65];\n\n  // 一番左のbitの位置\n  inline int bsr(value_type x) {\n#ifdef __GNUC__\n    return x > 0 ? 63 - __builtin_clz(x) : -1;\n#else\n    int r = -1, i = 0;\n    while (x)\n      x >>= 1, r = i++;\n    return r;\n#endif\n  }\n\n public:\n  inline RadixHeap() : last_(0), size_(0) {}\n\n  inline bool empty() const noexcept { return size_ == 0; }\n  inline int size() const noexcept { return size_; }\n\n  inline void push(value_type val, T elem) {\n    assert(last_ <= val);\n    ++size_;\n    vec[bsr(val ^ last_) + 1].emplace_back(val, elem);\n  }\n\n  inline const pair_type& top() {\n    if (!vec[0].empty())\n      return vec[0].front();\n    for (int i = 1; i < 65; ++i)\n      if (!vec[i].empty())\n        return *min_element(vec[i].begin(), vec[i].end(),\n                            [](const pair<value_type, T>& l, const pair<value_type, T>& r) {\n                              return l.first < r.first;\n                            });\n    assert(false && \"RadixHeap is empty.\");\n    return vec[0].front();\n  }\n\n  void pop() {\n    if (vec[0].empty()) {\n      for (int i = 1; i < 65; ++i) {\n        if (vec[i].empty())\n          continue;\n        last_ = min_element(vec[i].begin(), vec[i].end(),\n                            [](const pair<value_type, T>& l, const pair<value_type, T>& r) {\n                              return l.first < r.first;\n                            })\n                    ->first;\n        for (auto& p : vec[i])\n          vec[bsr(p.first ^ last_) + 1].push_back(move(p));\n        vec[i].clear();\n        break;\n      }\n    }\n\n    --size_;\n    vec[0].pop_back();\n  }\n};","path":"/src/cpp/container/array/radixheap.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"PriorityQueue","overview":"clear, reserveが欲しいだけ","usage":"","require":"#include <vector>\n#include <algorithm>\nusing namespace std;","verified":["rand"],"references":[],"code":"template <typename T>\nclass PriorityQueue {\n  vector<T> data_;\n\n public:\n  inline PriorityQueue() {}\n\n  inline bool empty() const noexcept { return data_.empty(); }\n  inline int size() const noexcept { return data_.size(); }\n  inline void reserve(int s) { data_.reserve(s); }\n  inline void clear() { data_.clear(); }\n  inline const T& top() const noexcept { return data_.front(); }\n  inline void pop() {\n    pop_heap(data_.begin(), data_.end());\n    data_.pop_back();\n  }\n  inline void push(const T& val) {\n    data_.push_back(val);\n    push_heap(data_.begin(), data_.end());\n  }\n  inline void push(T&& val) {\n    data_.push_back(move(val));\n    push_heap(data_.begin(), data_.end());\n  }\n  template <typename... Arg>\n  inline void emplace(Arg&&... args) {\n    data_.emplace_back(forward<Arg>(args)...);\n    push_heap(data_.begin(), data_.end());\n  }\n};","path":"/src/cpp/container/array/priorityqueue.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"Treap(set)","overview":"Treapとは，次を満たす確率的平衝二分探索木である．\n- keyについてみると，木は二分探索木になっている．\n- priority(randomized)についてみると，木はHeapになっている．\n\n実装したTreapは，map(set)のような機能を持つだけ．\nsplit/mergeも出来ない．\n\n\nkeyはユニーク＆これ以上Nodeを追加しないという条件を加えれば区間クエリは書けそう．\n例えば『キーがx以下のNodeにyを加算する』は，treap[x]とtreap[x].childlen[0]に対してLazy実装で実現できる．","usage":"value_t& Treap::operator[](key_t key)\n; keyに対応するvalの参照を得る．無いなら作る．\nunique_ptr<TreapNode>& Treap::find(key_t key)\n; keyに対応するvalのスマートポインタの参照を得る．\n; keyに対応するvalが存在しないなら，空のスマートポインタの参照を得る．\nvoid Treap::erase(key_t key)\n; keyを削除する．","require":"#include <memory>\n#include <algorithm>\n#include <random>\n#include <functional>\nusing namespace std;","verified":[],"references":["https://www.slideshare.net/iwiwi/2-12188757","http://www.prefield.com/algorithm/container/treap.html"],"code":"class Treap {\n public:\n  using key_type = int;\n  using value_type = long long;\n\n private:\n  using randevice_type = mt19937;\n\n  static randevice_type rnd;\n\n private:\n  struct Node {\n    key_type key;\n    value_type value;\n    unique_ptr<Node> childlen[2];\n    randevice_type::result_type priority;\n\n    Node(const key_type& k = key_type(), const value_type& v = value_type())\n        : key(k), value(v), priority(rnd() | 1) {}\n    Node(key_type k, value_type v, randevice_type::result_type p) : key(k), value(v), priority(p) {}\n\n    // inline Node& operator[](size_t i) { return *childlen[i & 1]; }\n    // inline bool has(size_t i) { return (bool)childlen[i & 1]; }\n  };\n\n private:\n  unique_ptr<Node> root;\n\n public:\n  Treap() {}\n  Treap(Node* p) : root(p) {}\n\n private:\n  // base.childlen[swap_for]がbaseの位置に来るように回転させる．\n  static void _rotate(unique_ptr<Node>& base, size_t swap_for) {\n    swap_for &= 1;\n    unique_ptr<Node> swf = move(base->childlen[swap_for]);\n    base->childlen[swap_for] = move(swf->childlen[swap_for ^ 1]);\n    swf->childlen[swap_for ^ 1] = move(base);\n    base = move(swf);\n  }\n\n  // thisをrootとする部分木にkをkeyとするNodeが無ければ作る，あれば返す．\n  static inline Node& _touch(unique_ptr<Node>& node, key_type k) {\n    if (k == node->key)\n      return *node;\n    size_t i = node->key < k;\n    if (node->childlen[i]) {\n      auto& r = _touch(node->childlen[i], k);\n      if (node->priority > node->childlen[i]->priority)\n        _rotate(node, i);\n      return r;\n    } else {\n      node->childlen[i].reset(new Node(k));\n      return *(node->childlen[i]);\n    }\n  }\n\n  // keyが等しいnodeを探す(const)\n  static const unique_ptr<Node>& _find(const unique_ptr<Node>& ptr, key_type key) {\n    return (!ptr || ptr->key == key) ? ptr : _find(ptr->childlen[ptr->key < key], key);\n  }\n  // keyが等しいnodeを探す\n  static unique_ptr<Node>& _find(unique_ptr<Node>& ptr, key_type key) {\n    return (!ptr || ptr->key == key) ? ptr : _find(ptr->childlen[ptr->key < key], key);\n  }\n\n  // ptrを削除する．\n  static void _erase(unique_ptr<Node>& ptr) {\n    if (!ptr->childlen[0] && !ptr->childlen[1]) {\n      ptr.release();\n    } else {\n      bool i = ptr->childlen[0]\n                   ? 0\n                   : ptr->childlen[1] ? 1 : ptr->childlen[0]->priority > ptr->childlen[1]->priority;\n      _rotate(ptr, i);\n      _erase(ptr->childlen[i ^ 1]);\n    }\n  }\n\n public:\n  // map[]と同じ\n  value_type& operator[](key_type key) {\n    if (!(root)) {\n      root.reset(new Node());\n      return root->value;\n    } else {\n      return _touch(root, key).value;\n    }\n  }\n\n  // keyが等しいnodeを探す\n  // 存在しないなら空のunique_ptrの参照が返る\n  inline const unique_ptr<Node>& find(key_type key) const { return _find(root, key); }\n\n  // keyを持つnodeを削除する\n  inline void erase(key_type key) {\n    unique_ptr<Node>& node = _find(root, key);\n    if (node)\n      _erase(node);\n  }\n};\nTreap::randevice_type Treap::rnd = randevice_type();","path":"/src/cpp/container/balancing/treap_set.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"Treap(segment)(plain)","overview":"Treapとは，次を満たす確率的平衝二分探索木である．\n- keyについてみると，木は二分探索木になっている．\n- priority(randomized)についてみると，木はHeapになっている．\n\n実装したTreapは，配列っぽいインターフェースを持つ．split/mergeベースで記述．\n\n\n区間クエリは書けそう．\n例えば『キーがx以下のNodeにyを加算する』は，treap[x]とtreap[x].childlen[0]に対してLazy実装で実現できる．","usage":"void Treap::concat(Treap& another)\n; thisの末尾にanotherを結合して，anotherを空にする．\nTreap Treap::split(int size)\n; thisの前からsize個を切り出す．\nvoid Treap::insert(int index, value_t val)\n; index番目の要素の手前にvalを挿入する．\nvoid Treap::erase(int index)\n; index番目の要素を削除する．\nunique_ptr<TreapNode>& Treap::find(int index)\n; index番目の要素のスマートポインタの参照を得る．\n; index番目の要素が存在しないなら，空のスマートポインタの参照を得る．\nvalue_t& Treap::operator[](int index)\n; index番目の要素に対応するvalの参照を得る．無いなら爆発する．","require":"#include <memory>\n#include <algorithm>\n#include <random>\n#include <functional>\nusing namespace std;","verified":[],"references":["https://www.slideshare.net/iwiwi/2-12188757","http://www.prefield.com/algorithm/container/treap.html"],"code":"struct TreapNode {\n  typedef long long value_t;\n  typedef mt19937_64 randomizer_t;\n  static const value_t init_value_ = 0;\n  static randomizer_t rnd;\n\n  unique_ptr<TreapNode> childlen[2];\n  value_t value;\n  randomizer_t::result_type priority;\n  int n_node;\n\n  TreapNode(value_t v = init_value_) : value(v), priority(rnd() | 1), n_node(1) {}\n  TreapNode(value_t v, randomizer_t::result_type p) : value(v), priority(p), n_node(1) {}\n\n  // 子の操作前に必ず実行\n  // todo: 十分に呼ばれているかどうかvalidate\n  inline void update_before() {}\n\n  // 子の操作後に必ず実行\n  inline void update_after() {\n    n_node = 1;\n    if (childlen[0])\n      n_node += childlen[0]->n_node;\n    if (childlen[1])\n      n_node += childlen[1]->n_node;\n  }\n\n  // inline Node& operator[](size_t i) { return *childlen[i & 1]; }\n  // inline bool has(size_t i) { return (bool)childlen[i & 1]; }\n};\nTreapNode::randomizer_t TreapNode::rnd = TreapNode::randomizer_t();\n\nclass Treap : public unique_ptr<TreapNode> {\n public:\n  using value_t = TreapNode::value_t;\n  static const value_t init_value_ = TreapNode::init_value_;\n\n  Treap() {}\n  Treap(value_t val) : unique_ptr<TreapNode>(new TreapNode(val)) {}\n  Treap(unique_ptr<TreapNode>& p) { swap(p); }\n\n  static void _concat(unique_ptr<TreapNode>& treap1, unique_ptr<TreapNode>& treap2) {\n    if (!treap2)\n      return;\n    if (!treap1) {\n      treap1.swap(treap2);\n      return;\n    }\n    if (treap1->priority < treap2->priority) {\n      treap1->update_before();\n      if (!treap1->childlen[1])\n        treap1->childlen[1] = move(treap2);\n      else\n        _concat(treap1->childlen[1], treap2);\n    } else {\n      treap2->update_before();\n      if (!treap2->childlen[0]) {\n        treap2->childlen[0] = move(treap1);\n        treap1.swap(treap2);\n      } else {\n        treap1.swap(treap2->childlen[0]);\n        _concat(treap2->childlen[0], treap1);\n        treap1.swap(treap2);\n      }\n    }\n    treap1->update_after();\n  }\n\n  // anotherをthisの後ろにmergeする\n  inline void concat(Treap& another) { _concat(*this, another); }\n  inline void concat(Treap&& another) {\n    auto a = move(another);\n    _concat(*this, a);\n  }\n\n  // TODO: あまりにも下手\n  static unique_ptr<TreapNode> _split(unique_ptr<TreapNode>& node, int size) {\n    if (size <= 0)\n      return unique_ptr<TreapNode>();\n    if (!node->childlen[0]) {\n      if (!node->childlen[1])\n        return move(node);\n      node->update_before();\n      unique_ptr<TreapNode> cutted = move(node);\n      node = move(cutted->childlen[1]);\n      cutted->childlen[1] = move(_split(node, size - 1));\n      cutted->update_after();\n      node->update_after();\n      return cutted;\n    }\n    if (node->childlen[0]->n_node > size) {\n      unique_ptr<TreapNode> res = _split(node->childlen[0], size);\n      node->update_after();\n      return res;\n    } else if (node->childlen[0]->n_node < size) {\n      node->update_before();\n      unique_ptr<TreapNode> cutted = move(node);\n      node = move(cutted->childlen[1]);\n      cutted->childlen[1] = move(_split(node, size - cutted->childlen[0]->n_node - 1));\n      cutted->update_after();\n      node->update_after();\n      return cutted;\n    } else {\n      unique_ptr<TreapNode> res = move(node->childlen[0]);\n      node->update_after();\n      return res;\n    }\n  }\n\n  // 左からsize個切り取る\n  inline Treap split(int size) {\n    if (!(*this))\n      return Treap();\n    if ((*this)->n_node <= size) {\n      return move(*this);\n    }\n    unique_ptr<TreapNode> res = _split(*this, size);\n    (*this)->update_after();\n    return res;\n  }\n\n  static unique_ptr<TreapNode>& _find(unique_ptr<TreapNode>& node, int index) {\n    if (!node)\n      return node;\n    node->update_before();\n    if (!node->childlen[0])\n      return 0 < index ? _find(node->childlen[1], index - 1)\n                       : index == 0 ? node : node->childlen[0];\n    if (node->childlen[0]->n_node < index)\n      return _find(node->childlen[1], index - node->childlen[0]->n_node - 1);\n    if (node->childlen[0]->n_node > index)\n      return _find(node->childlen[0], index);\n    return node;\n  }\n\n  // 左からi番目のnodeを削除する\n  // 存在しないなら空のunique_ptrの参照が返る\n  inline unique_ptr<TreapNode>& find(int index) { return _find(*this, index); }\n  // 安全でない\n  inline value_t& operator[](int index) { return find(index)->value; }\n\n  // 左からidx番目のnodeを削除する\n  inline void erase(int index) {\n    if (index < 0 && (*this)->n_node <= index)\n      return;\n    Treap tmp = split(index);\n    split(1);\n    swap(tmp);\n    concat(tmp);\n  }\n\n  // i番目の要素の前にvalを挿入する\n  inline void insert(int index, value_t val) {\n    Treap tmp = split(index);\n    tmp.concat(Treap(val));\n    tmp.concat(*this);\n    swap(tmp);\n  }\n\n  // size要素から成るvalで初期化されたTreapを生成する\n  // 空でないTreapでgenerateを呼び出したら何もしない．\n  // 乱数生成がボトルネックで，O(NlogN)時間\n  void generate(int size, value_t val = init_value_) {\n    if (size <= 0 || *this)\n      return;\n    vector<TreapNode::randomizer_t::result_type> rr(size);\n    for (auto& x : rr)\n      x = TreapNode::rnd();\n    sort(rr.begin(), rr.end());\n\n    function<void(unique_ptr<TreapNode>&, int)> dfs = [&size, &rr, &val, &dfs](\n                                                          unique_ptr<TreapNode>& node, int idx1) {\n      if (idx1 > size)\n        return;\n      node.reset(new TreapNode(val, rr[idx1 - 1]));\n      node->update_before();\n      dfs(node->childlen[0], idx1 * 2);\n      dfs(node->childlen[1], idx1 * 2 + 1);\n      node->update_after();\n    };\n    dfs(*this, 1);\n  }\n\n  // void print_tour(unique_ptr<TreapNode>& node) {\n  //   if (!node) {\n  //     cout << \"NIL \";\n  //     return;\n  //   }\n  //   cout << \"L[\" << node->value << \"] \";\n  //   print_tour(node->childlen[0]);\n  //   cout << \"C[\" << node->value << \"] \";\n  //   print_tour(node->childlen[1]);\n  //   cout << \"R[\" << node->value << \"] \";\n  // }\n  // inline void print_tour() { print_tour(*this); }\n};","path":"/src/cpp/container/balancing/treap_segment.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"LeftistHeap","overview":"優先度付きキューに加えて，2つのHeapを併合出来る機能を持つ．\nstd::priority_queueとは異なって，最小値が取り出される仕様に注意．\nsize()は無いので，必要ならメンバ変数を1つ加えてあれこれ．\n時間計算量は O(log_2(N))．リスト実装なので，配列実装のHeapと比べて低速かもしれない．","usage":"#include <vector>\n#include <memory>\n#include <cassert>\n#include <algorithm>\nusing namespace std;","verified":["乱数"],"references":["http://hos.ac/blog/#blog0001"],"code":"template <typename T>\n// using T = int;\nclass LeftistHeap {\n  struct Node {\n    T value;\n    unique_ptr<Node> left, right;\n    int dist = 0;\n    inline Node(const T& _value) : value(_value) {}\n    template <typename... Args>\n    inline Node(Args&&... args) : value(args...) {}\n  };\n  static inline unique_ptr<Node>&& meldNode(unique_ptr<Node>&& heap1, unique_ptr<Node>&& heap2) {\n    if (!heap1)\n      return move(heap2);\n    if (!heap2)\n      return move(heap1);\n    if (!(heap1->value < heap2->value))\n      heap1.swap(heap2);\n    heap1->right = meldNode(move(heap1->right), move(heap2));\n    if (!heap1->left || heap1->left->dist < heap1->right->dist)\n      heap1->left.swap(heap1->right);\n    heap1->dist = heap1->right ? heap1->right->dist + 1 : 1;\n    return move(heap1);\n  }\n  unique_ptr<Node> root;\n\n public:\n  LeftistHeap() {}\n\n  inline bool empty() const { return !root; }\n  inline const T& top() const { return root->value; }\n  inline void push(const T& val) { root = meldNode(move(root), make_unique<Node>(val)); }\n  template <typename... Args>\n  inline void emplace(Args&&... args) {\n    root = meldNode(move(root), make_unique<Node>(args...));\n  }\n  inline void pop() { root = meldNode(move(root->left), move(root->right)); }\n  inline void meld(LeftistHeap&& another) { root = meldNode(move(root), move(another.root)); }\n};","path":"/src/cpp/container/balancing/leftistheap.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"2次元グリッドと二次元座標","overview":"ゲームAI用。\nクラス名は極端に短くしてある。","usage":"","require":"#include <cmath>\n#include <ostream>\n#include <iomanip>\n#include <vector>\nusing namespace std;","verified":[],"references":[],"words":["grid"," field"," point"," game"],"code":"struct P {\n  using T = int;\n  T y, x;\n\n  inline explicit P(T _y, T _x) : y(_y), x(_x) {}\n  inline P() : y(0), x(0) {}\n\n  inline bool operator==(P p) const { return y == p.y && x == p.x; }\n  inline bool operator<(P p) const { return y == p.y ? x < p.x : y < p.y; }\n  inline P operator+(P p) const { return P(y + p.y, x + p.x); }\n  inline P operator-(P p) const { return P(y - p.y, x - p.x); }\n  inline P& operator+=(P p) {\n    y += p.y;\n    x += p.x;\n    return *this;\n  }\n  inline P& operator-=(P p) {\n    y -= p.y;\n    x -= p.x;\n    return *this;\n  }\n  inline P& operator*=(T m) {\n    y *= m;\n    x *= m;\n    return *this;\n  }\n  inline T distM(P p) const { return abs(y - p.y) + abs(x - p.x); }\n  inline T distC(P p) const { return max(abs(y - p.y), abs(x - p.x)); }\n  template <typename ITR>\n  ITR nearestM(ITR begin, ITR end) const {\n    if (begin == end)\n      return end;\n    T best = distM(*begin);\n    ITR besti = begin;\n    for (ITR it = begin; ++it, it != end;) {\n      T m = distM(*it);\n      if (best < m) {\n        best = m;\n        besti = it;\n      }\n    }\n    return besti;\n  }\n};\ninline ostream& operator<<(ostream& os, P p) {\n  os << '(' << p.y << ',' << p.x << ')';\n  return os;\n}\n\nconst P FourMoving[] = {P(-1, 0), P(0, 1), P(1, 0), P(0, -1)};\nconst P FiveMoving[] = {P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(0, 0)};\nconst P EightMoving[] = {P(-1, 0),  P(0, 1),  P(1, 0),  P(0, -1),\n                         P(-1, -1), P(-1, 1), P(1, -1), P(1, 1)};\n\ninline P operator*(P::T m, P p) noexcept {\n  return P(m * p.y, m * p.x);\n}\n\ntemplate <typename T>\n// using T = int;\nstruct F {\n  int height, width;\n  vector<T> data;\n\n  F(int h = 1, int w = 1) : height(h), width(w), data(h * w) {}\n\n  inline T& operator()(int y, int x) { return data[x + y * width]; }\n  inline T& operator()(P p) { return data[p.x + p.y * width]; }\n  inline T operator()(int y, int x) const { return data[x + y * width]; }\n  inline T operator()(P p) const { return data[p.x + p.y * width]; }\n\n  inline bool safe(int y, int x) const { return 0 <= y && y < height && 0 <= x && x < width; }\n  inline bool safe(P p) const { return 0 <= p.y && p.y < height && 0 <= p.x && p.x < width; }\n\n  inline void fill(T e) { std::fill(data.begin(), data.end(), e); }\n  inline void resize(int h, int w) {\n    height = h;\n    width = w;\n    data.resize(h * w);\n  }\n\n  void print(ostream& os, int setw_arg = 4) {\n    for (int y = 0; y < height; ++y) {\n      for (int x = 0; x < width; ++x)\n        os << setw(setw_arg) << operator()(y, x) << ' ';\n      os << '\\n';\n    }\n  }\n};","path":"/src/cpp/grid/datastructure/euclid.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"2次元グリッド上のダイクストラ","overview":"全てのセルに対してstartからの距離を求める","usage":"","require":"#include <functional>\n#include <limits>\n#include <queue>\nusing namespace std;\n#include \"src/cpp/grid/datastructure/euclid.hpp\"\nusing ll = long long;","verified":["https://yukicoder.me/submissions/294734"],"references":[],"words":["grid"," dij"],"code":"/// <summary>\n/// 全てのセルに対してstartからの距離を求める\n/// </summary>\n/// <param name=\"height\">gridの高さ</param>\n/// <param name=\"width\">gridの幅</param>\n/// <param name=\"start\">開始地点</param>\n/// <param name=\"costFunc\">costFunc(curr, dest):\n/// 現在地点currから隣接点destに移動する時に掛かるコストを返す関数</param>\n/// <returns>開始地点からの最短距離</returns>\nF<ll> gridDistance(int height, int width, P start, function<ll(P, P)> costFunc) {\n  priority_queue<pair<ll, P>> pque;\n\n  F<ll> dist(height, width);\n  dist.fill(numeric_limits<ll>::max());\n  pque.emplace(0, start);\n  dist(start) = 0;\n\n  while (!pque.empty()) {\n    auto dx = pque.top();\n    pque.pop();\n    dx.first = -dx.first;\n\n    for (auto y : FourMoving) {\n      y += dx.second;\n      if (!dist.safe(y))\n        continue;\n      auto c = costFunc(dx.second, y);\n      if (c >= 0 && dist(y) > dx.first + c) {\n        dist(y) = dx.first + c;\n        pque.emplace(-(dx.first + c), y);\n      }\n    }\n  }\n\n  return dist;\n}","path":"/src/cpp/grid/method/griddistance.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"2次元グリッド上の距離(マンハッタン距離)","overview":"","usage":"","require":"#include <functional>\n#include <limits>\n#include <queue>\nusing namespace std;\n#include \"src/cpp/grid/datastructure/euclid.hpp\"","verified":["[TODO]"],"references":[],"words":["grid"," field"," point"],"code":"template <typename T>\nF<int> make_distancetable(int height,\n                          int width,\n                          const vector<P>& start_point,\n                          function<bool(P)> ismoveable) {\n  constexpr int inf = numeric_limits<int>::max();\n\n  F<int> result(height, width);\n  result.fill(inf);\n\n  queue<P> q;\n  for (const P& p : start_point)\n    q.push(p), result(p) = 0;\n\n  while (!q.empty()) {\n    P p = q.front();\n    q.pop();\n    int d = result(p);\n    if (0 < p.y && result(p.y - 1, p.x) == inf && ismoveable(P(p.y - 1, p.x)))\n      q.emplace(p.y - 1, p.x), result(p.y - 1, p.x) = d + 1;\n    if (p.y < height - 1 && result(p.y + 1, p.x) == inf && ismoveable(P(p.y + 1, p.x)))\n      q.emplace(p.y + 1, p.x), result(p.y + 1, p.x) = d + 1;\n    if (0 < p.x && result(p.y, p.x - 1) == inf && ismoveable(P(p.y, p.x - 1)))\n      q.emplace(p.y, p.x - 1), result(p.y, p.x - 1) = d + 1;\n    if (p.x < width - 1 && result(p.y, p.x + 1) == inf && ismoveable(P(p.y, p.x + 1)))\n      q.emplace(p.y, p.x + 1), result(p.y, p.x + 1) = d + 1;\n  }\n  return result;\n}","path":"/src/cpp/grid/method/distance.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"決定木","overview":"決定木","usage":"","require":"#include <memory>\n#include <functional>\nusing namespace std;","verified":[],"references":[],"code":"template <typename input_t, typename output_t>\nclass DecisionTree {\n  using comparator_t = function<bool(input_t)>;\n\n  bool leaf_;\n  comparator_t comparator_;\n  output_t out_;\n  unique_ptr<DecisionTree> childlen_[2];\n\n public:\n  DecisionTree() : leaf_(true), comparator_(nullptr) {}\n\n  inline DecisionTree& operator[](int i) { return *childlen_[i]; }\n  inline bool leaf() { return leaf_; }\n\n  inline void generate_leaf(output_t out) {\n    leaf_ = true;\n    childlen_[0].release();\n    childlen_[1].release();\n    out_ = out;\n  }\n\n  inline void generate_branch(comparator_t comparator) {\n    leaf_ = false;\n    childlen_[0].reset(new DecisionTree());\n    childlen_[1].reset(new DecisionTree());\n    comparator_ = comparator;\n  }\n\n  output_t eval(input_t val) { return leaf() ? out_ : childlen_[comparator_(val)]->eval(val); }\n};","path":"/src/cpp/predicator/datastructure/decisiontree.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"無向グラフ(隣接行列)","overview":"隣接行列を持つ．\n必要な空間計算量は |V|^2","usage":"void connect(int from, int to, W_T dist = 1)\n;つなげる．ループ辺は非推奨．\nvoid resize(int _n)\n;頂点数を変更する．\n;global変数として宣言した時に用いる．\ninline W_T& operator()(int y, int x);\n;行列の値の参照","require":"#include <vector>\nusing namespace std;","verified":[],"references":[],"words":["graphstruct"],"code":"class Graph2d {\n public:\n  using W_T = int;\n  int n;\n  vector<W_T> matrix;\n\n  explicit Graph2d(int size) : n(size), matrix(size * size){};\n\n  inline int size() const { return n; }\n  void resize(int s) {\n    n = s;\n    matrix.resize(n * n);\n  }\n  void resize(int s, W_T val) {\n    n = s;\n    matrix.resize(n * n, val);\n  }\n\n  inline W_T& at(int y, int x) { return matrix[y * n + x]; }\n  inline W_T& operator()(int y, int x) { return matrix[y * n + x]; }\n  inline W_T at(int y, int x) const { return matrix[y * n + x]; }\n  inline W_T operator()(int y, int x) const { return matrix[y * n + x]; }\n\n  inline void connect(int u, int v, W_T dist = 1) { at(u, v) = at(v, u) = dist; }\n  inline void connect_d(int from, int to, W_T dist = 1) {  // directedEdge u->v\n    at(from, to) = dist;\n  }\n};","path":"/src/cpp/graph/datastructure/graph2d.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"有向グラフ(隣接頂点)","overview":"隣接頂点の情報を持つ．\n必要な空間計算量は |V|+2|E|","usage":"void connect(int from, int to)\n;つなげる．ループ辺は非推奨．\nvoid resize(int _n)\n;頂点数を変更する．\n;global変数として宣言した時に用いる．","require":"#include <vector>\nusing namespace std;","verified":[],"references":[],"words":["graphstruct"],"code":"class DGraph {\n public:\n  int n;\n  vector<vector<int>> vertex_to;\n  vector<vector<int>> vertex_from;\n\n  explicit DGraph(int n = 1) : n(n), vertex_to(n), vertex_from(n) {}\n\n  inline int size() const { return n; }\n  void resize(int _n) {\n    n = _n;\n    vertex_to.resize(_n);\n    vertex_from.resize(_n);\n  }\n  void connect(int from, int to) {\n    vertex_to[(int)from].emplace_back(to);\n    vertex_from[(int)to].emplace_back(from);\n  }\n};","path":"/src/cpp/graph/datastructure/dgraph.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"有向グラフ(最大流用)","overview":"辺集合の情報を持つ．","usage":"","require":"#include <vector>\nusing namespace std;","verified":[],"references":[],"words":["graphstruct"],"code":"class DGraphF {\n public:\n  typedef int cap_t;\n  int n_;\n  struct Arc {\n    int from, to;\n    // 残量\n    cap_t left;\n    // 容量\n    cap_t cap;\n\n    Arc(int from = 0, int to = 0, cap_t w = 1) : from(from), to(to), left(w), cap(w) {}\n    inline bool operator<(const Arc& a) const {\n      return (left != a.left) ? left < a.left\n                              : (left < a.left) | (cap < a.cap) | (from < a.from) | (to < a.to);\n    }\n    inline bool operator==(const Arc& a) const {\n      return (from == a.from) && (to == a.to) && (left == a.left) && (cap == a.cap);\n    }\n  };\n  vector<vector<int>> vertex_to;\n  vector<vector<int>> vertex_from;\n  vector<Arc> edges;\n\n  explicit DGraphF(int n = 1) : n_(n), vertex_to(n), vertex_from(n) {}\n\n  void connect(int from, int to, cap_t left) {\n    vertex_to[(int)from].push_back((int)edges.size());  // toto\n    vertex_from[(int)to].push_back((int)edges.size());  // fromfrom\n    edges.emplace_back(from, to, left);\n  }\n\n  inline int size() const { return n_; }\n};","path":"/src/cpp/graph/datastructure/graphflow.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"無向グラフ(隣接頂点)","overview":"隣接頂点の情報を持つ．\n必要な空間計算量は |V|+2|E|","usage":"void connect(int from, int to)\n;つなげる．ループ辺は非推奨．\nvoid resize(int _n)\n;頂点数を変更する．\n;global変数として宣言した時に用いる．","require":"#include <vector>\nusing namespace std;","verified":[],"references":[],"words":["graphstruct"],"code":"class Graph {\n public:\n  int n;\n  vector<vector<int>> vertex_to;\n\n  explicit Graph(int n = 1) : n(n), vertex_to(n) {}\n\n  inline int size() const { return n; }\n  void resize(int _n) { vertex_to.resize(n = _n); }\n  void connect(int from, int to) {\n    vertex_to[(int)from].emplace_back(to);\n    vertex_to[(int)to].emplace_back(from);\n  }\n};","path":"/src/cpp/graph/datastructure/graph.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"Unionfind","overview":"頂点数N，辺∅のグラフがある．\nグラフに対して，辺の追加と同じ連結成分かどうかの判定を行う．int","usage":"bool connect(int x, int y)\n@ret : 元々繋がっていたならばno，\nbool same(int x, int y)\nint root(int x)\nint size(int x)","require":"#include <vector>\n#include <algorithm>\nusing namespace std;","verified":[],"references":[],"code":"class Unionfind {\n public:\n  vector<int> data;\n  explicit Unionfind(int size) : data(size, -1) {}\n  bool connect(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x != y) {\n      if (data[y] < data[x])\n        swap(x, y);\n      data[x] += data[y];\n      data[y] = (int)x;\n    }\n    return x != y;\n  }\n  inline bool same(int x, int y) { return root(x) == root(y); }\n  inline int root(int x) { return (int)(data[x] < 0 ? x : data[x] = root(data[x])); }\n  inline int size(int x) { return -data[root(x)]; }\n};","path":"/src/cpp/graph/datastructure/unionfind.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"無向グラフ(辺集合)","overview":"辺集合の情報を持つ．\n辺には1つの値を持たせることができる．\n必要な空間計算量は |V|+5|E|","usage":"void connect(int from, int to, W_T val = 0)\n;つなげる．ループ辺は非推奨．\nvoid resize(size_t _n)\n;頂点数を変更する．\n;global変数として宣言した時に用いる．\nvoid connect(vector<Edges>&& edges)\n; edgesを基に構築（グラフは空であること）","require":"#include <vector>\nusing namespace std;","verified":[],"references":[],"words":["graphstruct"],"code":"// Edge構造体を定義する無向グラフ\nclass GraphE {\n public:\n  using W_T = int;\n  struct Edge {\n    int u, v;\n    W_T value;\n    Edge(int from = 0, int to = 0, W_T value = 0) : u(from), v(to), value(value) {}\n    inline int to(int _v) const { return _v == v ? u : v; }\n  };\n  size_t n;\n  vector<vector<int>> vertex_to;\n  vector<Edge> edges;\n\n  explicit GraphE(int n = 1) : n(n), vertex_to(n) {}\n\n  inline size_t size() const noexcept { return n; }\n  void resize(size_t _n) { vertex_to.resize(n = _n); }\n  void connect(int from, int to, W_T val = 0) {\n    vertex_to[(size_t)from].push_back((int)edges.size());\n    vertex_to[(size_t)to].push_back((int)edges.size());\n    edges.emplace_back(from, to, val);\n  }\n  void connect(vector<Edge>&& es) {\n    edges = move(es);\n    for (int i = 0; (size_t)i < edges.size(); ++i) {\n      vertex_to[edges[i].u].push_back(i);\n      vertex_to[edges[i].v].push_back(i);\n    }\n  }\n};","path":"/src/cpp/graph/datastructure/graphe.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"有向グラフ(辺集合)","overview":"辺集合の情報を持つ．\n辺には1つの値を持たせることができる．\n必要な空間計算量は |V|+5|E|","usage":"void connect(int from, int to, W_T val = 0)\n;つなげる．ループ辺は非推奨．\nvoid resize(int _n)\n;頂点数を変更する．\n;global変数として宣言した時に用いる．","require":"#include <vector>\nusing namespace std;","verified":[],"references":[],"words":["graphstruct"],"code":"class DGraphE {\n public:\n  using W_T = int;\n  struct Arc {\n    int from, to;\n    W_T value;\n    Arc(int f = 0, int t = 0, W_T value = 0) : from(f), to(t), value(value) {}\n    inline int pair(int _v) const { return _v == to ? from : to; }\n  };\n  int n;\n  vector<vector<int>> vertex_to;\n  vector<vector<int>> vertex_from;\n  vector<Arc> arcs;\n\n  explicit DGraphE(int n = 1) : n(n), vertex_to(n), vertex_from(n) {}\n\n  inline int size() const { return n; }\n  void resize(int _n) {\n    n = _n;\n    vertex_to.resize(_n);\n    vertex_from.resize(_n);\n  }\n  void connect(int from, int to, W_T val = 0) {\n    vertex_to[(int)from].push_back((int)arcs.size());\n    vertex_from[(int)to].push_back((int)arcs.size());\n    arcs.emplace_back(from, to, val);\n  }\n};","path":"/src/cpp/graph/datastructure/dgraphe.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"LCA","overview":"根付き木が与えられたとき，準備O(NlogN)，次のクエリにO(1)で答えるアルゴリズム・データ構造．\n- 頂点u,vに共通する最も若い祖先\nLCA問題は，構築処理さえ済めば各質問をRMQの時間で解くことが出来る．\n\nループを含むグラフを与えた場合，再帰処理が終わらない可能性がある．","usage":"LCATable(const Graph& graph, int root = 0)\n; rootを根としたgraphに対してLCAを構築する\nint LCATable::operator()(int u, int v)\n; 頂点u,vに共通する最も若い祖先の頂点番号を取得する","require":"#include <vector>\nusing namespace std;\n#include \"src/cpp/container/likermq/rmq_sparsetable.hpp\"\n#include \"src/cpp/graph/datastructure/graph.hpp\"","verified":["problem."],"references":["thanks."],"words":["lca"],"code":"class LCATable {\n  vector<int> visited_;\n  vector<int> visited_inv_;\n  SparseTable<int> depth_;\n\n public:\n  LCATable(const Graph& g, int root = 0) : visited_(g.n * 2), visited_inv_(g.n), depth_(g.n * 2) {\n    build(g, root);\n  }\n\n  int _tour_dfs(const Graph& g, int idx, int from = -1, int step = 0, int dep = 0) {\n    depth_[step] = dep;\n    visited_inv_[idx] = step;\n    visited_[step] = idx;\n\n    for (int to : g.vertex_to[idx]) {\n      if (to == from)\n        continue;\n      step = _tour_dfs(g, to, idx, ++step, dep + 1);\n      depth_[step] = dep;\n      visited_[step] = idx;\n    }\n    return ++step;\n  }\n\n  inline void build(const Graph& g, int root = 0) {\n    _tour_dfs(g, root);\n    depth_.build();\n  }\n\n  inline int operator()(int u, int v) {\n    return visited_inv_[u] <= visited_inv_[v]\n               ? visited_[depth_.getminrangeIdx(visited_inv_[u], visited_inv_[v])]\n               :\n               operator()(v, u);\n  }\n};","path":"/src/cpp/graph/datastructure/wrapper/lca.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"ProjectSelection","overview":"project p_1..p_n があり，それぞれのprojectは状態Bである．\n今，いくつかのpeojectを状態Aに移すことができる．\n- (i, r) p_iが状態Aの時，利益(損失)rを得る．\n- (i, j, q)p_iが状態Aでp_jが状態Bの時，qの損失が発生する．\n利益を最大化する．\n燃やす埋めるフローの考察の補助に使うことができる．．","usage":"void push_revenue(int i, DGraphF::cap_t r)\n;p_iが状態Aの時，利益(損失)rを得る．\nvoid push_purchase(int i, int j, DGraphF::cap_t q)\n;p_iが状態Aでp_jが状態Bの時，qの損失が発生する．\nDGraphF::cap_t solve()\n解く．","require":"#include <vector>\n// #include \"src/cpp/graph/datastructure/graphflow.hpp\" // duplicate\n#include \"src/cpp/graph/method/flow/dinic.hpp\"","verified":["verified(ARC)"],"references":["https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem#Project_selection_problem","http://tokoharuland.hateblo.jp/entry/2017/11/12/234636"],"code":"class ProjectSelection {\n public:\n  int n_;\n  DGraphF graph_;\n  const DGraphF::cap_t inf_ = 1e9;\n  DGraphF::cap_t potential_ = 0;\n\n  ProjectSelection(int _n) : n_(_n), graph_(_n + 2) {}\n\n  // p_iが状態Aの時，利益(損失)rを得る．\n  inline void push_revenue(int i, DGraphF::cap_t r) {\n    potential_ += max(DGraphF::cap_t(0), r);\n    if (r > 0)\n      graph_.connect(n_, i, r);\n    else if (r < 0)\n      graph_.connect(i, n_ + 1, -r);\n  }\n  // p_iが状態Aでp_jが状態Bの時，qの損失が発生する．\n  inline void push_purchase(int i, int j, DGraphF::cap_t q) { graph_.connect(i, j, q); }\n\n  DGraphF::cap_t solve() {\n    std::vector<DGraphF::cap_t> result;\n    dinic(graph_, result, n_, n_ + 1);\n    return potential_ - result[n_ + 1];\n  }\n};","path":"/src/cpp/graph/datastructure/wrapper/projectselection.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"最小流量制限付き最大フロー","overview":"最小流量制限なしソルバーを使って、最小流制限ありの問題を解く。\n\n＃ 解説 ＃\n\n面倒なので，最小流l,最大流hで頂点uから頂点vへ流れる有向辺を(u,v)[l,h]と表記する．\n\n+ s→tな最大最小流量制限付きフローG=(V,E)を考える．最大流量制限付きフローG'を作りたい．\n+ 新たに頂点S,Tを作る．\n+ (u,v)[c,c+d]がGに存在するとき，G'に(u,v)[0,d],(u,T)[0,c],(S,v)[0,c]を与える．\n+ G'に多重辺が出来ることがある．\n+ S→T,S→t,s→T,s→tの順に最大流を求める．S,Tに隣接する辺に優先して流すため．\n+ S,Tに隣接する辺が全てemptyになっていれば，条件を満たすフローが存在\n+ 流量は(u,v)+(u,T)\n\n事前に全体の流量が把握出来るならば， #137248のように,S→s,t→Tの辺を作ってS→Tを流せばよい","usage":"solve_dinic_edge(map<pair<int, int>, int>& result_edge, int i_source, int i_sink)\n; i_source から i_sink に流す\n; 解が存在するならばtrueを返す\n; result_edge[make_pair(u,v)] で辺の流量","require":"#include <vector>\n#include <map>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graphflow.hpp\"\n#include \"src/cpp/graph/method/flow/dinic.hpp\"","verified":["http://yukicoder.me/submissions/137248","http://yukicoder.me/submissions/143696"],"references":["http://snuke.hatenablog.com/entry/2016/07/10/043918"],"words":["maxflow","dinic"],"code":"class FlowMinMax {\n public:\n  DGraphF graph;\n  const int v_source;  // vertex of new source\n  FlowMinMax(int n) : graph(n + 2), v_source(n) {}\n\n private:\n  bool _solve_maxflow_edge(map<pair<int, int>, int>& result_edge, int i_source, int i_sink) {\n    vector<int> resflow(graph.size(), 0);\n\n    dinic(graph, resflow, v_source, v_source + 1);\n    dinic(graph, resflow, v_source, i_sink);\n    dinic(graph, resflow, i_source, v_source + 1);\n    dinic(graph, resflow, i_source, i_sink);\n\n    for (int e : graph.vertex_from[v_source + 1]) {\n      const DGraphF::Arc& a = graph.edges[e];\n      if (0 < a.left)\n        return false;\n    }\n    for (int u = 0; u < graph.size() - 2; u++) {\n      for (int ei : graph.vertex_to[u]) {            // TODO:最適化の余地あり(らしい)\n        const DGraphF::Arc& a_uv = graph.edges[ei];  // u -> v\n        if (a_uv.to >= graph.size() - 2) {\n          if (0 < a_uv.left)\n            return false;\n          continue;\n        }\n\n        const DGraphF::Arc& a_sv = graph.edges[ei + 1];  // S -> v\n        int flow;\n        if (a_uv.to != a_sv.to) {\n          flow = a_uv.cap - a_uv.left;\n        } else {\n          if (0 < a_sv.left)\n            return false;\n          flow = a_sv.cap + a_uv.cap - a_sv.left - a_uv.left;\n        }\n        if (0 < flow)\n          result_edge[make_pair(u, a_uv.to)] += flow;\n      }\n    }\n    return true;\n  }\n\n public:\n  void connect(int from, int to, int w_min, int w_max) {\n    if (w_max == w_min) {\n      graph.connect(v_source, to, w_min);\n      graph.connect(from, v_source + 1, w_min);\n    } else if (w_min == 0) {\n      graph.connect(from, to, w_max - w_min);\n    } else {\n      graph.connect(from, v_source + 1, w_min);\n      graph.connect(from, to, w_max - w_min);\n      graph.connect(v_source, to, w_min);\n    }\n  }\n\n  inline bool solve_maxflow_edge(map<pair<int, int>, int>& result_edge, int i_source, int i_sink) {\n    return _solve_maxflow_edge(result_edge, i_source, i_sink);\n  }\n};","path":"/src/cpp/graph/datastructure/wrapper/minmaxflow.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"2-SAT Solver","overview":"2-SATを解く．\n強連結成分分解は内包済み．DGraphが必要．","usage":"Sat_2(int n)\n;\nvoid Sat_2::push(int a, int b)\n; 節を追加する．節は2つのリテラルから構成される．\n; リテラルの番号は1-indexed．\n; 負のインデックスを指定すると，否定として扱われる．\nvector<int> Sat_2::solve()\n; 充足不能なら、empty。\n; result[i]は，i番目のリテラルがTかFか．0-indexed","require":"#include <cassert>\n#include <vector>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/dgraph.hpp\"","verified":["https://yukicoder.me/submissions/496242"],"references":["http://www.prefield.com/algorithm/misc/2-sat.html","プログラミングコンテストチャレンジブック"],"code":"class Sat2 {\n public:\n  int n;\n  DGraph graph;\n\n  Sat2(int n) : n(n), graph(n * 2) {}\n\n private:\n  inline int _cv(int v) { return 0 < v ? (v - 1) * 2 : (-v - 1) * 2 + 1; }\n\n  vector<int> label_, postorder_;\n\n  void solveScc_dfs1(int v) {\n    if (label_[v] < 0)\n      return;\n    label_[v] = -1;\n    for (int to : graph.vertex_to[v])\n      solveScc_dfs1(to);\n    postorder_.push_back(v);\n  }\n\n  void solveScc_dfs2(int v, int rank) {\n    if (label_[v] > 0)\n      return;\n    label_[v] = rank;\n    for (int to : graph.vertex_from[v])\n      solveScc_dfs2(to, rank);\n  }\n\n public:\n  // 1 <= a <= n OR -1 >= a >= -n\n  // 正ならばx_a，負ならばNOT x_aを表現．\n  inline void push(int a, int b) {\n    assert(a != 0 && b != 0);\n    graph.connect(_cv(-a), _cv(b));\n    graph.connect(_cv(-b), _cv(a));\n  }\n\n  vector<int> solve() {\n    label_.resize(graph.n);\n    postorder_.reserve(graph.n);\n\n    for (int i = 0; i < graph.n; ++i)\n      solveScc_dfs1(i);\n    for (int i = (int)postorder_.size() - 1; 0 <= i; --i)\n      solveScc_dfs2(postorder_[i], i + 1);\n\n    vector<int> result(n);\n    for (int i = 0; i < n; ++i) {\n      if (label_[i * 2] == label_[i * 2 + 1])\n        return {};\n      result[i] = (label_[i * 2] < label_[i * 2 + 1]);\n    }\n    return result;\n  }\n};","path":"/src/cpp/graph/datastructure/wrapper/2sat.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"最大独立集合 (分岐限定法)","overview":"グラフの最大独立集合の大きさと選ぶ頂点集合を求める．\n入力グラフは単純グラフであること．多重辺はNG．\n最小頂点被覆，最大クリークに転用可能．\n分岐限定法．","usage":"int independentSet(const Graph& graph)","require":"#include <vector>\n#include <cstdint>\n#include \"src/cpp/graph/datastructure/graph.hpp\"","verified":["https://atcoder.jp/contests/code-thanks-festival-2017-open/submissions/4080519"],"words":["vertexcover"," independentSet"],"references":["FV Fomin, Exact Exponential Algorithms, Springer."],"tag":"wip","code":"pair<int, vector<int>> independentSet(const Graph& graph) {\n  int bestScore = 0;\n  vector<int8_t> bestSelection;\n\n  vector<int8_t> selection(graph.size());\n  vector<int> degree(graph.size());\n\n  for (int i = 0; i < graph.size(); ++i)\n    degree[i] = graph.vertex_to[i].size();\n\n  auto deleteVtxSel = [&](int vtx, int id) -> int {\n    int del = 1;\n    selection[vtx] = id;\n    for (int to : graph.vertex_to[vtx])\n      if (selection[to] == 0) {\n        selection[to] = -id;\n        ++del;\n      }\n    for (int to : graph.vertex_to[vtx])\n      if (selection[to] == -id)\n        for (int to2 : graph.vertex_to[to])\n          if (selection[to2] == 0)\n            degree[to2]--;\n    return del;\n  };\n\n  auto undoVtxSel = [&](int vtx, int id) {\n    for (int to : graph.vertex_to[vtx])\n      if (selection[to] == -id)\n        for (int to2 : graph.vertex_to[to])\n          if (selection[to2] == 0)\n            degree[to2]++;\n    for (int to : graph.vertex_to[vtx])\n      if (selection[to] == -id)\n        selection[to] = 0;\n    selection[vtx] = 0;\n  };\n\n  auto deleteVtxUnsel = [&](int vtx, int id) -> int {\n    selection[vtx] = -id;\n    for (int to : graph.vertex_to[vtx])\n      if (selection[to] == 0)\n        degree[to]--;\n    return 1;\n  };\n\n  auto undoVtxUnsel = [&](int vtx, int id) {\n    for (int to : graph.vertex_to[vtx])\n      if (selection[to] == 0)\n        degree[to]++;\n    selection[vtx] = 0;\n  };\n\n  auto dfs = [&](auto& dfs, int depth, int rem, int score) -> void {\n    if (rem == 0) {\n      if (bestScore < score) {\n        bestScore = score;\n        bestSelection = selection;\n      }\n      return;\n    }\n    if (score + rem < bestScore)\n      return;\n\n    int minDeg = 1e9, minDegi = 0;\n    int maxDeg = 0, maxDegi = 0;\n    int zeroDegCnt = 0;\n    for (int i = 0; i < graph.size(); ++i) {\n      if (selection[i] != 0)\n        continue;\n      if (degree[i] == 0) {\n        ++zeroDegCnt;\n        selection[i] = depth;\n      }\n      if (minDeg > degree[i]) {\n        minDeg = degree[i];\n        minDegi = i;\n      }\n      if (maxDeg < degree[i]) {\n        maxDeg = degree[i];\n        maxDegi = i;\n      }\n    }\n\n    if (zeroDegCnt > 0) {\n      dfs(dfs, depth + 1, rem - zeroDegCnt, score + zeroDegCnt);\n      for (int i = 0; i < graph.size(); ++i) {\n        if (selection[i] == depth)\n          selection[i] = 0;\n      }\n      return;\n    }\n\n    if (minDeg == 1 || (minDeg == 2 && maxDeg == 2)) {\n      int dl = deleteVtxSel(minDegi, depth);\n      dfs(dfs, depth + 1, rem - dl, score + 1);\n      undoVtxSel(minDegi, depth);\n      return;\n    }\n\n    {\n      deleteVtxUnsel(maxDegi, depth);\n      dfs(dfs, depth + 1, rem - 1, score);\n      undoVtxUnsel(maxDegi, depth);\n\n      int dl = deleteVtxSel(maxDegi, depth);\n      dfs(dfs, depth + 1, rem - dl, score + 1);\n      undoVtxSel(maxDegi, depth);\n    }\n  };\n\n  dfs(dfs, 1, graph.size(), 0);\n\n  vector<int> idxs;\n  for (int i = 0; i < graph.size(); ++i)\n    if (bestSelection[i] > 0)\n      idxs.push_back(i);\n  idxs.shrink_to_fit();\n  return make_pair(bestScore, idxs);\n}","path":"/src/cpp/graph/method/independentset.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"トポロジカルソート","overview":"トポロジカルソートについては次のリンクを参照\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B&lang=jp","usage":"vector<int> topological_sort(const DGraph& graph)\ngraph :\n@ret  : 頂点集合0..N-1がトポロジカルソートされたもの．\n; @ret.size() < N の時，入力のグラフがDAGでは無かったことを示す．","require":"#include <vector>\n#include <functional>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/dgraph.hpp\"","verified":["http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2641044#1"],"references":[],"code":"vector<int> topologicalSort(const DGraph& graph) {\n  const int n = graph.n;\n  vector<int> result;\n  result.reserve(n);\n  vector<int> start;\n  start.reserve(n);\n  vector<int> sync(n);\n\n  for (int i = 0; i < n; ++i) {\n    int x = graph.vertex_from[i].size();\n    if (x == 0)\n      start.push_back(i);\n    else\n      sync[i] = x;\n  }\n\n  function<void(int)> dfs = [&](int idx) {\n    result.push_back(idx);\n    for (int to : graph.vertex_to[idx]) {\n      if (--sync[to] <= 0)\n        dfs(to);\n    }\n  };\n  for (int s : start)\n    dfs(s);\n  return result;\n}","path":"/src/cpp/graph/method/topological_sort.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"オイラー路検出","overview":"要は一筆書き．\nまだ汚いのでそのうち\nTODO: fix -Wsign-compare","usage":"vector<int> find_eulerialTrail(const GraphE& graph)\n@ret : 辿り方．頂点番号，辺番号，頂点番号，…と交互に記述される．","require":"#include <vector>\n#include <algorithm>\n#include <stack>\n#include <map>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/unionfind.hpp\"\n#include \"src/cpp/graph/datastructure/dgraphe.hpp\"","verified":["[TODO]"],"references":["http://shonen9th.blog.fc2.com/blog-entry-147.html"],"words":["euler"],"tag":"wip, unverified","code":"// オイラー路が存在するかどうか\n// 存在しなかったら(-1,-1)，存在したら(始点,終点)\n// 閉路なら 始点==終点\npair<int, int> has_eulerialTrail(const DGraphE& graph) {\n  Unionfind uf(graph.size());\n\n  int vstart = -1, vgoal = -1;\n\n  for (int i = 0; i < graph.size(); ++i) {\n    if (graph.vertex_from[i].size() + 1 == graph.vertex_to[i].size()) {\n      if (vstart >= 0)\n        return make_pair(-1, -1);\n      vstart = i;\n    } else if (graph.vertex_from[i].size() == graph.vertex_to[i].size() + 1) {\n      if (vgoal >= 0)\n        return make_pair(-1, -1);\n      vgoal = i;\n    } else if (graph.vertex_from[i].size() != graph.vertex_to[i].size())\n      return make_pair(-1, -1);\n  }\n  if ((vstart == -1) != (vgoal == -1))\n    return make_pair(-1, -1);\n  for (const auto& a : graph.arcs) {\n    uf.connect(a.from, a.to);\n  }\n  if (uf.size(0) < graph.size())\n    return make_pair(-1, -1);\n\n  if (vstart == -1)\n    vgoal = vstart = 0;\n\n  return make_pair(vstart, vgoal);\n}\n\nvector<int> find_eulerialTrail(const DGraphE& graph, int startEdge = 0) {\n  using boolean = int;\n\n  // 辺集合を複数のサイクルに分割したとき，属するサイクル番号\n  vector<int> group(graph.arcs.size(), -1);\n  //\n  vector<int> prior(graph.arcs.size(), -1);\n\n  int groupCount = 0;\n\n  // ループ辺は独立した1つのサイクルとして分割\n  for (int ei = 0; ei < graph.arcs.size(); ++ei)\n    if (graph.arcs[ei].from == graph.arcs[ei].to)\n      group[ei] = groupCount++;\n\n  // 辺集合を複数のサイクルに分割\n  for (int idx_ = -1; idx_ < (int)graph.arcs.size(); ++idx_) {\n    int idx = idx_ == -1 ? startEdge : idx_;\n    if (group[idx] >= 0)\n      continue;\n\n    group[idx] = groupCount++;\n    // int tail = graph.arcs[idx].from;\n    int v = graph.arcs[idx].to;\n\n    int tim = 0;\n    prior[idx] = 0;\n\n    for (bool running = true; running;) {\n      running = false;\n      for (int ie : graph.vertex_to[v]) {\n        if (group[ie] >= 0)\n          continue;\n\n        prior[ie] = ++tim;\n        group[ie] = group[idx];\n        v = graph.arcs[ie].to;\n        running = true;\n        break;\n      }\n    }\n  }\n  vector<int> result;\n  stack<int> history;\n\n  int tail = graph.arcs[startEdge].from;\n  int curr = graph.arcs[startEdge].to;\n  history.push(group[startEdge]);\n\n  result.push_back(tail);\n  result.push_back(startEdge);\n  result.push_back(curr);\n\n  vector<boolean> encountedGroup(groupCount);\n  encountedGroup[group[startEdge]] = true;\n\n  group[startEdge] = -1;\n\n  for (int step = 1; step < graph.arcs.size(); ++step) {\n    bool prfound = false;\n    map<int, pair<int, int>> connected;  // [group] = prior, edgeid\n    for (int ie : graph.vertex_to[curr]) {\n      // 通過済みの辺\n      if (group[ie] < 0)\n        continue;\n\n      int g = group[ie];\n\n      // 通過したことが無いサイクルならば\n      if (!encountedGroup[g]) {\n        history.push(g);\n        encountedGroup[g] = true;\n\n        group[ie] = -1;\n        curr = graph.arcs[ie].to;\n        result.push_back(ie);\n        result.push_back(curr);\n\n        prfound = true;\n        break;\n      } else {\n        if (connected.count(g) == 0)\n          connected[g] = make_pair(prior[ie], ie);\n        else\n          connected[g] = min(connected[g], make_pair(prior[ie], ie));\n      }\n    }\n    if (prfound)\n      continue;\n    if (connected.empty())\n      break;\n\n    {\n      // 今通過しているサイクルを一通り巡回したならば，1つ前のサイクルに乗り換える\n      while (connected.count(history.top()) == 0) {\n        history.pop();\n        if (history.empty())\n          return result;  // assertion\n      }\n      // 1つ前のサイクルに乗り換える，辺id\n      int ie = connected[history.top()].second;\n      group[ie] = -1;\n      curr = graph.arcs[ie].to;\n\n      result.push_back(ie);\n      result.push_back(curr);\n    }\n  }\n\n  return result;\n}","path":"/src/cpp/graph/method/find_euleriantrail.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"オイラー路検出(テスト用)","overview":"","usage":"","require":"#include \"src/cpp/implements/compe.hpp\"\n#include \"src/cpp/graph/datastructure/dgraphe.hpp\"\n#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;","verified":[],"references":[],"words":["euler"],"tag":"wiip","code":"DGraphE gen_random_eulerialTrail(int N, int M) {\n  vector<pair<int, int>> route;\n  route.reserve(M);\n  int la = 0;\n  repeat(i, M - 1) {\n    int e = rand(0, N - 1);\n    route.emplace_back(la, e);\n    la = e;\n  }\n  shuffle(route.begin(), route.end(), randdev);\n\n  vector<int> shuffler(N);\n  iota(shuffler.begin(), shuffler.end(), 0);\n  shuffle(shuffler.begin(), shuffler.end(), randdev);\n\n  DGraphE graph(N);\n  for (auto p : route)\n    graph.connect(shuffler[p.first], shuffler[p.second]);\n\n  return graph;\n}\n\nbool check_eulerialTrail(const DGraphE& graph, vector<int> trail) {\n  vector<int> chkvertex(graph.size());\n  vector<int> chkedge(graph.arcs.size());\n\n  int v = trail[0];\n\n  for (int i = 1; i < trail.size(); ++i) {\n    int t = trail[i];\n    if (i % 2 == 1) {\n      auto e = graph.arcs[t];\n      if (chkedge[t])\n        return false;\n      if (e.from != v)\n        return false;\n      v = e.to;\n    } else {\n      if (v != t)\n        return false;\n    }\n  }\n  return true;\n}","path":"/src/cpp/graph/method/euleriantrail_checker.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"巡回セールスマン問題(bitDP)","overview":"巡回セールスマン問題をbitDPで解く．\n三角不等式を満たしていなくても解ける．\nTODO","usage":"void connect(int from, int to, W_T dist = 1)\n;つなげる．ループ辺は非推奨．\nvoid resize(int _n)\n;頂点数を変更する．\n;global変数として宣言した時に用いる．\ninline W_T& operator()(int y, int x);\n;行列の値の参照","require":"#include <vector>\n#include <algorithm>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graph2d.hpp\"\ncpp/graph/datastructure/graph2dcpp","words":["tsp"],"verified":["http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2588066#1","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2641075#1"],"references":[],"code":"vector<int> tsProblem(int n, const Graph2d& graph) {\n  using dist_T = long long;\n  using ull = unsigned long long;\n\n  if (n <= 1)\n    return {0};\n  if (n == 2)\n    return {0, 1};\n\n  vector<vector<dist_T>> dp;\n  ull bit;\n\n  // initialize\n  dp.resize(n);\n  for (auto& v : dp)\n    v.resize(1 << n), fill(v.begin(), v.end(), (dist_T)5e15);\n\n  // bitdp\n  dp[0][1] = 0;\n  for (int bit_i = 1; bit_i < (1 << n) - 1; ++bit_i) {\n    bit = bit_i;\n\n    for (int from = 0; from < n; ++from) {\n      if (!(bool)(bit & (1ull << from)))\n        continue;\n      dist_T pt = dp[from][bit_i];\n\n      for (int to = 0; to < n; ++to) {\n        if ((bool)(bit & (1ull << to)))\n          continue;\n        dp[to][bit_i | (1ull << to)] = min(dp[to][bit_i | (1 << to)], pt + graph(from, to));\n      }\n    }\n  }\n  // 末尾を探す\n  dist_T best = 5e15;\n  int tail = 0;\n  for (int i = 0; i < n; ++i)\n    if (dp[i][(1 << n) - 1] + graph(i, 0) < best)\n      best = dp[i][(1 << n) - 1] + graph(i, 0), tail = i;\n\n  // 復元\n  vector<int> tourist;\n  tourist.reserve(n);\n  bit = (1ull << n) - 1ull;\n  for (int z = 0; z < n - 1; ++z) {\n    ull b = bit;\n    tourist.push_back(tail);\n    bit ^= bit & (1ull << tail);\n    ull c = bit;\n\n    for (int nxt = 0; nxt < n; ++nxt) {\n      if ((bit & (1ull << (ull)nxt)) && abs(dp[tail][b] - dp[nxt][c] - graph(nxt, tail)) == 0) {\n        tail = nxt;\n        break;\n      }\n    }\n  }\n  tourist.push_back(0);\n  reverse(tourist.begin(), tourist.end());\n  return tourist;\n}","path":"/src/cpp/graph/method/tsp.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"関節点検出","overview":"[TODO] validation","usage":"detect_articulation_point(const GraphE& graph, vector<int>& out)\nout : out[頂点番号] = 関節点 ? 1 : 0","require":"#include <vector>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graph.hpp\"","verified":[],"words":["articulation"],"tag":"unverified","code":"void detect_articulation_point(const Graph& graph, vector<int>& out) {\n  out.resize(graph.n);\n  fill(out.begin(), out.end(), 0);\n  vector<int> visited(graph.n);\n\n  int cnt = 1;\n  function<int(int)> dfs = [&](int idx) {\n    // printf(\"%d: called %d\\n\",idx,visited[idx]);\n    int p = visited[idx];\n    for (int to : graph.vertex_to[idx]) {\n      if (visited[to]) {\n        p = min(p, visited[to]);\n      } else {\n        visited[to] = ++cnt;\n        int q = dfs(to);\n        if (visited[idx] == q)\n          out[idx] = 1;\n        p = min(p, q);\n      }\n    }\n    // printf(\"%d: return %d\\n\",idx,p);\n    return p;\n  };\n  visited[0] = 1;\n  int start_degree = 0;\n  for (int to : graph.vertex_to[0]) {\n    if (!visited[to]) {\n      ++start_degree;\n      visited[to] = ++cnt;\n      dfs(to);\n    }\n  }\n  if (2 <= start_degree)\n    out[0] = 1;\n}","path":"/src/cpp/graph/method/articulation.hpp","references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"warshall-floyd","overview":"全ペアの最短経路を求める．\n[note] 辺が無い頂点ペアの距離はinfで埋めておくこと．","usage":"void warshall_floyd(Graph2d& g)","require":"#include <algorithm>\n#include \"src/cpp/graph/datastructure/graph2d.hpp\"","verified":[],"references":[],"code":"void warshall_floyd(Graph2d& g) {\n  int i, j, k;\n  for (i = 0; i < g.n; i++) {\n    for (j = 0; j < g.n; j++) {\n      for (k = 0; k < g.n; k++) {\n        g(j, k) = std::min(g(j, k), g(j, i) + g(i, k));\n      }\n    }\n  }\n}","path":"/src/cpp/graph/method/distance/warshallfloyd.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"SPFA","overview":"shortest path faster algorithm\n負閉路検出可能・負辺動作可能。\nベルマンフォードより速いらしい。\nただし閉路検出が遅いような気がする。","usage":"vector<DGraphE::W_T> shortestPathFasterAlgorithm(const DGraphE& graph, int start = 0, bool*\ndetectNegativeCycle = nullptr) detectNegativeCycle = nullptrと置くと負閉路検出を無効化する","require":"#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/dgraphe.hpp\"","verified":["https://atcoder.jp/contests/abc137/submissions/7173578"],"references":["http://hogloid.hatenablog.com/entry/20120409/1333973448","https://tubo28.me/compprog/algorithm/spfa/"],"code":"vector<DGraphE::W_T> shortestPathFasterAlgorithm(const DGraphE& graph,\n                                                 int start = 0,\n                                                 bool* detectNegativeCycle = nullptr) {\n  using T = DGraphE::W_T;\n  const int n = graph.n;\n  vector<bool> incl(n);\n  vector<T> dist(n, numeric_limits<T>::max() / 2);\n  vector<int> counter;\n  if (detectNegativeCycle)\n    *detectNegativeCycle = false, counter.resize(n);\n\n  queue<int> que;\n  que.push(start);\n  incl[start] = true;\n  dist[start] = 0;\n  while (!que.empty()) {\n    int v = que.front();\n    que.pop();\n    incl[v] = false;\n    for (auto ai : graph.vertex_to[v]) {\n      auto a = graph.arcs[ai];\n\n      if (dist[a.to] <= dist[v] + a.value)\n        continue;\n      dist[a.to] = dist[v] + a.value;\n\n      if (incl[a.to])\n        continue;\n      incl[a.to] = true;\n      que.push(a.to);\n\n      if (detectNegativeCycle && ++counter[a.to] >= n) {\n        *detectNegativeCycle = true;\n        return move(dist);\n      }\n    }\n  }\n  return move(dist);\n}","path":"/src/cpp/graph/method/distance/spfa.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"bellmanFord","overview":"bellmanFord法。\n頂点数と辺情報を引数とする。\nループする場合、空のvectorを返す。","usage":"","require":"#include <vector>\n#include <limits>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/dgraphe.hpp\"","verified":["https://atcoder.jp/contests/abc137/submissions/6908127"],"words":["bellmanford"],"code":"vector<DGraphE::W_T> bellmanFord(int n, const vector<DGraphE::Arc>& arcs, int start = 0) {\n  using T = DGraphE::W_T;\n  vector<T> dist(n, numeric_limits<T>::min() / 2);\n  dist[start] = 0;\n  bool running = true;\n  while (running && --n >= 0) {\n    running = false;\n    for (auto& arc : arcs) {\n      if (dist[arc.to] < dist[arc.from] + arc.value) {\n        dist[arc.to] = dist[arc.from] + arc.value;\n        running = true;\n        if (n <= 0)\n          return vector<T>();\n      }\n    }\n  }\n  return dist;\n}","path":"/src/cpp/graph/method/bellmanford.hpp","references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"ダイクストラ法(無向・重み無し)","overview":"","usage":"","require":"#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graph.hpp\"","words":["dijkstra"],"verified":[],"references":[],"code":"vector<int> dijkstra(const Graph& graph, int startIndex) {\n  vector<int> dist(graph.size(), numeric_limits<int>::max());\n\n  queue<pair<int, int>> que;  // <dist, idx>\n  que.emplace(0, startIndex);\n  dist[startIndex] = 0;\n\n  while (!que.empty()) {\n    int d = que.front().first;\n    int v = que.front().second;\n    que.pop();\n    if (dist[v] < d)\n      continue;\n\n    for (int u : graph.vertex_to[v])\n      if (d + 1 < dist[u])\n        que.emplace(dist[u] = d + 1, u);\n  }\n  return move(dist);\n}","path":"/src/cpp/graph/method/dijkstra/dijkstra.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"ダイクストラ法(無向・辺重み)","overview":"","usage":"","require":"#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graphe.hpp\"","words":["dijkstra"],"verified":[],"references":[],"code":"vector<GraphE::W_T> dijkstraEdgeWeighted(const GraphE& graph, int startIndex) {\n  using T = GraphE::W_T;\n  vector<T> dist(graph.size(), numeric_limits<T>::max());\n\n  priority_queue<pair<T, int>> que;  // <dist, idx>\n  que.emplace(0, startIndex);\n  dist[startIndex] = 0;\n\n  while (!que.empty()) {\n    T d = -que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (dist[v] < d)\n      continue;\n\n    for (int ei : graph.vertex_to[v]) {\n      auto e = graph.edges[ei];\n      int u = e.to(v);\n      if (d + e.value < dist[u]) {\n        que.emplace(-(dist[u] = d + e.value), u);\n      }\n    }\n  }\n  return move(dist);\n}","path":"/src/cpp/graph/method/dijkstra/dijkstraWE.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"ダイクストラ法(有向・辺重み)","overview":"","usage":"","require":"#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/dgraphe.hpp\"","words":["dijkstra"],"verified":[],"references":[],"code":"vector<DGraphE::W_T> dijkstraDEdgeWeighted(const DGraphE& graph, int startIndex) {\n  using T = DGraphE::W_T;\n  vector<T> dist(graph.size(), numeric_limits<T>::max());\n\n  priority_queue<pair<T, int>> que;  // <dist, idx>\n  que.emplace(0, startIndex);\n  dist[startIndex] = 0;\n\n  while (!que.empty()) {\n    T d = -que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (dist[v] < d)\n      continue;\n\n    for (int ei : graph.vertex_to[v]) {\n      auto e = graph.arcs[ei];\n      int u = e.to;\n      if (d + e.value < dist[u]) {\n        que.emplace(-(dist[u] = d + e.value), u);\n      }\n    }\n  }\n  return move(dist);\n}","path":"/src/cpp/graph/method/dijkstra/dijkstraDWE.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"ダイクストラ法(有向・重み無し)","overview":"","usage":"","require":"#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/dgraph.hpp\"","words":["dijkstra"],"verified":["https://atcoder.jp/contests/abc132/submissions/6175759"],"references":[],"code":"vector<int> dijkstraD(const DGraph& graph, int startIndex) {\n  vector<int> dist(graph.size(), numeric_limits<int>::max());\n\n  queue<pair<int, int>> que;  // <dist, idx>\n  que.emplace(0, startIndex);\n  dist[startIndex] = 0;\n\n  while (!que.empty()) {\n    int d = que.front().first;\n    int v = que.front().second;\n    que.pop();\n    if (dist[v] < d)\n      continue;\n\n    for (int u : graph.vertex_to[v])\n      if (d + 1 < dist[u])\n        que.emplace(dist[u] = d + 1, u);\n  }\n  return move(dist);\n}","path":"/src/cpp/graph/method/dijkstra/dijkstraD.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"ダイクストラ法(無向・頂点重み)","overview":"","usage":"","require":"#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graph.hpp\"","words":["dijkstra"],"verified":[],"references":[],"code":"template <typename T, typename VECTOR>\nvector<T> dijkstraVertexWeighted(const Graph& graph, int startIndex, const VECTOR& weight) {\n  vector<T> dist(graph.size(), numeric_limits<int>::max());\n\n  priority_queue<pair<T, int>> que;  // <dist, idx>\n  que.emplace(0, startIndex);\n  dist[startIndex] = 0;\n\n  while (!que.empty()) {\n    T d = -que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (dist[v] < d)\n      continue;\n\n    for (int u : graph.vertex_to[v])\n      if (d + weight[u] < dist[u])\n        que.emplace(-(dist[u] = d + weight[u]), u);\n  }\n  return move(dist);\n}","path":"/src/cpp/graph/method/dijkstra/dijkstraWV.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"橋検出","overview":"","usage":"detect_bridge(const GraphE& graph, vector<int>& out)\nout : out[辺番号] = 橋 ? 1 : 0","require":"#include <vector>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graphe.hpp\"","verified":["contests/abc075/submissions/1688087"],"words":["bridge"],"code":"// 橋を探す\n//\nvoid detect_bridge(const GraphE& graph, vector<int>& out) {\n  out.resize(graph.edges.size());\n  fill(out.begin(), out.end(), 0);\n  vector<int> visited(graph.n);\n\n  int cnt = 1;\n  function<int(int, int)> dfs = [&](int idx, int from) {\n    // printf(\"%d: called %d\\n\",idx,visited[idx]);\n    int p = visited[idx];\n    for (int ei : graph.vertex_to[idx]) {\n      if (ei == from)\n        continue;\n      auto& edge = graph.edges[ei];\n      int to = edge.to(idx);\n      if (visited[to]) {\n        p = min(p, visited[to]);\n      } else {\n        visited[to] = ++cnt;\n        int q = dfs(to, ei);\n        if (visited[idx] < q)\n          out[ei] = 1;\n        p = min(p, q);\n      }\n    }\n    // printf(\"%d: return %d\\n\",idx,p);\n    return p;\n  };\n  visited[0] = 1;\n  dfs(0, -1);\n}","path":"/src/cpp/graph/method/bridge.hpp","references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"dinic(最大流ソルバー)","overview":"dinic法で最大流問題を解く。\nLPの特殊な形とも捉えることができる。","usage":"void dinic(DGraphF &graph, vector<DGraphF::cap_t>& result, int i_source, int i_sink)\ngraph    : ネットワーク\nresult   : 各頂点にどれだけの水流が流れたか\ni_source : 源\ni_sink   : 流し台","require":"#include <vector>\n#include <functional>\n#include <queue>\n#include <cassert>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graphflow.hpp\"","verified":["[TODO] リファクタリング後のコードのverify","https://yukicoder.me/submissions/208764"],"references":["http://tubo28.me/algorithm/dinic/","http://topcoder.g.hatena.ne.jp/Mi_Sawa/20140311"],"tag":"wip","code":"void dinic(DGraphF& graph, vector<DGraphF::cap_t>& result, int i_source, int i_sink) {\n  assert(i_source != i_sink);\n\n  result.resize(graph.n_);\n  vector<int> dist(graph.n_);\n  vector<bool> visited(graph.n_);\n\n  function<DGraphF::cap_t(int, int, DGraphF::cap_t)> _dfs =\n      [&](int u, int i_sink, DGraphF::cap_t mini) -> DGraphF::cap_t {\n    // DAG\n    // TODO: 経路再利用\n    if (i_sink == u)\n      return mini;\n    if (visited[u])\n      return -1;\n    visited[u] = true;\n\n    DGraphF::cap_t sumw = 0;\n    bool term = true;\n    for (int edgeidx : graph.vertex_to[u]) {\n      auto& edge = graph.edges[edgeidx];\n      if (edge.left > 0 && dist[u] > dist[edge.to]) {\n        DGraphF::cap_t f = (mini < 0) ? edge.left : min(edge.left, mini);\n\n        f = _dfs(edge.to, i_sink, f);\n        if (f == -1)\n          continue;\n        edge.left -= f;\n        result[edge.to] += f;\n\n        sumw += f;\n        mini -= f;\n        term = false;\n        visited[u] = false;  // TODO: 末尾では?\n        if (mini == 0)\n          return sumw;\n      }\n    }\n    for (int edgeidx : graph.vertex_from[u]) {\n      auto& edge = graph.edges[edgeidx];\n      if (edge.cap > edge.left && dist[u] > dist[edge.from]) {\n        DGraphF::cap_t f = (mini < 0) ? (edge.cap - edge.left) : min(edge.cap - edge.left, mini);\n\n        f = _dfs(edge.from, i_sink, f);\n        if (f == -1)\n          continue;\n        edge.left += f;\n        result[edge.to] -= f;\n\n        sumw += f;\n        mini -= f;\n        term = false;\n        visited[u] = false;\n        if (mini == 0)\n          return sumw;\n      }\n    }\n    return term ? -1 : sumw;\n  };\n\n  queue<int> que;\n  for (int distbegin = 0;; distbegin += (int)graph.n_) {\n    // sinkからsourceへの距離を計算．\n    que.emplace(i_sink);\n    dist[i_sink] = distbegin + 1;\n    while (!que.empty()) {\n      int v = que.front();\n      que.pop();\n      for (int edgeidx : graph.vertex_from[v]) {\n        const auto edge = graph.edges[edgeidx];\n        if (0 < edge.left && dist[edge.from] <= distbegin) {\n          dist[edge.from] = dist[v] + 1;\n          que.push(edge.from);\n        }\n      }\n      for (int edgeidx : graph.vertex_to[v]) {\n        const auto edge = graph.edges[edgeidx];\n        if (edge.left < edge.cap && dist[edge.to] <= distbegin) {\n          dist[edge.to] = dist[v] + 1;\n          que.push(edge.to);\n        }\n      }\n    }\n    fill(visited.begin(), visited.end(), false);\n\n    if (dist[i_source] <= distbegin)\n      break;\n    else\n      result[i_source] += _dfs(i_source, i_sink, -1);\n  }\n}","path":"/src/cpp/graph/method/flow/dinic.hpp","words":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"最小頂点被覆 (半分全列挙)","overview":"グラフの最小頂点被覆の大きさと選ぶ頂点集合を求める．\n最大独立集合，最大クリークに転用可能．\n半分全列挙の実装","usage":"int vertexCover(const Graph& graph)","require":"#include <vector>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graph.hpp\"\ncpp/graph/datastructure/graph.hpp","verified":["http://buyoh.hateblo.jp/entry/2017/12/10/184345","https://atcoder.jp/contests/code-thanks-festival-2017-open/submissions/4065305"],"words":["vertexcover"],"references":[],"code":"inline int bitcount(int x) {\n  return bitset<31>(x).count();\n}\n\n// 半分全列挙\npair<int, vector<int>> vertexCover(const Graph& graph) {\n  const int n = graph.n;\n  const int n_A = n / 2;\n  const int n_B = n - n_A;\n  const int inf = 1e9;\n\n  // group A : i <  n_A\n  // group B : i >= n_A\n\n  // dp[S] : S \\subseteq V_A，\n  vector<int> ans_partial_A(1 << n_A, 0);\n\n  // Sが独立集合なら0，独立集合でないならinfとなるように初期状態を構成する．\n  for (int i = 0; i < n_A; ++i) {\n    int bit = 1 << i;\n    for (int j : graph.vertex_to[i])\n      if (j < n_A)\n        ans_partial_A[bit | (1 << j)] = inf;  // 頂点数2\n  }\n  for (int bit = 3; bit < 1 << n_A; ++bit) {\n    if (bitcount(bit) <= 1)\n      continue;\n    for (int i = 0; i < n_A; ++i) {\n      ans_partial_A[bit | (1 << i)] |= ans_partial_A[bit];\n    }\n  }\n\n  // groupA の部分集合の解を全列挙\n  // ここでは groupA と groupB のカットエッジの被覆は考えない．\n  for (int bit = 1; bit < 1 << n_A; ++bit) {\n    for (int i = 0; i < n_A; ++i) {\n      if (bit & (1 << i))\n        continue;\n      ans_partial_A[bit | (1 << i)] = min(ans_partial_A[bit | (1 << i)], ans_partial_A[bit] + 1);\n    }\n  }\n\n  // dp[S] Sは独立集合ではない\n  vector<bool> not_independent_B(1 << n_B, 0);\n  for (int _i = 0; _i < n_B; ++_i) {\n    int bit = 1 << _i;\n    for (int j : graph.vertex_to[n_A + _i])\n      if (n_A <= j)\n        not_independent_B[bit | (1 << (j - n_A))] = 1;\n  }\n  for (int bit = 3; bit < 1 << n_B; ++bit) {\n    if (bitcount(bit) <= 1)\n      continue;\n    for (int _i = 0; _i < n_B; ++_i) {\n      not_independent_B[bit | (1 << _i)] =\n          not_independent_B[bit | (1 << _i)] | not_independent_B[bit];\n    }\n  }\n\n  // dp[S] Sに隣接する頂点のbit配列\n  vector<int> adjacent2B(1 << n_B, 0);\n  for (int _i = 0; _i < n_B; ++_i) {\n    int bit = 0;\n    for (int j : graph.vertex_to[n_A + _i])\n      if (j < n_A)\n        bit |= 1 << j;\n    adjacent2B[1 << _i] = bit;\n  }\n  for (int bit = 1; bit < 1 << n_B; ++bit) {\n    for (int _i = 0; _i < n_B; ++_i) {\n      adjacent2B[bit | (1 << _i)] |= adjacent2B[bit];\n    }\n  }\n\n  // answer\n  int best = inf;\n  pair<int, int> vtx_selection;\n\n  // groupB の部分集合を全列挙\n  for (int bit = 0; bit < 1 << n_B; ++bit) {\n    // choice_Bが頂点被覆でないなら，reject\n    if (not_independent_B[((1 << n_B) - 1) ^ bit])\n      continue;\n\n    int mask_A = (1 << n_A) - 1;\n    int fix_A = 0;\n\n    int adj = adjacent2B[((1 << n_B) - 1) ^ bit];\n    for (int i = 0; i < n_A; ++i) {\n      // choice_B で選んでいない頂点が，groupAと隣接するならば\n      if (adj & (1 << i)) {\n        // そのgroupAの頂点は必ず選択する．\n        mask_A ^= 1 << i;  // 頂点jは考慮しなくてよい\n        ++fix_A;           // 必ず選択することにしたので\n      }\n    }\n\n    int score = ans_partial_A[mask_A] + bitcount(bit) + fix_A;\n    if (score < best) {\n      best = score;\n      vtx_selection.first = mask_A;\n      vtx_selection.second = bit;\n    }\n  }\n\n  // 選んだ頂点の復元\n  vector<int> selection;\n  for (int i = 0; i < n_B; ++i) {\n    if (vtx_selection.second & (1 << i))\n      selection.push_back(n_A + i);\n  }\n  for (int i = 0; i < n_A; ++i) {\n    if ((vtx_selection.first & (1 << i)) == 0)\n      selection.push_back(i);\n  }\n  {\n    int m = vtx_selection.first;\n    int curr = ans_partial_A[m];\n    while (m > 0) {\n      int bi;\n      for (int i = 0; i < n_A; ++i) {\n        if ((m & (1 << i)) == 0)\n          continue;\n        int a = ans_partial_A[m ^ (1 << i)];\n        if (curr == a) {\n          bi = -1;\n          m ^= (1 << i);\n          break;\n        } else if (curr - 1 == a) {\n          bi = i;\n        }\n      }\n      if (bi >= 0) {\n        m ^= (1 << bi);\n        selection.push_back(bi);\n        --curr;\n      }\n    }\n  }\n  sort(selection.begin(), selection.end());\n  selection.shrink_to_fit();\n\n  return make_pair(best, selection);\n}","path":"/src/cpp/graph/method/vertexcover.hpp","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"強連結成分分解","overview":"機能豊富すぎるSCCクラス\n機能豊富すぎるので、例えば2satはこのスニペットには依存しない\n[TODO] validation\nよく使っているので問題ないとは思いますが…","usage":"","require":"#include <vector>\n#include <stack>\n#include <functional>\n#include \"src/cpp/graph/datastructure/dgraph.hpp\"\n#include \"src/cpp/graph/datastructure/unionfind.hpp\"","verified":[],"words":["scc"],"code":"class SCComps {\n public:\n  // sccが1頂点に纏められたグラフ\n  DGraph sccg;\n  // 元の頂点番号からscc後の頂点番号を求める\n  vector<int> ori2scc;\n  // scc後の頂点番号から元の頂点番号を求める\n  vector<vector<int>> scc2ori;\n\n private:\n  int strongly_connected_components(const DGraph& graph, Unionfind& result) {\n    stack<int> stk;\n    vector<int> num(graph.size()), low(graph.size()), flg(graph.size());\n    int cnt = 0;\n    int n_components = graph.n;\n\n    function<void(int)> dfs = [&](int idx) {\n      low[idx] = num[idx] = ++cnt;\n      stk.push(idx);\n      flg[idx] = true;\n\n      for (int to : graph.vertex_to[idx]) {\n        if (num[to] == 0) {\n          dfs(to);\n          low[idx] = min(low[idx], low[to]);\n        } else if (flg[to]) {  // ?\n          low[idx] = min(low[idx], num[to]);\n        }\n      }\n      if (low[idx] == num[idx]) {\n        while (!stk.empty()) {\n          int v = stk.top();\n          stk.pop();\n          flg[v] = false;\n          if (idx == v)\n            break;\n          n_components -= result.connect(idx, v);\n        }\n      }\n    };\n    for (int i = 0; i < graph.size(); ++i) {\n      if (num[i] == 0)\n        dfs(i);\n    }\n    return n_components;\n  }\n\n public:\n  void build(const DGraph& orig) {\n    Unionfind uf(orig.size());\n    strongly_connected_components(orig, uf);\n\n    int n = 0;\n    for (int i = 0; i < orig.size(); ++i) {\n      int r = uf.root(i);\n      if (ori2scc[r] == -1) {\n        ori2scc[r] = n++;\n        scc2ori.emplace_back();\n      }\n      ori2scc[i] = ori2scc[r];\n      scc2ori[ori2scc[i]].push_back(i);\n    }\n    sccg.resize(n);\n\n    for (int i = 0; i < orig.size(); ++i) {\n      for (int to : orig.vertex_to[i]) {\n        if (ori2scc[i] == ori2scc[to])\n          continue;\n        sccg.connect(ori2scc[i], ori2scc[to]);\n      }\n    }\n  }\n\n  inline const vector<int>& vertex_to(int v) const { return sccg.vertex_to[v]; }\n  inline const vector<int>& vertex_from(int v) const { return sccg.vertex_from[v]; }\n  inline int size() const { return sccg.n; }\n\n  SCComps(const DGraph& g) : sccg(1), ori2scc(g.size(), -1) { build(g); }\n};","path":"/src/cpp/graph/method/connectedcomponent/scc.hpp","references":[],"commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"幾何(点と線と円)","overview":"点と線と円に関するクラスとメソッド．\n距離と交点のみ．","usage":"","verified":["目視"],"references":["http://shogo82148.github.io/homepage/memo/geometry/circle-cross.html"],"words":["kika","vector"],"require":"","code":"class Point {\n    /**\n     * \n     * @param {number} x \n     * @param {number} y \n     */\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * \n     * @param {number} t\n     */\n    multiply(t) {\n        return new Point(t * this.x, t * this.y);\n    }\n    /**\n     * \n     * @param {Point} p \n     */\n    plus(p) {\n        return new Point(this.x + p.x, this.y + p.y);\n    }\n    /**\n     * \n     * @param {Point} p \n     */\n    minus(p) {\n        return new Point(this.x - p.x, this.y - p.y);\n    }\n    /**\n     * \n     * @param {Point} p \n     */\n    distance(p) {\n        return Math.hypot(this.x - p.x, this.y - p.y);\n    }\n    /**\n     * x*x+y*y\n     */\n    square() {\n        return this.x * this.x + this.y * this.y;\n    }\n    /**\n     * \n     * @param {Point} p \n     */\n    dot(p) {\n        return this.x * p.x + this.y * p.y;\n    }\n    /**\n     * \n     * @param {Point} p \n     */\n    cross(p) {\n        return this.x * p.y - p.x * this.y;\n    }\n    /**\n     * \n     * @param {Point} p \n     */\n    cos(p) {\n        return (this.x * p.x + this.y * p.y)\n            / (Math.sqrt(this.x * this.x + this.y * this.y)\n                * Math.sqrt(p.x * p.x + p.y * p.y));\n    }\n}\n\n\nclass Circle { // eslint-disable-line no-unused-vars\n    /**\n     * \n     * @param {Point} p 中心点\n     * @param {number} rad 半径\n     */\n    constructor(p, rad) {\n        this.p = p;\n        this.rad = rad;\n    }\n\n    /**\n     * 直線と円の交点\n     * 交点が存在しない場合，[null,null]\n     * @param {Line} li \n     * @returns {[Point,Point]}\n     */\n    intersectionLine(li) {\n        return li.intersectionCircle(this);\n    }\n\n    /**\n     * 円と円の交点\n     * 交点が存在しない場合，[null,null]\n     * @param {Circle} ci \n     * @returns {[Point,Point]}\n     */\n    intersectionCircle(ci) {\n        const a = (this.p.square() - ci.p.square() - this.rad * this.rad + ci.rad * ci.rad) / 2;\n        return Line.equation(this.p.x - ci.p.x, this.p.y - ci.p.y, -a).intersectionCircle(this);\n    }\n}\n\n\nclass Line {\n    /**\n     * pos+t*vel を満たす直線．\n     * |vel| < EPS の時，0除算が発生することがある．\n     * @param {Point} pos\n     * @param {Point} vel\n     */\n    constructor(pos, vel) {\n        this.pos = pos;\n        this.vel = vel;\n    }\n    /**\n     * p1,p2を通る直線を生成\n     * p1.distance(p2) < EPS の時，0除算が発生することがある．\n     * @param {Point} p1 \n     * @param {Point} p2 \n     */\n    static path(p1, p2) {\n        const lp = p1, lv = p2.plus(p1.multiply(-1));\n        return new Line(lp, lv);\n    }\n\n    /**\n     * ax + by + c = 0 を満たす直線を生成\n     * |a| < EPS, |b| < EPS の時，0除算が発生する．\n     * @param {number} a \n     * @param {number} b \n     * @param {number} c \n     */\n    static equation(a, b, c) {\n        if (Math.abs(a) < Math.abs(b))\n            return new Line(new Point(0, -c / b), new Point(b, -a));\n        else\n            return new Line(new Point(-c / a, 0), new Point(b, -a));\n    }\n\n    /**\n     * t をパラメータとする直線上の点 pos+t*vel を求める．\n     * @param {number} t \n     */\n    point(t) {\n        return this.pos.plus(this.vel.multiply(t));\n    }\n\n    /**\n     * 点と直線の距離\n     * 直線上で点に最寄りの座標\n     * @param {Point} p\n     * @returns {{distance: number, nearest: Point}}\n     */\n    distancePoint(p) {\n        const lp = this.pos, lv = this.vel;\n\n        const den = lv.square();\n\n        return {\n            distance: Math.abs(lv.cross(p.minus(lp))) / Math.sqrt(den),\n            nearest: this.point(lv.dot(p.minus(lp)) / den)\n        };\n    }\n\n    /**\n     * 直線と円の交点\n     * 交点が存在しない場合，[null,null]\n     * @param {Circle} ci \n     * @returns {[Point,Point]}\n     */\n    intersectionCircle(ci) {\n        const lp = this.pos, lv = this.vel;\n\n        const d = lv.x * (ci.p.y - lp.y) - lv.y * (ci.p.x - lp.x);\n        const den = lv.x * lv.x + lv.y * lv.y;\n        const det = (den) * ci.rad * ci.rad - d * d;\n        if (det < 0) return [null, null];\n\n        const num = lv.x * (ci.p.x - lp.x) + lv.y * (ci.p.y - lp.y);\n        const detsq = Math.sqrt(det);\n        return [this.point((num + detsq) / den), this.point((num - detsq) / den)];\n    }\n\n    /**\n     * 直線と直線の交点\n     * 存在しない場合はnull\n     * @param {Line} li\n     * @returns {Point} \n     */\n    intersectionLine(li) {\n        const num = -this.vel.cross(li.pos.minus(this.pos));\n        const den = this.vel.cross(li.vel);\n        if (den == 0) return null;\n        return li.point(num / den);\n    }\n\n}","path":"/src/javascript/2d/2d.js","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"組合せ・順列列挙","overview":"ジェネレータを返す．ジェネレータは，組合せ・順列を列挙する．\nruby の Array#permutation，Array#combination に似た挙動．\n高等なアルゴリズムは使わず，雑な再帰で実装．","usage":"for (let e of [1,2,3,4].combination(2)) console.log(e);","verified":[],"references":["https://qiita.com/komaji504/items/62a0f8ea43053e90555a"],"words":["shuffle"],"require":"","code":"Array.prototype.permutation = function* () {\n    if (this.length <= 0) return;\n    const n = this.length;\n    const this_ = this;\n    function* dfs(p) {\n        if (p.length == n) {\n            yield p.map(i => this_[i]);\n            return;\n        }\n        for (let i = 0; i < n; ++i) {\n            if (p.some(e => e == i)) continue;\n            p.push(i);\n            for (let r of dfs(p)) yield r;\n            p.pop();\n        }\n    }\n    for (let r of dfs([])) yield r;\n};\n\nArray.prototype.combination = function* (k) {\n    if (this.length <= 0 || (this.length < k)) return;\n    const n = this.length;\n    const this_ = this;\n    function* dfs(c, idx) {\n        if (n - idx < k - c.length) return;\n        if (idx == n) {\n            if (c.length == k)\n                yield c.map(i => this_[i]);\n            return;\n        }\n        if (k > c.length) {\n            c.push(idx);\n            for (let r of dfs(c, idx + 1)) yield r;\n            c.pop();\n        }\n        for (let r of dfs(c, idx + 1)) yield r;\n    }\n    for (let r of dfs([], 0)) yield r;\n};","path":"/src/javascript/extends/array/combperm.js","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"shuffle (Fisher窶添ates)","overview":"配列をshuffleする\n配列はコピーされず書き換えられる","usage":"[1,2,3].shuffle()","verified":[],"references":["https://qiita.com/komaji504/items/62a0f8ea43053e90555a"],"words":["shuffle"],"require":"","code":"Array.prototype.shuffle = function () {\n    for (let i = this.length - 1; i > 0; --i) {\n        let r = Math.floor(Math.random() * (i + 1));\n        let t = this[i];\n        this[i] = this[r];\n        this[r] = t;\n    }\n    return this;\n};","path":"/src/javascript/extends/array/shuffle.js","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"さいころの回転","overview":"無理やり感のある実装\n\nさいころのローカル座標軸はvecsで取得出来る．\nこれを使って，1はどの方向を向いているか？等の情報が得られる．\n\nvecsはフィールドですが，readonlyとして扱ってね．","usage":"","verified":["todo"],"references":[],"words":["dice","sai"],"require":"","code":"class Dice { // eslint-disable-line no-unused-vars\n\n    constructor() {\n        this.vecs = [\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ];\n    }\n\n    /**\n     * @param {1|-1} sign 1 or -1\n     */\n    rotateZ(sign = 1) {\n        sign = sign < 0 ? -1 : 1;\n        for (let i = 0; i < 3; ++i)\n            this.vecs[i] = [sign * this.vecs[i][1], -sign * this.vecs[i][0], this.vecs[i][2]];\n    }\n\n    /**\n     * @param {1|-1} sign 1 or -1\n     */\n    rotateY(sign = 1) {\n        sign = sign < 0 ? -1 : 1;\n        for (let i = 0; i < 3; ++i)\n            this.vecs[i] = [sign * this.vecs[i][2], this.vecs[i][1], -sign * this.vecs[i][0]];\n    }\n\n    /**\n     * @param {1|-1} sign 1 or -1\n     */\n    rotateX(sign = 1) {\n        sign = sign < 0 ? -1 : 1;\n        for (let i = 0; i < 3; ++i)\n            this.vecs[i] = [this.vecs[i][0], sign * this.vecs[i][2], -sign * this.vecs[i][1]];\n    }\n}","path":"/src/javascript/game/dice.js","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"ccw(進行方向)","overview":"二次元座標上の点を表す構造体\na -> b -> c と進むときの方向を判定する。","verified":[],"references":["http://www.prefield.com/algorithm/geometry/ccw.html"],"words":["ccw"],"code":"def ccw(a,b,c)\n  ax,ay = a\n  bx,by = by\n  cx,cy = c\n  bx -= ax\n  by -= ay\n  cx -= ax\n  cy -= ay\n  bx*cy - by*cx > 0 ?  1 : # 半時計周り\n  bx*cy - by*cx < 0 ? -1 : # 時計回り\n  bx*cx + by*cy < 0 ?  2 :       # c - a - b\n  bx*bx+by*by < cx*cx+cy*cy ? -2 # a - b - c\n                            :  0 # a - c - b\nend","path":"/src/ruby/2d/method/ccw.rb","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]},{"title":"GCD,LCM,組み合わせ計算","overview":"todo","usage":"int func(int x);\nx : input\n@ret","verified":["problem."],"references":["thanks."],"words":["math"],"require":"","code":"def pow_md(x, w, mod)\n  y = 1\n  x = x%mod\n  while 0 < w\n      y = (y*x) % mod if w.odd?\n      x = (x*x) % mod\n      w >>= 1\n  end\n  y\nend\n\n\ndef nCr_md(n, r, mod)\n  return nCr_md(n, n-r, mod) if n/2 < r\n  num,den = 1,1\n  1.upto(r) do |i|\n      num = num*(n-i+1) % mod\n      den = den*i % mod\n  end\n  num * pow_md(den, mod-2, mod) % mod\nend","path":"/src/ruby/math/method/math_utils.ruby","commits":[{"sha":"fdb05a2ea85699ae0edbdb4ee9b271b8cac4132d","date":"2020-10-12 23:39:56 +0000","message":"bugfix: git commit in workflows"}]}]
[{"title":"幾何頂点","overview":"二次元座標上の点を表す構造体","code":"struct Pt {\n  using value_t = double;\n  value_t x, y;\n  Pt(value_t _x = 0, value_t _y = 0) : x(_x), y(_y) {}\n  inline void normalize() {\n    if (x != 0 || y != 0)\n      x /= hypot(), y /= hypot();\n  }\n  inline value_t hypot() const { return std::hypot(x, y); }\n  inline value_t hypot(Pt p) const { return std::hypot(x - p.x, y - p.y); }\n  inline value_t dot(Pt p) const { return x * p.x + y * p.y; }\n  inline value_t cross(Pt p) const { return x * p.y - y * p.x; }\n  inline Pt normalized() const {\n    return x != 0 || y != 0 ? Pt(x / hypot(), y / hypot()) : Pt(0, 0);\n  }\n  inline Pt operator+(Pt p) const { return Pt(x + p.x, y + p.y); }\n  inline Pt operator-(Pt p) const { return Pt(x - p.x, y - p.y); }\n  inline Pt& operator+=(Pt p) {\n    x += p.x;\n    y += p.y;\n    return *this;\n  }\n  inline Pt& operator-=(Pt p) {\n    x -= p.x;\n    y -= p.y;\n    return *this;\n  }\n};\nPt operator*(Pt::value_t a, Pt p) {\n  return Pt(a * p.x, a * p.y);\n}","lang":"cpp","path":"/src/cpp/2d/datastructure/basic.hpp","require":"#include <cmath>\nusing namespace std;","references":[],"words":[],"verified":[],"commits":[{"sha":"c81d3aa9a6c36003093301b4cc96cb8317a6ea53","date":"2021-09-02 13:58:03 +0000","message":"refactor by Github Actions"},{"sha":"a020c95cd679421a3751a8535496ef625e5a5125","date":"2021-09-02 22:56:30 +0000","message":"avoid duplication of P"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"ccw(進行方向)","overview":"二次元座標上の点を表す構造体\na -> b -> c と進むときの方向を判定する。","code":"int ccw(Pt a, Pt b, Pt c) {\n  b.x -= a.x;\n  b.y -= a.y;\n  c.x -= a.x;\n  c.y -= a.y;\n  if (b.x * c.y - b.y * c.x > 0)\n    return +1;  // 半時計周り\n  if (b.x * c.y - b.y * c.x < 0)\n    return -1;  // 時計回り\n  if (b.x * c.x + b.y * c.y < 0)\n    return +2;  // c - a - b\n  if (b.hypot() < c.hypot())\n    return -2;  // a - b - c\n  return 0;     // a - c - b\n}","lang":"cpp","path":"/src/cpp/2d/method/ccw.hpp","require":"#include \"src/cpp/2d/datastructure/basic.hpp\"","references":["http://www.prefield.com/algorithm/geometry/ccw.html"],"words":["ccw"],"verified":[],"commits":[{"sha":"a020c95cd679421a3751a8535496ef625e5a5125","date":"2021-09-02 22:56:30 +0000","message":"avoid duplication of P"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"凸包","overview":"凸包を求める。","code":"vector<pair<Pt, int>> convex_hull(const vector<pair<Pt, int>>& points) {\n  // pointsはソート済みであること\n  const int n = points.size();\n  vector<pair<Pt, int>> ch(2 * n);\n  int k = 0;\n  for (int i = 0; i < n; ch[k] = points[i], ++k, ++i)  // lower-hull\n    while (k >= 2 && ccw(ch[k - 2].first, ch[k - 1].first, points[i].first) <= 0)\n      --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k] = points[i], ++k, --i)  // upper-hull\n    while (k >= t && ccw(ch[k - 2].first, ch[k - 1].first, points[i].first) <= 0)\n      --k;\n  ch.resize(k - 1);\n  return ch;\n}","lang":"cpp","path":"/src/cpp/2d/method/convex_hull.hpp","require":"#include <vector>\nusing namespace std;\n#include \"src/cpp/2d/datastructure/basic.hpp\"  // duplicate\n#include \"src/cpp/2d/method/ccw.hpp\"","references":["http://www.prefield.com/algorithm/geometry/convex_hull.html"],"words":["convex"],"verified":["atcoder"],"commits":[{"sha":"c81d3aa9a6c36003093301b4cc96cb8317a6ea53","date":"2021-09-02 13:58:03 +0000","message":"refactor by Github Actions"},{"sha":"a020c95cd679421a3751a8535496ef625e5a5125","date":"2021-09-02 22:56:30 +0000","message":"avoid duplication of P"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"巡回する配列","overview":"無限に長いが、途中から巡回する規則を見つけられるような\n列が存在する。A[i+1] = (A[i]*25 + 9)%101 のような。\nこのような列を容易に参照するためのデータ構造。","code":"template <typename T>\nclass CycledVector : std::vector<T> {\n  size_t nloop = 0;\n  size_t midl = 0;\n  size_t cvidx(size_t i) {\n    if (i <= midl)\n      return i;\n    return (i - midl) % nloop + midl;\n  }\n\n public:\n  CycledVector() : nloop(0), midl(0) {}\n  CycledVector(size_t n) : std::vector<T>(n), nloop(n), midl(0) {}\n  CycledVector(const std::vector<T>& v) : std::vector<T>(v), nloop(v.size()), midl(0) {}\n  CycledVector(std::vector<T>&& v) : std::vector<T>(v), nloop(v.size()), midl(0) {}\n  // 配列上のterm番目の要素とmid番目の要素と共有するような、サイクル状にする\n  void set_loop(size_t mid, size_t term) {\n    midl = mid;\n    nloop = term - mid;\n  }\n  // warning: midl/nloop is reseted.\n  void resize(size_t n) {\n    std::vector<T>::resize(n);\n    midl = 0;\n    nloop = n;\n  }\n  const T& operator[](size_t i) const { return std::vector<T>::operator[](cvidx(i)); }\n  T& operator[](size_t i) { return std::vector<T>::operator[](cvidx(i)); }\n  // 累積和の配列とみなして、先頭からiまでの総和を計算する\n  // 累積和の配列とは、A[i]がiまでの総和であるようなもので、\n  // 通常の累積和とズレている点に注意\n  // 別用途との共存の為によるもの\n  T sum_as_cum(size_t i) const {\n    if (i < midl + nloop)\n      return std::vector<T>::operator[](i);\n    T cut = T();\n    if (0 < midl)\n      cut = std::vector<T>::operator[](midl - 1);\n    T k = T(i - midl) / T(nloop);\n    size_t m = (i - midl) % nloop;\n    T block = std::vector<T>::operator[](midl + nloop - 1) - cut;\n    T cut2 = std::vector<T>::operator[](midl + m - 1) - cut;\n    return cut + block * k + cut2;\n  }\n};","lang":"cpp","path":"/src/cpp/container/array/cycledarray.hpp","require":"#include <vector>\nusing namespace std;","references":[],"words":[],"verified":["rand"],"commits":[{"sha":"ddbc85ae6cd3e8c9e911b21a19de0bd0d5a9c38c","date":"2021-02-21 23:56:23 +0000","message":"CycledArray"}],"tested_by":["test/cpp/container/array/cycledarray.cpp"]},{"title":"IntervalHeap","overview":"両端優先キュー．\nHeapの各ノードは1~2つの要素を持つ．この2つの要素は順序関係によって区間とみなすことができる．\n子⊆親を満たすようにHeapを保つことで，data_.front()には常に最小値と最大値が格納される．\n\nうーん相当無駄な実装が多いような．","code":"template <typename T>\nclass IntervalHeap {\n  using TT = pair<T, T>;  // first <= second\n\n  vector<TT> data_;  // data_の配列要素は2つの要素を持つ．data_.size() は (size_ + 1) / 2 と等価\n  int size_;  // データ構造が持つ要素の数\n\n  // data_[ptr]は1つの要素しか持っていない？\n  inline bool one(int ptr) const noexcept {\n    // ptr == 末尾 かつ 末尾を1要素しか持たない\n    return ptr == (size_ - 1) / 2 && (size_ & 1) == 1;\n  }\n\n  void fixup(int ptr) {\n    if (ptr <= 0)\n      return;\n    // ptr == 末尾 かつ 末尾を1要素しか持たない場合\n    if (one(ptr)) {\n      int parent = (ptr - 1) / 2;\n      if (data_[ptr].first < data_[parent].first)\n        swap(data_[ptr].first, data_[parent].first);  // 左端\n      else if (data_[ptr].first > data_[parent].second)\n        swap(data_[ptr].first, data_[parent].second);  // 右端\n      ptr = parent;\n    }\n    while (ptr > 0) {\n      int parent = (ptr - 1) / 2;\n      if (data_[ptr].first < data_[parent].first)\n        swap(data_[ptr].first, data_[parent].first);  // 左端\n      if (data_[ptr].second > data_[parent].second)\n        swap(data_[ptr].second, data_[parent].second);  // 右端\n      ptr = parent;\n    }\n  }\n\n  void fixdown(int ptr) {\n    // ptr == 末尾 かつ 末尾を1要素しか持たない場合\n    if (one(ptr))\n      return;\n\n    // ptrの整合\n    if (data_[ptr].first > data_[ptr].second)\n      swap(data_[ptr].first, data_[ptr].second);\n\n    int child = ptr * 2 + 1;       // 左の子のid\n    if (child >= (size_ + 1) / 2)  // 左の子が居ない\n      return;\n\n    if (child + 1 >= (size_ + 1) / 2) {  // 左の子しか居ない\n      if (data_[child].first < data_[ptr].first)\n        swap(data_[child].first, data_[ptr].first);  // 左端\n      if (!one(child) && data_[child].second > data_[ptr].second)\n        swap(data_[child].second, data_[ptr].second);  // 右端\n      // childの整合\n      if (!one(child) && data_[child].first > data_[child].second)\n        swap(data_[child].first, data_[child].second);\n      return;\n    }\n    bool leftfix = false, rightfix = false;\n    if (data_[child].first < data_[child + 1].first) {  // 左の子が右の子より小さい\n      if (data_[child].first < data_[ptr].first)\n        swap(data_[child].first, data_[ptr].first);  // 左端\n      leftfix = true;\n    } else {  // 右の子が左の子より小さい\n      if (data_[child + 1].first < data_[ptr].first)\n        swap(data_[child + 1].first, data_[ptr].first);  // 左端\n      rightfix = true;\n    }\n    if (one(child + 1) ||\n        data_[child].second >\n            data_[child + 1]\n                .second) {  // 左の子が右の子より大きい または 右の子は1要素しかもっていない\n      if (data_[child].second > data_[ptr].second)\n        swap(data_[child].second, data_[ptr].second);  // 右端\n      leftfix = true;\n    } else {  // 右の子が左の子より大きい\n      if (data_[child + 1].second > data_[ptr].second)\n        swap(data_[child + 1].second, data_[ptr].second);  // 右端\n      rightfix = true;\n    }\n    if (leftfix)\n      fixdown(child);\n    if (rightfix)\n      fixdown(child + 1);\n  }\n\n public:\n  inline IntervalHeap() : size_(0) {}\n\n  inline void reserve(size_t s) { data_.reserve(s); }\n  inline size_t size() const noexcept { return size_; }\n  inline void clear() {\n    size_ = 0;\n    data_.clear();\n  }\n\n  // TODO forward\n  void push(const T& elem) {\n    // 1. とりあえず末尾に追加\n    if ((size_ & 1) == 0) {\n      data_.emplace_back(elem, T());\n    } else {\n      data_.back().second = elem;\n      if (data_.back().first > data_.back().second)\n        swap(data_.back().first, data_.back().second);\n    }\n    ++size_;\n    // 2. 整合\n    fixup((size_ - 1) / 2);\n  }\n\n  const T& min() const { return data_.front().first; }\n\n  const T& max() const { return size_ <= 1 ? data_.front().first : data_.front().second; }\n\n  void popmin() {\n    if (size_ <= 0) {\n      //\n    } else if (size_ == 1) {\n      --size_;\n      data_.pop_back();\n    } else if (size_ == 2) {\n      --size_;\n      swap(data_.front().first, data_.front().second);\n    } else if ((size_ & 1) == 0) {\n      // 現在偶数個あり，奇数個に減る\n      // 1. 末尾と交換\n      swap(data_.front().first, data_.back().second);\n      // 2. delete\n      --size_;\n      // 3. 整合\n      fixdown(0);\n    } else {\n      // 現在奇数個あり，偶数個に減る\n      // 1. 末尾と交換\n      swap(data_.front().first, data_.back().first);\n      data_.pop_back();\n      // 2. delete\n      --size_;\n      // 3. 整合\n      fixdown(0);\n    }\n  }\n\n  void popmax() {\n    if (size_ <= 0) {\n      //\n    } else if (size_ == 1) {\n      --size_;\n      data_.pop_back();\n    } else if (size_ == 2) {\n      --size_;\n    } else if ((size_ & 1) == 0) {\n      // 現在偶数個あり，奇数個に減る\n      // 1. 末尾と交換\n      swap(data_.front().second, data_.back().second);\n      // 2. delete\n      --size_;\n      // 3. 整合\n      fixdown(0);\n    } else {\n      // 現在奇数個あり，偶数個に減る\n      // 1. 末尾と交換\n      swap(data_.front().second, data_.back().first);\n      data_.pop_back();\n      // 2. delete\n      --size_;\n      // 3. 整合\n      fixdown(0);\n    }\n  }\n};","lang":"cpp","path":"/src/cpp/container/array/intervalheap.hpp","require":"#include <vector>\nusing namespace std;","references":["https://topcoder.g.hatena.ne.jp/spaghetti_source/20121006/1349491389"],"words":[],"verified":["rand"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/container/array/intervalheap.cpp"]},{"title":"PriorityQueue","overview":"clear, reserveが欲しいだけ","code":"template <typename T>\nclass PriorityQueue {\n  vector<T> data_;\n\n public:\n  inline PriorityQueue() {}\n\n  inline bool empty() const noexcept { return data_.empty(); }\n  inline int size() const noexcept { return data_.size(); }\n  inline void reserve(int s) { data_.reserve(s); }\n  inline void clear() { data_.clear(); }\n  inline const T& top() const noexcept { return data_.front(); }\n  inline void pop() {\n    pop_heap(data_.begin(), data_.end());\n    data_.pop_back();\n  }\n  inline void push(const T& val) {\n    data_.push_back(val);\n    push_heap(data_.begin(), data_.end());\n  }\n  inline void push(T&& val) {\n    data_.push_back(move(val));\n    push_heap(data_.begin(), data_.end());\n  }\n  template <typename... Arg>\n  inline void emplace(Arg&&... args) {\n    data_.emplace_back(forward<Arg>(args)...);\n    push_heap(data_.begin(), data_.end());\n  }\n};","lang":"cpp","path":"/src/cpp/container/array/priorityqueue.hpp","require":"#include <vector>\n#include <algorithm>\nusing namespace std;","references":[],"words":[],"verified":["rand"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"RadixHeap","overview":"priority_queueに次の制約を与えたもの\n- 最後に取り出した値より小さな値を追加出来ない\n計算量はならし O(logD) (D:=max data_value) らしい","code":"template <typename T>\n// using T = int;\nclass RadixHeap {\n public:\n  using value_type = unsigned long long;\n\n private:\n  using pair_type = pair<value_type, T>;\n  value_type last_;\n  int size_;\n  int lastcnt_ = 0;\n  vector<pair_type> vec[65];\n\n  // 一番左のbitの位置\n  inline int bsr(value_type x) {\n#ifdef __GNUC__\n    return x > 0 ? 63 - __builtin_clz(x) : -1;\n#else\n    int r = -1, i = 0;\n    while (x)\n      x >>= 1, r = i++;\n    return r;\n#endif\n  }\n\n public:\n  inline RadixHeap() : last_(0), size_(0) {}\n\n  inline bool empty() const noexcept { return size_ == 0; }\n  inline int size() const noexcept { return size_; }\n\n  inline void push(value_type val, T elem) {\n    assert(last_ <= val);\n    ++size_;\n    vec[bsr(val ^ last_) + 1].emplace_back(val, elem);\n  }\n\n  inline const pair_type& top() {\n    if (!vec[0].empty())\n      return vec[0].front();\n    for (int i = 1; i < 65; ++i)\n      if (!vec[i].empty())\n        return *min_element(vec[i].begin(), vec[i].end(),\n                            [](const pair<value_type, T>& l, const pair<value_type, T>& r) {\n                              return l.first < r.first;\n                            });\n    assert(false && \"RadixHeap is empty.\");\n    return vec[0].front();\n  }\n\n  void pop() {\n    if (vec[0].empty()) {\n      for (int i = 1; i < 65; ++i) {\n        if (vec[i].empty())\n          continue;\n        last_ = min_element(vec[i].begin(), vec[i].end(),\n                            [](const pair<value_type, T>& l, const pair<value_type, T>& r) {\n                              return l.first < r.first;\n                            })\n                    ->first;\n        for (auto& p : vec[i])\n          vec[bsr(p.first ^ last_) + 1].push_back(move(p));\n        vec[i].clear();\n        break;\n      }\n    }\n\n    --size_;\n    vec[0].pop_back();\n  }\n};","lang":"cpp","path":"/src/cpp/container/array/radixheap.hpp","require":"#include <vector>\n#include <cassert>\n#include <type_traits>\n#include <algorithm>\n#include <limits>\nusing namespace std;","references":["https://www.slideshare.net/yosupo/ss-46612984"],"words":[],"verified":["todo"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"RadixHeap(simple)","overview":"priority_queueに次の制約を与えたもの\n- 最後に取り出した値より小さな値を追加出来ない\n計算量はならし O(logD) (D:=max data_value) らしい","code":"class RadixHeap {\n public:\n  using value_type = long long;\n\n private:\n  value_type last_;\n  int size_;\n  int lastcnt_ = 0;\n  vector<value_type> vec[64];\n\n  // 一番左のbitの位置\n  static inline int bsr(value_type x) noexcept {\n#ifdef __GNUC__\n    return 63 - __builtin_clz(x);  // x == 0 の時，未定義\n#else\n    int r = -1, i = 0;\n    while (x)\n      x >>= 1, r = i++;\n    return r;\n#endif\n  }\n\n public:\n  inline RadixHeap() : last_(0), size_(0) {}\n\n  inline bool empty() const noexcept { return size_ == 0; }\n  inline int size() const noexcept { return size_; }\n\n  inline void push(value_type val) {\n    assert(last_ <= val);\n    ++size_;\n    if (val == last_)\n      ++lastcnt_;\n    else\n      vec[bsr(val ^ last_)].push_back(val);\n  }\n\n  inline value_type top() {\n    if (lastcnt_)\n      return last_;\n    for (int i = 0; i < 64; ++i)\n      if (!vec[i].empty())\n        return *min_element(vec[i].begin(), vec[i].end());\n    assert(true && \"RadixHeap is empty.\");\n    return numeric_limits<value_type>::max();\n  }\n\n  void pop() {\n    if (lastcnt_ == 0) {\n      for (int i = 0; i < 64; ++i) {\n        if (vec[i].empty())\n          continue;\n        last_ = *min_element(vec[i].begin(), vec[i].end());\n        for (auto val : vec[i]) {\n          if (val == last_)\n            ++lastcnt_;\n          else\n            vec[bsr(val ^ last_)].push_back(val);\n        }\n        vec[i].clear();\n        break;\n      }\n    }\n    --size_;\n    --lastcnt_;\n  }\n};","lang":"cpp","path":"/src/cpp/container/array/radixheap_simple.hpp","require":"#include <vector>\n#include <cassert>\n#include <type_traits>\n#include <algorithm>\n#include <limits>\nusing namespace std;","references":["https://www.slideshare.net/yosupo/ss-46612984"],"words":[],"verified":["todo"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"LeftistHeap","overview":"優先度付きキューに加えて，2つのHeapを併合出来る機能を持つ．\nstd::priority_queueとは異なって，最小値が取り出される仕様に注意．\nsize()は無いので，必要ならメンバ変数を1つ加えてあれこれ．\n時間計算量は O(log_2(N))．リスト実装なので，配列実装のHeapと比べて低速かもしれない．","code":"template <typename T>\n// using T = int;\nclass LeftistHeap {\n  struct Node {\n    T value;\n    unique_ptr<Node> left, right;\n    int dist = 0;\n    inline Node(const T& _value) : value(_value) {}\n    template <typename... Args>\n    inline Node(Args&&... args) : value(args...) {}\n  };\n  static inline unique_ptr<Node>&& meldNode(unique_ptr<Node>&& heap1, unique_ptr<Node>&& heap2) {\n    if (!heap1)\n      return move(heap2);\n    if (!heap2)\n      return move(heap1);\n    if (!(heap1->value < heap2->value))\n      heap1.swap(heap2);\n    heap1->right = meldNode(move(heap1->right), move(heap2));\n    if (!heap1->left || heap1->left->dist < heap1->right->dist)\n      heap1->left.swap(heap1->right);\n    heap1->dist = heap1->right ? heap1->right->dist + 1 : 1;\n    return move(heap1);\n  }\n  unique_ptr<Node> root;\n\n public:\n  LeftistHeap() {}\n\n  inline bool empty() const { return !root; }\n  inline const T& top() const { return root->value; }\n  inline void push(const T& val) { root = meldNode(move(root), make_unique<Node>(val)); }\n  template <typename... Args>\n  inline void emplace(Args&&... args) {\n    root = meldNode(move(root), make_unique<Node>(args...));\n  }\n  inline void pop() { root = meldNode(move(root->left), move(root->right)); }\n  inline void meld(LeftistHeap&& another) { root = meldNode(move(root), move(another.root)); }\n};","lang":"cpp","path":"/src/cpp/container/balancing/leftistheap.hpp","require":"","references":["http://hos.ac/blog/#blog0001"],"words":[],"verified":["乱数"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"Treap(segment)(plain)","overview":"Treapとは，次を満たす確率的平衝二分探索木である．\n- keyについてみると，木は二分探索木になっている．\n- priority(randomized)についてみると，木はHeapになっている．\n\n実装したTreapは，配列っぽいインターフェースを持つ．split/mergeベースで記述．\n\n遅延評価を想定するので、getter には const 修飾は使われていない。\n\n区間クエリは書けそう．\n例えば『キーがx以下のNodeにyを加算する』は，treap[x]とtreap[x].childlen[0]\nに対してLazy実装で実現できる．\n\n実装ノート:\nTreap の平衡化実装と遅延評価等の区間演算実装を分離したい…\n遅延評価等の実装が一切無いクラスを TreapPlain として、Treap が TreapPlain を継承して\n機能追加したクラスとしたい。NodeFactory とか必要そう。vtable がパフォーマンスに影響する\n問題もある。","code":"class Treap {\n public:\n  using value_t = long long;\n  using rng_t = mt19937_64;\n  static rng_t rnd;\n\n  struct NodeData {\n    value_t value;\n    NodeData(value_t val) : value(val) {}\n    inline void updateBefore() {}\n    inline void updateAfter() {}\n  };\n\n protected:\n  struct Node {\n    unique_ptr<Node> childlen[2];\n    NodeData data;\n    rng_t::result_type priority;\n    int n_node;\n\n    Node(value_t v, rng_t::result_type p) : data(v), priority(p), n_node(1) {}\n\n    inline void updateBefore() { data.updateBefore(); }\n    inline void updateAfter() {\n      // recalculate number of nodes\n      n_node = 1;\n      if (childlen[0])\n        n_node += childlen[0]->n_node;\n      if (childlen[1])\n        n_node += childlen[1]->n_node;\n      data.updateAfter();\n    }\n  };\n\n  static unique_ptr<Node> createNode(value_t val) {\n    // NOTE: 乱数の1ビットを潰す理由を忘却\n    return unique_ptr<Node>(new Node(val, rnd() | 1));\n  }\n\n  unique_ptr<Node> root_;\n\n public:\n  Treap() {}\n  Treap(value_t val) : root_(createNode(val)) {}\n  Treap(Treap&& p) : root_(move(p.root_)) {}\n  void swap(Treap& p) { std::swap(root_, p.root_); }\n  int size() const { return root_ ? root_->n_node : 0; }\n\n private:\n  Treap(unique_ptr<Node>&& p) : root_(move(p)) {}\n\n  static void _concat(unique_ptr<Node>& treap1, unique_ptr<Node>& treap2) {\n    if (!treap2)\n      return;\n    if (!treap1) {\n      treap1.swap(treap2);\n      return;\n    }\n    if (treap1->priority < treap2->priority) {\n      treap1->updateBefore();\n      if (!treap1->childlen[1])\n        treap1->childlen[1] = move(treap2);\n      else\n        _concat(treap1->childlen[1], treap2);\n    } else {\n      treap2->updateBefore();\n      if (!treap2->childlen[0]) {\n        treap2->childlen[0] = move(treap1);\n        treap1.swap(treap2);\n      } else {\n        treap1.swap(treap2->childlen[0]);\n        _concat(treap2->childlen[0], treap1);\n        treap1.swap(treap2);\n      }\n    }\n    treap1->updateAfter();\n  }\n\n  // TODO: refactoring?\n  static unique_ptr<Node> _split(unique_ptr<Node>& node, int size) {\n    if (size <= 0)\n      return unique_ptr<Node>();\n    if (!node->childlen[0]) {\n      if (!node->childlen[1])\n        return move(node);\n      node->updateBefore();\n      unique_ptr<Node> cutted = move(node);\n      node = move(cutted->childlen[1]);\n      cutted->childlen[1] = move(_split(node, size - 1));\n      cutted->updateAfter();\n      node->updateAfter();\n      return cutted;\n    }\n    if (node->childlen[0]->n_node > size) {\n      unique_ptr<Node> res = _split(node->childlen[0], size);\n      node->updateAfter();\n      return res;\n    } else if (node->childlen[0]->n_node < size) {\n      node->updateBefore();\n      unique_ptr<Node> cutted = move(node);\n      node = move(cutted->childlen[1]);\n      cutted->childlen[1] = move(_split(node, size - cutted->childlen[0]->n_node - 1));\n      cutted->updateAfter();\n      node->updateAfter();\n      return cutted;\n    } else {\n      unique_ptr<Node> res = move(node->childlen[0]);\n      node->updateAfter();\n      return res;\n    }\n  }\n\n  static unique_ptr<Node>& _find(unique_ptr<Node>& node, int index) {\n    if (!node)\n      return node;\n    node->updateBefore();\n    if (!node->childlen[0])\n      return 0 < index    ? _find(node->childlen[1], index - 1)\n             : index == 0 ? node\n                          : node->childlen[0];\n    if (node->childlen[0]->n_node < index)\n      return _find(node->childlen[1], index - node->childlen[0]->n_node - 1);\n    if (node->childlen[0]->n_node > index)\n      return _find(node->childlen[0], index);\n    return node;\n  }\n\n public:\n  // anotherをthisの後ろにmergeする\n  inline void concat(Treap& another) { _concat(root_, another.root_); }\n  inline void concat(Treap&& another) { _concat(root_, another.root_); }\n\n  // 左からsize個切り取る\n  inline Treap split(int size) {\n    if (!root_)\n      return Treap();\n    if (root_->n_node <= size) {\n      return move(root_);\n    }\n    unique_ptr<Node> res = _split(root_, size);\n    root_->updateAfter();\n    return res;\n  }\n\n  // 左からi番目のnodeを取得する\n  // 存在しないなら空のunique_ptrの参照が返る\n  // inline unique_ptr<Node>& find(int index) { return _find(root_, index); }\n  // 安全でない\n  inline value_t& operator[](int index) { return _find(root_, index)->data.value; }\n\n  // 左からidx番目のnodeを削除する\n  inline void erase(int index) {\n    if (index < 0 && root_->n_node <= index)\n      return;\n    Treap tmp = split(index);\n    split(1);\n    swap(tmp);\n    concat(tmp);\n  }\n\n  // i番目の要素の前にvalを挿入する\n  inline void insert(int index, value_t val) {\n    Treap tmp = split(index);\n    tmp.concat(Treap(val));\n    tmp.concat(*this);\n    swap(tmp);\n  }\n\n private:\n  static unique_ptr<Node> create_dfs(int req_size,\n                                     const value_t& val,\n                                     const vector<rng_t::result_type>& rr,\n                                     int idx1) {\n    if (idx1 > req_size)\n      return unique_ptr<Node>();\n    unique_ptr<Node> node(new Node(val, rr[idx1 - 1]));\n    node->updateBefore();\n    node->childlen[0] = create_dfs(req_size, val, rr, idx1 * 2);\n    node->childlen[1] = create_dfs(req_size, val, rr, idx1 * 2 + 1);\n    node->updateAfter();\n    return node;\n  }\n\n  // size要素から成るvalで初期化されたTreapを生成する\n  // 乱数生成時のソートがボトルネックで，O(NlogN)時間\n public:\n  static Treap create(int size, value_t val) {\n    vector<rng_t::result_type> rr(size);\n    for (auto& x : rr)\n      x = rnd();\n    sort(rr.begin(), rr.end());\n\n    return create_dfs(size, val, rr, 1);\n  }\n\n private:\n  void printTour_dfs(ostream& o, unique_ptr<Node>& node) {\n    if (!node) {\n      o << \"NIL \";\n      return;\n    }\n    o << \"L[\" << node->data.value << \"] \";\n    printTour_dfs(o, node->childlen[0]);\n    o << \"C[\" << node->data.value << \"] \";\n    printTour_dfs(o, node->childlen[1]);\n    o << \"R[\" << node->data.value << \"] \";\n  }\n\n public:\n  inline void printTour(ostream& o) { printTour_dfs(o, root_); }\n\n private:\n  void toVector_dfs(unique_ptr<Node>& node, vector<value_t>& out) {\n    if (!node)\n      return;\n    toVector_dfs(node->childlen[0], out);\n    out.push_back(node->data.value);\n    toVector_dfs(node->childlen[1], out);\n  }\n\n public:\n  inline vector<value_t> toVector() {\n    vector<value_t> out;\n    toVector_dfs(root_, out);\n    return out;\n  }\n\n  //\n\n  void setValue(int index, value_t value) {\n    auto& node = _find(root_, index);\n    if (!node)\n      return;\n    // TODO: updateAfter is not fired\n    node->data.value = value;\n  }\n};\nTreap::rng_t Treap::rnd = Treap::rng_t();","lang":"cpp","path":"/src/cpp/container/balancing/treap_segment.hpp","require":"#include <ostream>\n#include <memory>\n#include <algorithm>\n#include <random>\n#include <functional>\nusing namespace std;","references":["https://www.slideshare.net/iwiwi/2-12188757","http://www.prefield.com/algorithm/container/treap.html"],"words":[],"verified":[],"commits":[{"sha":"89b6b28cb7b64dcc9fe511981f6540179d47f400","date":"2022-11-14 02:34:51 +0000","message":"Fix build error"},{"sha":"fb616bf63eb6aaf7aefb1b8c220f5ce4695ac4d5","date":"2021-09-19 02:03:12 +0000","message":"refactor treap"},{"sha":"a50b0710696c3e5ad0248e83bb71bee90bef64c5","date":"2020-07-29 13:01:52 +0000","message":"refactor by Github Actions"},{"sha":"cf7b674ed255c45c1acbd50ab5df3f464ab53ca0","date":"2020-06-27 18:12:41 +0000","message":"refactor by Github Actions"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/container/balancing/treap_segment.cpp"]},{"title":"Treap(set)","overview":"Treapとは，次を満たす確率的平衝二分探索木である．\n- keyについてみると，木は二分探索木になっている．\n- priority(randomized)についてみると，木はHeapになっている．\n\n実装したTreapは，map(set)のような機能を持つだけ．\nsplit/mergeも出来ない．\n\n\nkeyはユニーク＆これ以上Nodeを追加しないという条件を加えれば区間クエリは書けそう．\n例えば『キーがx以下のNodeにyを加算する』は，treap[x]とtreap[x].childlen[0]に対してLazy実装で実現できる．","code":"class Treap {\n public:\n  using key_type = int;\n  using value_type = long long;\n\n private:\n  using randevice_type = mt19937;\n\n  static randevice_type rnd;\n\n private:\n  struct Node {\n    key_type key;\n    value_type value;\n    unique_ptr<Node> childlen[2];\n    randevice_type::result_type priority;\n\n    Node(const key_type& k = key_type(), const value_type& v = value_type())\n        : key(k), value(v), priority(rnd() | 1) {}\n    Node(key_type k, value_type v, randevice_type::result_type p) : key(k), value(v), priority(p) {}\n\n    // inline Node& operator[](size_t i) { return *childlen[i & 1]; }\n    // inline bool has(size_t i) { return (bool)childlen[i & 1]; }\n  };\n\n private:\n  unique_ptr<Node> root;\n\n public:\n  Treap() {}\n  Treap(Node* p) : root(p) {}\n\n private:\n  // base.childlen[swap_for]がbaseの位置に来るように回転させる．\n  static void _rotate(unique_ptr<Node>& base, size_t swap_for) {\n    swap_for &= 1;\n    unique_ptr<Node> swf = move(base->childlen[swap_for]);\n    base->childlen[swap_for] = move(swf->childlen[swap_for ^ 1]);\n    swf->childlen[swap_for ^ 1] = move(base);\n    base = move(swf);\n  }\n\n  // thisをrootとする部分木にkをkeyとするNodeが無ければ作る，あれば返す．\n  static inline Node& _touch(unique_ptr<Node>& node, key_type k) {\n    if (k == node->key)\n      return *node;\n    size_t i = node->key < k;\n    if (node->childlen[i]) {\n      auto& r = _touch(node->childlen[i], k);\n      if (node->priority > node->childlen[i]->priority)\n        _rotate(node, i);\n      return r;\n    } else {\n      node->childlen[i].reset(new Node(k));\n      return *(node->childlen[i]);\n    }\n  }\n\n  // keyが等しいnodeを探す(const)\n  static const unique_ptr<Node>& _find(const unique_ptr<Node>& ptr, key_type key) {\n    return (!ptr || ptr->key == key) ? ptr : _find(ptr->childlen[ptr->key < key], key);\n  }\n  // keyが等しいnodeを探す\n  static unique_ptr<Node>& _find(unique_ptr<Node>& ptr, key_type key) {\n    return (!ptr || ptr->key == key) ? ptr : _find(ptr->childlen[ptr->key < key], key);\n  }\n\n  // ptrを削除する．\n  static void _erase(unique_ptr<Node>& ptr) {\n    if (!ptr->childlen[0] && !ptr->childlen[1]) {\n      ptr.release();\n    } else {\n      bool i = ptr->childlen[0]\n                   ? 0\n                   : ptr->childlen[1] ? 1 : ptr->childlen[0]->priority > ptr->childlen[1]->priority;\n      _rotate(ptr, i);\n      _erase(ptr->childlen[i ^ 1]);\n    }\n  }\n\n public:\n  // map[]と同じ\n  value_type& operator[](key_type key) {\n    if (!(root)) {\n      root.reset(new Node());\n      return root->value;\n    } else {\n      return _touch(root, key).value;\n    }\n  }\n\n  // keyが等しいnodeを探す\n  // 存在しないなら空のunique_ptrの参照が返る\n  inline const unique_ptr<Node>& find(key_type key) const { return _find(root, key); }\n\n  // keyを持つnodeを削除する\n  inline void erase(key_type key) {\n    unique_ptr<Node>& node = _find(root, key);\n    if (node)\n      _erase(node);\n  }\n};\nTreap::randevice_type Treap::rnd = randevice_type();","lang":"cpp","path":"/src/cpp/container/balancing/treap_set.hpp","require":"#include <memory>\n#include <algorithm>\n#include <random>\n#include <functional>\nusing namespace std;","references":["https://www.slideshare.net/iwiwi/2-12188757","http://www.prefield.com/algorithm/container/treap.html"],"words":[],"verified":[],"commits":[{"sha":"a50b0710696c3e5ad0248e83bb71bee90bef64c5","date":"2020-07-29 13:01:52 +0000","message":"refactor by Github Actions"},{"sha":"cf7b674ed255c45c1acbd50ab5df3f464ab53ca0","date":"2020-06-27 18:12:41 +0000","message":"refactor by Github Actions"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/container/balancing/treap_set.cpp"]},{"title":"可変長bitset","overview":"乱数で雑に性能評価したがあんまり速度差が無い(環境によって若干速い・遅い)\nvector<bool> がバグる環境用","code":"class BitSet64 {\n public:\n  using allocator_type = std::allocator<uint64_t>;\n\n private:\n  allocator_type alloc_;\n  int nBlock_;\n  uint64_t* mem_;\n\n public:\n  inline BitSet64(int _n = 1) : nBlock_((_n + 63) >> 6) {\n    mem_ = allocator_traits<allocator_type>::allocate(alloc_, nBlock_);\n  }\n  inline BitSet64(const BitSet64& another) : nBlock_(another.nBlock_) {\n    mem_ = allocator_traits<allocator_type>::allocate(alloc_, nBlock_);\n    std::copy(another.mem_, another.mem_ + nBlock_, mem_);\n  }\n  inline BitSet64(BitSet64&& another)\n      : alloc_(another.alloc_), nBlock_(another.nBlock_), mem_(another.mem_) {\n    another.mem_ = nullptr;\n  }\n  ~BitSet64() {\n    if (mem_ != nullptr) {\n      allocator_traits<allocator_type>::deallocate(alloc_, mem_, nBlock_);\n      mem_ = nullptr;\n    }\n  }\n  inline bool operator[](uint64_t index) const { return (mem_[index >> 6] >> (index & 0x3f)) & 1; }\n  inline void set(uint64_t index, bool v) {\n    if (v)\n      mem_[index >> 6] |= uint64_t(1) << (index & 0x3f);\n    else\n      mem_[index >> 6] &= ~(uint64_t(1) << (index & 0x3f));\n  }\n  inline void set(uint64_t index) { mem_[index >> 6] |= uint64_t(1) << (index & 0x3f); }\n  inline void reset(uint64_t index) { mem_[index >> 6] &= ~(uint64_t(1) << (index & 0x3f)); }\n  inline void fill(bool v) {\n    std::fill(mem_, mem_ + nBlock_, v ? numeric_limits<uint64_t>::max() : (uint64_t)0);\n  }\n  inline void resize(int newSize) {\n    newSize >>= 6;\n    uint64_t* newmem_ = allocator_traits<allocator_type>::allocate(alloc_, nBlock_);\n    std::copy(mem_, mem_ + min(newSize, nBlock_), newmem_);\n    allocator_traits<allocator_type>::deallocate(alloc_, mem_, nBlock_);\n    nBlock_ = newSize;\n  }\n};","lang":"cpp","path":"/src/cpp/container/basic/bitset.hpp","require":"#include <cstdint>\n#include <memory>\n#include <limits>\nusing namespace std;","references":[],"words":[],"verified":["resizeが出来ていない"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"Binary Indexed Tree(単独加算，区間総和)","overview":"次のクエリを処理できる．\n- １つの要素を加算・減算する．\n- 区間の要素の総和を計算する．\n1-indexedの実装に注意．\n何度も加減算を繰り返すと内部でオーバーフローを起こす可能性．","code":"template <typename T = long long>\nclass Bitree {\n  const int size_;\n  vector<T> data_;\n  static int nlz(uint32_t x) {\n    union {\n      uint32_t i;\n      float f;\n    } data;\n    data.f = (float)x + 0.5;\n    return 158 - (data.i >> 23);\n  }\n\n public:\n  Bitree(int size_) : size_(size_), data_(size_ + 1) {}\n\n  // 1..rの範囲の値の和を求める．\n  T sum(int r) const {\n    T s = 0;\n    while (r) {\n      s += data_[r];\n      r -= r & -r;  //  r&-r と書くことで最下のビットを得る\n    }\n    return s;\n  }\n  // l..rの範囲の値の和を求める\n  inline T sum(int l, int r) const { return sum(r) - sum(l - 1); }\n  // i番目の値を求める(1index)\n  T get(int i) const {\n    int j = i - 1;\n    T s = 0;\n    while (i != j) {\n      s += data_[i] - data_[j];\n      i -= i & -i;\n      j -= j & -j;\n    }\n    return s;\n  }\n  // idxの要素の値をval増やす\n  void add(int idx, T val) {\n    while (idx <= size_) {\n      data_[idx] += val;\n      idx += idx & -idx;\n    }\n  }\n  // sum(i)がvalを超える最初のiを返す\n  // get(j)<0となるjが存在すると正しく動作しない\n  int upper_bound(T val) const {\n    int li = 1 << (31 - nlz(size_));\n    int p = 0;\n    T d = 0;\n    while (li && p < size_) {\n      T k = data_[p | li];\n      if (!(val < d + k))\n        p |= li, d += k;\n      li >>= 1;\n    }\n    if (p > size_)\n      p = size_;\n    return p + 1;\n  }\n  // sum(i)がval以上である最初のiを返す\n  // get(j)<0となるjが存在すると正しく動作しない\n  int lower_bound(T val) const {\n    int li = 1 << (31 - nlz(size_));\n    int p = 0;\n    T d = 0;\n    while (li && p < size_) {\n      T k = data_[p | li];\n      if (d + k < val)\n        p |= li, d += k;\n      li >>= 1;\n    }\n    if (p > size_)\n      p = size_;\n    return p + 1;\n  }\n};","lang":"cpp","path":"/src/cpp/container/likermq/bit.hpp","require":"#include <vector>\n#include <cstdint>\nusing namespace std;","references":["プログラミングコンテストチャレンジブック"],"words":[],"verified":["二分探索が未だ出来ていない"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"Doubling (根付き木)","overview":"根付き木上でダブリングをする\n例えば、ある頂点から根に向かって k 頂点の要素の総和が計算できる\n真面目に汎化すれば、出次数が高々1のグラフに対しても出来るはずので拡張したい","code":"template <typename Trait>\nclass DoublingRootedTree {\n  Trait trait;\n  using T = typename Trait::T;\n\n  int n_, m_;\n  // データ構造のダブリング\n  vector<T> dp_;\n  // 親要素へのダブリング\n  vector<int> parent_db_;\n\n  inline T& dpAt(int i, int h) { return dp_[i * m_ + h]; }\n  inline T& parentAt(int i, int h) { return parent_db_[i * m_ + h]; }\n\n  void buildTableVertex(const vector<int>& stk) {\n    const int n = stk.size();  // TODO:\n    // set dp_;\n    for (int k = 1; k < m_; ++k) {\n      int h = 1 << (k - 1);\n      if (h < n) {\n        dpAt(stk[n - 1], k) = trait.mul(dpAt(stk[n - 1], k - 1), dpAt(stk[n - 1 - h], k - 1));\n      }\n    }\n    // set parent_db_\n    for (int k = 0; k < m_; ++k) {\n      int h = 1 << k;\n      if (h < n) {\n        parentAt(stk[n - 1], k) = stk[n - 1 - h];\n      }\n    }\n  }\n  void buildTable(const Graph& g, vector<int>& stk, int vtx, int from) {\n    stk.push_back(vtx);\n    buildTableVertex(stk);\n    for (auto to : g.vertex_to[vtx]) {\n      if (to == from)\n        continue;\n      buildTable(g, stk, to, vtx);\n    }\n    stk.pop_back();\n  }\n  void buildTable(const Graph& g, int root) {\n    vector<int> stk;\n    buildTable(g, stk, root, -1);\n  }\n\n  void init() {\n    dp_.resize(n_ * m_, trait.elem());\n    parent_db_.resize(n_ * m_);\n  }\n\n public:\n  DoublingRootedTree(int n) : n_(n) {\n    for (m_ = 0; n_ > (1 << m_); ++m_)\n      ;\n    --m_;\n    if (m_ <= 0)\n      m_ = 1;\n  }\n\n  void build(const Graph& g, int root = 0) {\n    init();\n    buildTable(g, root);\n  }\n\n  template <typename IT>\n  void build(const Graph& g, IT begin, IT end, int root = 0) {\n    init();\n    IT it = begin;\n    for (int i = 0; i < n_ && it != end; ++i, ++it) {\n      dpAt(i, 0) = *it;\n    }\n    buildTable(g, root);\n  }\n\n  template <typename F>\n  void build(const Graph& g, F init, int root = 0) {\n    init();\n    for (int i = 0; i < n_; ++i) {\n      dpAt(i, 0) = init(i);\n    }\n    buildTable(g, root);\n  }\n\n  // p1 から親方向へ d 個の要素の総和を取る。\n  T query(int p1, int d) {\n    T s = trait.elem();\n    // for (int k = m_ - 1; 0 <= k; --k) {\n    //   int h = 1 << k;\n    //   while (p1 + h <= p2) {\n    //     s = trait.mul(s, dpAt(p1, k));\n    //     p1 += h;\n    //   }\n    // }\n    return s;\n  }\n};\n\nstruct DoublingTrait {\n  using T = long long;\n  // 元を返す\n  T elem() { return 0; }\n  T mul(T s, T t) { return s + t; }\n};\n\n//\n\n//","lang":"cpp","path":"/src/cpp/container/likermq/doubling_tree.hpp","require":"#include <vector>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graph.hpp\"","references":[],"words":[],"verified":["https://atcoder.jp/contests/abc235/submissions/28783483"],"commits":[{"sha":"38f30c3190385ce1e570a1258b891ddb16d1da21","date":"2022-01-25 21:30:59 +0000","message":"add doubling"}],"tested_by":[]},{"title":"Mo's algorithm","overview":"以下の計算時間がtの時、区間クエリを時間O(tNsqrt(N))で処理できる。\n- 計算済み区間に隣接する要素1つを加えた区間の計算(add)\n- 計算済み区間の端の要素1つを削除した区間の計算(del)\n抽象クラスとして実装しているので、実装する場合はこのクラスを継承して、\nadd,delメソッドをオーバーライドする\n\n区間を結合できるような場合、セグメント木が利用できるので、そちらを使う。","code":"class MoAlgo {\n private:\n  int n_, sqn_;\n\n protected:\n  std::vector<std::pair<int, int>> ranges_;\n\n protected:\n  // solveが呼ばれた直後に呼ばれる\n  virtual void init(){};\n  // 現在の状態に要素indexを追加\n  virtual void add(int index) = 0;\n  // 現在の状態から要素indexを削除\n  virtual void del(int index) = 0;\n  // i番目のクエリと一致した段階で呼ばれる\n  virtual void query(int index) = 0;\n\n public:\n  MoAlgo(int n) : n_(n), sqn_(std::sqrt(n)) {}\n  void rangeReserve(int n) { ranges_.reserve(n); }\n  // [b, e)\n  void rangeEmplace(int b, int e) { ranges_.emplace_back(b, e); }\n  void solve() {\n    init();\n    const int q = ranges_.size();\n    std::vector<int> qi(q);\n    std::iota(qi.begin(), qi.end(), 0);\n    std::sort(qi.begin(), qi.end(), [&](int l, int r) {\n      return (ranges_[l].first / sqn_ != ranges_[r].first / sqn_)\n                 ? ranges_[l].first < ranges_[r].first\n                 : ranges_[l].second < ranges_[r].second;\n    });\n    int nl = 0, nr = 0;  // [nl,nr)\n    for (int i : qi) {\n      while (nl > ranges_[i].first)\n        --nl, add(nl);\n      while (nr < ranges_[i].second)\n        add(nr), ++nr;\n      while (nl < ranges_[i].first)\n        del(nl), ++nl;\n      while (nr > ranges_[i].second)\n        --nr, del(nr);\n      query(i);\n    }\n  }\n};","lang":"cpp","path":"/src/cpp/container/likermq/mosalgo.hpp","require":"#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <numeric>","references":["https://snuke.hatenablog.com/entry/2016/07/01/000000"],"words":[],"verified":["TODO:","https://atcoder.jp/contests/abc174/submissions/15639599"],"commits":[{"sha":"65e5639a4194552890d55c88b58b38459e14200c","date":"2020-10-22 00:36:41 +0000","message":"mo's algorithm (#71)"}],"tested_by":["test/cpp/container/likermq/mosalgo.cpp"]},{"title":"SparseTable(区間最小)","overview":"構築済みの配列に対して，次のクエリを処理できる．\n- 区間の最小値を計算する．\n0-indexedで，[begin,end)．beginを含み，endを含まない．\n何度も加減算を繰り返すと内部でオーバーフローを起こす可能性．\nO(log^2N)．最大値のみの機能なら出来そう．[TODO]","code":"template <typename T>\nclass SparseTable {\n public:\n  int size;\n  vector<int> log2;\n  vector<T> data;\n  vector<T> dp;\n\n  SparseTable(int size) : size(size), log2(size + 1), data(size) {\n    // for fast calculate log2\n    for (int i = 2; i <= size; ++i) {\n      log2[i] = log2[i >> 1] + 1;\n    }\n\n    dp.resize(size * (log2[size] + 1));\n  }\n\n  inline T& operator[](size_t i) { return data[i]; }\n  inline T operator[](size_t i) const { return data[i]; }\n\n  void build() {\n    int l, i, f, b;\n    for (i = 0; i < size; i++) {\n      dp[i] = i;\n    }\n    for (l = 1; (1 << l) <= size; l++) {\n      for (i = 0; i + (1 << l) <= size; i++) {\n        f = dp[i + size * (l - 1)];\n        b = dp[(i + (1 << (l - 1))) + size * (l - 1)];\n\n        dp[i + size * l] = (data[f] <= data[b]) ? f : b;  // minimum\n      }\n    }\n  }\n\n  // range [l,r)\n  int getminrangeIdx(int l, int r) const {\n    int lg = log2[r - l];\n    int i1 = dp[l + size * lg];\n    int i2 = dp[r - (1 << lg) + size * lg];\n    return (data[i1] <= data[i2]) ? i1 : i2;  // minimum\n  }\n};","lang":"cpp","path":"/src/cpp/container/likermq/rmq_sparsetable.hpp","require":"#include <vector>\nusing namespace std;","references":["http://tookunn.hatenablog.com/entry/2016/07/13/211148"],"words":[],"verified":["http://yukicoder.me/submissions/172470"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"遅延セグメント木(bitset風味)","overview":"次のクエリを処理できる．\n- 区間の要素をすべて1にする\n- 区間の要素をすべて0にする．\n- 1になっている区間の要素の個数を求める．\n0-indexedで，[begin,end)．beginを含み，endを含まない．\n反転クエリも書ける。","code":"struct SegmentTree {\n  struct LZ {\n    bool enable;\n    int fillval;\n  };\n  vector<int> data;\n  vector<LZ> lazy;\n  int n;\n\n  SegmentTree(int _n) {\n    n = 8;\n    while (n < _n)\n      n <<= 1;\n    data.resize(n << 1);\n    lazy.resize(n << 1);\n  }\n\n  inline void _setup_lazy(int idx, int fillval) {\n    if (idx < n) {\n      lazy[idx * 2].enable = true;\n      lazy[idx * 2].fillval = fillval;\n      lazy[idx * 2 + 1].enable = true;\n      lazy[idx * 2 + 1].fillval = fillval;\n    }\n  }\n\n  inline void _apply_lazy(int idx, int size) {\n    if (lazy[idx].enable) {\n      lazy[idx].enable = false;\n      data[idx] = size * lazy[idx].fillval;\n      if (idx < n) {\n        _setup_lazy(idx, lazy[idx].fillval);\n      }\n    }\n  }\n\n  void _set_range(int begin, int end, int idx, int left, int right) {\n    _apply_lazy(idx, right - left);\n    if (end <= left || right <= begin)\n      return;  // out of range\n    if (begin <= left && right <= end) {\n      data[idx] = right - left;\n      _setup_lazy(idx, 1);\n      return;\n    }\n    int center = (right + left) / 2;\n    _set_range(begin, end, idx * 2, left, center);\n    _set_range(begin, end, idx * 2 + 1, center, right);\n    data[idx] = data[idx * 2] + data[idx * 2 + 1];\n  }\n\n  inline void set_range(int begin, int end) { return _set_range(begin, end, 1, 0, n); }\n\n  void _reset_range(int begin, int end, int idx, int left, int right) {\n    _apply_lazy(idx, right - left);\n    if (end <= left || right <= begin)\n      return;  // out of range\n    if (begin <= left && right <= end) {\n      data[idx] = 0;\n      _setup_lazy(idx, 0);\n      return;\n    }\n    int center = (right + left) / 2;\n    _reset_range(begin, end, idx * 2, left, center);\n    _reset_range(begin, end, idx * 2 + 1, center, right);\n    data[idx] = data[idx * 2] + data[idx * 2 + 1];\n  }\n\n  inline void reset_range(int begin, int end) { return _reset_range(begin, end, 1, 0, n); }\n\n  inline int _count_range(int begin, int end, int idx, int left, int right) {\n    if (end <= left || right <= begin)\n      return 0;  // out of range\n    _apply_lazy(idx, right - left);\n    if (begin <= left && right <= end)\n      return data[idx];\n\n    int center = (right + left) / 2;\n    return _count_range(begin, end, idx * 2, left, center) +\n           _count_range(begin, end, idx * 2 + 1, center, right);\n  }\n\n  inline int count_range(int begin, int end) { return _count_range(begin, end, 1, 0, n); }\n};","lang":"cpp","path":"/src/cpp/container/likermq/segmenttree/hatopoppo.hpp","require":"#include <vector>\nusing namespace std;","references":[],"words":[],"verified":["乱数テスト"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"遅延セグメント木(bitset風味)(sparse)","overview":"次のクエリを処理できる．\n- 区間の要素をすべて1にする\n- 区間の要素をすべて0にする．\n- 1になっている区間の要素の個数を求める．\n0-indexedで，[begin,end)．beginを含み，endを含まない．\n反転クエリも書ける。","code":"struct SegmentTreeS {\n  struct Node {\n    ll val_;\n    bool lazy_ = false;\n    unique_ptr<Node> bottom[2];\n\n    Node(ll v, bool lz = false) : val_(v), lazy_(lz) {}\n\n    inline void setup_bottom() {\n      if (!bottom[0])\n        bottom[0].reset(new Node(0));\n      if (!bottom[1])\n        bottom[1].reset(new Node(0));\n    }\n\n    inline void apply_lazy() {\n      bottom[0]->lazy_ = true;\n      bottom[0]->val_ = val_ / 2;\n      bottom[1]->lazy_ = true;\n      bottom[1]->val_ = val_ / 2;\n    }\n\n    void set_range(ll begin, ll end, ll left, ll right) {\n      if (end <= left || right <= begin)\n        return;  // out of range\n      if (begin <= left && right <= end) {\n        val_ = right - left;\n        lazy_ = true;\n        return;\n      }\n      setup_bottom();\n      if (lazy_)\n        apply_lazy();\n\n      ll center = (right + left) / 2;\n      bottom[0]->set_range(begin, end, left, center);\n      bottom[1]->set_range(begin, end, center, right);\n      val_ = (bottom[0]->val_ + bottom[1]->val_);\n    }\n\n    void reset_range(ll begin, ll end, ll left, ll right) {\n      if (end <= left || right <= begin)\n        return;  // out of range\n      if (begin <= left && right <= end) {\n        val_ = right - left;\n        lazy_ = true;\n        return;\n      }\n      setup_bottom();\n      if (lazy_)\n        apply_lazy();\n\n      ll center = (right + left) / 2;\n      bottom[0]->reset_range(begin, end, left, center);\n      bottom[1]->reset_range(begin, end, center, right);\n      val_ = (bottom[0]->val_ + bottom[1]->val_);\n    }\n\n    ll count_range(ll begin, ll end, ll left, ll right) {\n      if (end <= left || right <= begin)\n        return 0;\n      if (begin <= left && right <= end)\n        return val_;\n      if (val_ == 0 || val_ == right - left)\n        return val_;\n      ll center = (right + left) / 2;\n      return bottom[0]->count_range(begin, end, left, center) +\n             bottom[1]->count_range(begin, end, center, right);\n    }\n  };\n\n  ll width;\n  Node root;\n\n  SegmentTreeS(ll w) : root(0, false) {\n    width = 8;\n    while (width < w)\n      width <<= 1;\n  }\n\n  inline void set_range(ll begin, ll end) { root.set_range(begin, end, 0, width); }\n  inline void reset_range(ll begin, ll end) { root.reset_range(begin, end, 0, width); }\n  inline ll count_range(ll begin, ll end) { return root.count_range(begin, end, 0, width); }\n};","lang":"cpp","path":"/src/cpp/container/likermq/segmenttree/hatopoppoS.hpp","require":"#include <memory>\nusing namespace std;\nusing ll = long long;","references":[],"words":[],"verified":["https://yukicoder.me/submissions/251514","速度が出てない"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"セグメント木(区間加算，区間最大，単独書換)[deprecated]","overview":"次のクエリを処理できる．\n- １つの要素を書き換える．\n- 区間の要素すべてに加算する．\n- 区間の要素の最大値を計算する．\n0-indexedで，[begin,end)．beginを含み，endを含まない．\n何度も加減算を繰り返すと内部でオーバーフローを起こす可能性．\nインデックスは size_t ではなく int で扱う．\nコピーを繰り返すため，T に指定する型はプリミティブ型か小さな構造体だと嬉しい","code":"template <typename T>\n// using T = ll;\nclass SegmentTree {\n public:\n  struct IdxVal {\n    int index;\n    T value;\n    inline IdxVal(int _i = 0, const T& _v = T()) : index(_i), value(_v) {}\n    inline void set(int i, const T& v) {\n      index = i;\n      value = v;\n    }\n    inline bool operator<(const T& t) const { return value < t; }\n    inline bool operator==(const T& t) const { return value == t; }\n    inline bool operator<(const IdxVal& iv) const {\n      return value < iv.value || (value == iv.value && index < iv.index);\n    }\n    inline bool operator==(const IdxVal& iv) const {\n      return index == iv.index && value == iv.value;\n    }\n  };\n\n  struct Node {\n    T add;\n    IdxVal max;\n  };\n\n private:\n  const int size_;\n  vector<T> leaf_data_;\n  vector<Node> node_data_;\n  T* leaf_;\n  Node* node_;\n\n  void _resize() {\n    leaf_data_.resize(size_);\n    node_data_.resize(size_ - 1);\n\n    leaf_ = &leaf_data_[0];\n    node_ = &node_data_[0] - 1;\n  }\n\n  void _init() {\n    for (int i = size_ - 1; 0 < i; --i) {\n      int c = i << 1;\n      if (size_ <= c)\n        node_[i].max.set(c - size_, leaf_[c - size_]);\n      else\n        node_[i].max = node_[c].max;\n      node_[i].add = 0;\n    }\n  }\n\n public:\n  inline void fill(T val) {\n    std::fill(leaf_data_.begin(), leaf_data_.end(), val);\n    _init();\n  }\n\n  SegmentTree(int _n)\n      : size_([](int _n) {\n          int s = 8;\n          while (s < _n)\n            s <<= 1;\n          return s;\n        }(_n)) {\n    _resize();\n    _init();\n  }\n  SegmentTree(int _n, const T& _fillVal)\n      : size_([](int _n) {\n          int s = 8;\n          while (s < _n)\n            s <<= 1;\n          return s;\n        }(_n)) {\n    _resize();\n    fill(_fillVal);\n  }\n\n  // idx の要素の値を取得する\n  inline T getValue(int index) const {\n    T sum = leaf_[index];\n    index += size_;\n    while (1 < index) {\n      index = index >> 1;  // 親へ移動\n      sum += node_[index].add;\n    }\n    return sum;\n  }\n\n  // idx の要素の値をeに書き換える\n  void setValue(int index, const T e) {\n    leaf_[index] = e;\n\n    for (int i = index + size_; 1 < i;) {\n      i >>= 1;\n      leaf_[index] -= node_[i].add;\n    }\n    // bottom nodes\n    {\n      int c1 = index >> 1 << 1;\n      int c2 = index >> 1 << 1;\n      if (leaf_[c1] < leaf_[c2])\n        node_[(index + size_) >> 1].max.set(c2, leaf_[c2]);\n      else\n        node_[(index + size_) >> 1].max.set(c1, leaf_[c1]);\n    }\n    for (int i = (index + size_) >> 1; 1 < i;) {\n      i >>= 1;\n      if (node_[i << 1].max.value < node_[(i << 1) + 1].max.value)\n        node_[i].max = node_[(i << 1) + 1].max;\n      else\n        node_[i].max = node_[i << 1].max;\n    }\n  }\n\n private:\n  void _addValueRange(int begin, int end, const T e, int ptr, int rangebegin, int rangeend) {\n    if (rangeend <= begin || end <= rangebegin)\n      return;\n    if (begin <= rangebegin && rangeend <= end) {\n      if (size_ <= ptr)\n        leaf_[ptr - size_] += e;\n      else\n        node_[ptr].add += e, node_[ptr].max.value += e;\n      return;\n    }\n\n    _addValueRange(begin, end, e, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n    _addValueRange(begin, end, e, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n    if (size_ <= ptr << 1) {\n      int i = (ptr << 1) - size_;\n      if (leaf_[i] < leaf_[i + 1])\n        node_[ptr].max.set(i + 1, leaf_[i + 1]);\n      else\n        node_[ptr].max.set(i, leaf_[i]);\n    } else {\n      if (node_[ptr << 1].max.value < node_[(ptr << 1) + 1].max.value)\n        node_[ptr].max = node_[(ptr << 1) + 1].max;\n      else\n        node_[ptr].max = node_[ptr << 1].max;\n    }\n    node_[ptr].max.value += node_[ptr].add;\n  }\n\n private:\n  IdxVal _getMaxRange(int begin, int end, int ptr, int rangebegin, int rangeend) const {\n    if (rangeend <= begin || end <= rangebegin)\n      return IdxVal(-1);\n    if (begin <= rangebegin && rangeend <= end) {\n      if (size_ <= ptr)\n        return IdxVal(rangebegin, leaf_[rangebegin]);\n      else\n        return node_[ptr].max;\n    }\n\n    auto l = _getMaxRange(begin, end, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n    auto r = _getMaxRange(begin, end, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n    if (l.index == -1)\n      return move(r);\n    if (r.index == -1)\n      return move(l);\n    return l.value < r.value ? move(r) : move(l);\n  }\n\n public:\n  // 区間[begin,end)にeを加算する\n  inline void addValueRange(int begin, int end, const T e) {\n    _addValueRange(begin, end, e, 1, 0, size_);\n  }\n\n  // 区間[begin,end)の最大値を計算する\n  inline IdxVal getMaxRange(int begin, int end) const {\n    if (end - begin <= 1)\n      return IdxVal(begin, getValue(begin));\n    return _getMaxRange(begin, end, 1, 0, size_);\n  }\n};","lang":"cpp","path":"/src/cpp/container/likermq/segmenttree/maxrange_addrange.hpp","require":"#include <vector>\nusing namespace std;","references":["プログラミングコンテストチャレンジブック","https://www.slideshare.net/kazumamikami1/ss-15160153"],"words":[],"verified":["http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208410#1 (setval, getminrange)","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208412#1 (addvalrange, getval)","https://yukicoder.me/submissions/294581 (addvalrange, getminrange)","Legacy:","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2521389#1 (setval, getminrange)","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2521434#1 (addvalrange, getval)","https://yukicoder.me/submissions/227863 (addvalrange, getminrange)"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"セグメント木","overview":"次のクエリを処理できる．時間計算量O(log_2(N))\n- 1つの要素を書き換える\n- 1つの要素に加算する\n- 1つの要素の値を求める\n- 区間の要素すべてを1つの値で埋める\n- 区間の要素すべてに加算する\n- 区間の要素の和を求める\n- 区間の要素の最大値を計算する\n0-indexedで，[begin,end)．beginを含み，endを含まない．\n空間計算量はO(4NX+NC)．X は sizeof(T)，C は sizeof(struct{int;bool;})．\n何度も加減算を繰り返すと内部でオーバーフローを起こす可能性．\nインデックスは size_t ではなく int で扱う．","code":"template <typename T>\n// using T = ll;\nclass SegmentTree {\n public:\n  struct IdxVal {\n    int index;\n    T value;\n    inline IdxVal(int _i = 0, const T& _v = T()) : index(_i), value(_v) {}\n    inline void set(int i, const T& v) {\n      index = i;\n      value = v;\n    }\n    inline bool operator<(const T& t) const { return value < t; }\n    inline bool operator==(const T& t) const { return value == t; }\n    inline bool operator<(const IdxVal& iv) const {\n      return value < iv.value || (value == iv.value && index < iv.index);\n    }\n    inline bool operator==(const IdxVal& iv) const {\n      return index == iv.index && value == iv.value;\n    }\n  };\n\n  enum struct Cmd { None, Add, Flat };\n\n  struct Node {\n    T sum, lazyValue;\n    IdxVal max;\n    Cmd lazyType;\n  };\n\n private:\n  const int size_;\n  vector<T> leaf_data_;\n  vector<Node> node_data_;\n  T* leaf_;\n  Node* node_;\n\n  void _resize() {\n    leaf_data_.resize(size_);\n    node_data_.resize(size_ - 1);\n\n    leaf_ = &leaf_data_[0];\n    node_ = &node_data_[0] - 1;\n  }\n\n  void _init() {\n    for (int i = size_ - 1; 0 < i; --i) {\n      int c = i << 1;\n      if (size_ <= c)\n        node_[i].max.set(c - size_, leaf_[c - size_]);\n      else\n        node_[i].max = node_[c].max;\n      node_[i].lazyType = Cmd::None;\n      node_[i].sum = node_[i].lazyValue = 0;\n    }\n  }\n\n public:\n  inline void fill(T val) {\n    std::fill(leaf_data_.begin(), leaf_data_.end(), val);\n    _init();\n  }\n\n  SegmentTree(int _n)\n      : size_([](int _n) {\n          int s = 8;\n          while (s < _n)\n            s <<= 1;\n          return s;\n        }(_n)) {\n    _resize();\n    _init();\n  }\n  SegmentTree(int _n, const T& _fillVal)\n      : size_([](int _n) {\n          int s = 8;\n          while (s < _n)\n            s <<= 1;\n          return s;\n        }(_n)) {\n    _resize();\n    fill(_fillVal);\n  }\n\n private:\n  // lazyを適応する(子を呼ぶ前に呼ぶ)\n  // width: ptrが担当するnodeの範囲の大きさ(ptr = 1 ならば size_)\n  inline void _applyDown(int ptr, int width) {\n    width >>= 1;\n    // if (size_ <= ptr) return;\n    if (node_[ptr].lazyType == Cmd::Add) {\n      int c = ptr << 1;\n\n      if (size_ <= c) {\n        leaf_[c - size_] += node_[ptr].lazyValue;\n        leaf_[c + 1 - size_] += node_[ptr].lazyValue;\n      } else {\n        node_[c].sum += node_[ptr].lazyValue * width;\n        node_[c].max.value += node_[ptr].lazyValue;\n        node_[c].lazyValue += node_[ptr].lazyValue;\n        if (node_[c].lazyType == Cmd::None)\n          node_[c].lazyType = Cmd::Add;\n\n        node_[c + 1].sum += node_[ptr].lazyValue * width;\n        node_[c + 1].max.value += node_[ptr].lazyValue;\n        node_[c + 1].lazyValue += node_[ptr].lazyValue;\n        if (node_[c + 1].lazyType == Cmd::None)\n          node_[c + 1].lazyType = Cmd::Add;\n      }\n\n      node_[ptr].lazyType = Cmd::None;\n      node_[ptr].lazyValue = 0;\n    } else if (node_[ptr].lazyType == Cmd::Flat) {\n      node_[ptr].lazyType = Cmd::None;\n      int c = ptr << 1;\n\n      if (size_ <= c) {\n        leaf_[c - size_] = node_[ptr].lazyValue;\n        leaf_[c + 1 - size_] = node_[ptr].lazyValue;\n      } else {\n        node_[c].sum = node_[ptr].lazyValue * width;\n        node_[c].max.value = node_[ptr].lazyValue;\n        node_[c].lazyValue = node_[ptr].lazyValue;\n        node_[c].lazyType = Cmd::Flat;\n\n        node_[c + 1].sum = node_[ptr].lazyValue * width;\n        node_[c + 1].max.value = node_[ptr].lazyValue;\n        node_[c + 1].lazyValue = node_[ptr].lazyValue;\n        node_[c + 1].lazyType = Cmd::Flat;\n      }\n\n      node_[ptr].lazyType = Cmd::None;\n      node_[ptr].lazyValue = 0;\n    }\n  }\n\n  // lazyを適応する(子を呼んだ後に呼ぶ)\n  inline void _applyUp(int ptr) {\n    if (size_ <= ptr << 1) {\n      int i = (ptr << 1) - size_;\n      if (leaf_[i] < leaf_[i + 1])\n        node_[ptr].max.set(i + 1, leaf_[i + 1]);\n      else\n        node_[ptr].max.set(i, leaf_[i]);\n      node_[ptr].sum = leaf_[i] + leaf_[i + 1];\n    } else {\n      if (node_[(ptr << 1)].max.value < node_[(ptr << 1) + 1].max.value)\n        node_[ptr].max = node_[(ptr << 1) + 1].max;\n      else\n        node_[ptr].max = node_[(ptr << 1)].max;\n      node_[ptr].sum = node_[ptr << 1].sum + node_[(ptr << 1) + 1].sum;\n    }\n  }\n\n  // _downward_applyDown(ptr1): leaf[ptr1]の値を正しくする．\n  void _downward_applyDown(int ptr1, int width = 1) {\n    if (1 < ptr1)\n      _downward_applyDown(ptr1 >> 1, width << 1);\n    _applyDown(ptr1, width);\n  }\n\n  void _setValueRange(int begin, int end, T val, int ptr, int rangebegin, int rangeend) {\n    if (rangeend <= begin || end <= rangebegin)\n      return;  // note:範囲外\n    if (begin <= rangebegin && rangeend <= end) {\n      if (size_ <= ptr) {\n        leaf_[rangebegin] = val;\n      } else {\n        node_[ptr].sum = val * (rangeend - rangebegin);\n        node_[ptr].max.value = val;\n        node_[ptr].lazyType = Cmd::Flat;\n        node_[ptr].lazyValue = val;\n      }\n      return;\n    }\n\n    _applyDown(ptr, rangeend - rangebegin);\n\n    _setValueRange(begin, end, val, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n    _setValueRange(begin, end, val, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n    _applyUp(ptr);\n  }\n\n  void _addValueRange(int begin, int end, T val, int ptr, int rangebegin, int rangeend) {\n    if (rangeend <= begin || end <= rangebegin)\n      return;  // note:範囲外\n    if (begin <= rangebegin && rangeend <= end) {\n      if (size_ <= ptr) {\n        leaf_[rangebegin] += val;\n      } else {\n        node_[ptr].sum += val * (rangeend - rangebegin);\n        node_[ptr].max.value += val;\n        node_[ptr].lazyValue += val;\n        if (node_[ptr].lazyType == Cmd::None)\n          node_[ptr].lazyType = Cmd::Add;\n      }\n      return;\n    }\n\n    _applyDown(ptr, rangeend - rangebegin);\n\n    _addValueRange(begin, end, val, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n    _addValueRange(begin, end, val, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n    _applyUp(ptr);\n  }\n\n  T _getSumRange(int begin, int end, int ptr, int rangebegin, int rangeend) {\n    if (rangeend <= begin || end <= rangebegin)\n      return 0;  // note:範囲外\n    if (begin <= rangebegin && rangeend <= end) {\n      if (size_ <= ptr)\n        return leaf_[rangebegin];\n      else\n        return node_[ptr].sum;\n    }\n\n    _applyDown(ptr, rangeend - rangebegin);\n\n    return _getSumRange(begin, end, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1) +\n           _getSumRange(begin, end, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n  }\n\n  IdxVal _getMaxRange(int begin, int end, int ptr, int rangebegin, int rangeend) {\n    if (rangeend <= begin || end <= rangebegin)\n      return IdxVal(-1);  // note:範囲外\n    if (begin <= rangebegin && rangeend <= end) {\n      if (size_ <= ptr)\n        return IdxVal(rangebegin, leaf_[rangebegin]);\n      else\n        return node_[ptr].max;\n    }\n\n    _applyDown(ptr, rangeend - rangebegin);\n\n    auto l = _getMaxRange(begin, end, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n    auto r = _getMaxRange(begin, end, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n    if (l.index == -1)\n      return move(r);\n    if (r.index == -1)\n      return move(l);\n    return l.value < r.value ? move(r) : move(l);\n  }\n\n public:\n  // [index] の値を求める\n  inline T getValue(int index) {\n    _downward_applyDown((index + size_) >> 1);\n    return leaf_[index];\n  }\n\n  // [index] の値を書き換える\n  inline void setValue(int index, T val) {\n    _downward_applyDown((index + size_) >> 1);\n    T diff = val - leaf_[index];\n    leaf_[index] = val;\n\n    for (int ptr = (index + size_); 1 < ptr;) {\n      ptr >>= 1;\n      node_[ptr].sum -= diff;\n      _applyUp(ptr);\n    }\n  }\n\n  // [index] の値に加算する\n  inline void addValue(int index, T val) {\n    _downward_applyDown((index + size_) >> 1);\n    leaf_[index] += val;\n\n    for (int ptr = (index + size_); 1 < ptr;) {\n      ptr >>= 1;\n      node_[ptr].sum += val;\n      _applyUp(ptr);\n    }\n  }\n\n  // 区間[begin,end)全てにvalをセットする\n  inline void setValueRange(int begin, int end, T val) {\n    _setValueRange(begin, end, val, 1, 0, size_);\n  }\n\n  // 区間[begin,end)に一様にvalを加算する\n  inline void addValueRange(int begin, int end, T val) {\n    _addValueRange(begin, end, val, 1, 0, size_);\n  }\n\n  // 区間[begin,end)の和を求める\n  inline T getSumRange(int begin, int end) { return _getSumRange(begin, end, 1, 0, size_); }\n\n  // 区間[begin,end)の最大値とその位置を求める\n  inline IdxVal getMaxRange(int begin, int end) { return _getMaxRange(begin, end, 1, 0, size_); }\n};","lang":"cpp","path":"/src/cpp/container/likermq/segmenttree/segmenttree.hpp","require":"#include <vector>\nusing namespace std;","references":["プログラミングコンテストチャレンジブック","https://www.slideshare.net/kazumamikami1/ss-15160153"],"words":[],"verified":["http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208770#1","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208769#1","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208768#1","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208771#1","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208772#1","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208773#1","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3208777#1"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"セグメント木(単独書き換え，区間演算)","overview":"次のクエリを処理できる．\n- １つの要素を書き換える．\n- 区間の要素全てにfunc_を適応した値を求める．\n十分な高速化が施されている．と思われる．","code":"template <typename T>\n// typedef int T;\nclass SegmentTreeQ {\n  int size_;\n  vector<T> data_;\n  const function<T(T, T)> func_;\n  const T zero_;\n\n public:\n  SegmentTreeQ(int n, function<T(T, T)> f, T z) : func_(f), zero_(z) {\n    size_ = 8;\n    while (size_ < n)\n      size_ <<= 1;\n    data_.resize(size_ * 2, zero_);\n  }\n\n  void fill(T val) { std::fill(data_.begin(), data_.end(), val); }\n\n  inline T get_val(int index) const { return data_[index + size_]; }\n\n  void set_val(int index, const T e) {\n    index += size_;\n    data_[index] = e;\n    while (1 < index) {\n      data_[index >> 1] =\n          func_(data_[index], data_[index ^ 1]);  // TODO : この部分の計算順序は正確か？\n      index >>= 1;\n    }\n  }\n\n  inline int get_range(int begin, int end) const {\n    T rl = zero_, rr = zero_;\n    begin += size_;\n    end += size_;\n    for (; begin < end; begin >>= 1, end >>= 1) {\n      if (begin & 1)\n        rl = func_(data_[begin++], rl);\n      if (end & 1)\n        rr = func_(rr, data_[--end]);\n    }\n    return func_(rl, rr);\n  }\n};","lang":"cpp","path":"/src/cpp/container/likermq/segmenttree/updrange_plain.hpp","require":"#include <vector>\n#include <functional>\nusing namespace std;","references":["http://d.hatena.ne.jp/komiyam/20131202/1385992406","http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/","https://beta.atcoder.jp/contests/dwacon2018-final-open/submissions/2049865"],"words":[],"verified":["https://beta.atcoder.jp/contests/dwacon2018-final-open/submissions/2050384"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"永続配列","overview":"通常の固定長配列の機能に加えて，undoを持つ．\nundoした操作をundo出来る．","code":"struct PersistentArray {\n  using value_t = int;\n  struct Node {\n    enum Type { UPDATE, NONE };\n    Type type;\n    int index;\n    value_t val;\n    int next_idx;\n    Node(Type t = Type::NONE, int i = 0, value_t v = 0) : type(t), index(i), val(v) {}\n  };\n\n  int n;\n  vector<Node> history;\n\n  PersistentArray(int _size) : n(_size) { history.emplace_back(Node::Type::NONE); }\n\n  inline void update(int index, value_t val) {\n    Node node = Node(Node::Type::UPDATE, val);\n    node.next_idx = history.size() - 1;\n    history.push_back(node);\n  }\n\n  inline void undo(int count) {\n    int n = history.size();\n    assert(0 <= (n - 1 - count));\n    history.push_back(history[n - 1 - count]);\n  }\n\n  inline vector<value_t> get() {\n    int it = history.size() - 1;\n\n    vector<int> wrote(n);\n    vector<value_t> res(n);\n\n    while (history[it].type != Node::Type::NONE) {\n      const Node& node = history[it];\n      if (node.type == Node::Type::UPDATE) {\n        if (!wrote[node.index]) {\n          wrote[node.index] = true;\n          res[node.index] = node.val;\n        }\n      }\n      it = history[it].next_idx;\n    }\n\n    return res;\n  }\n};","lang":"cpp","path":"/src/cpp/container/persistent/parray.hpp","require":"#include <vector>\n#include <cassert>\nusing namespace std;","references":[],"words":["persistent","stack","eizoku"],"verified":["[TODO]"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"永続スタック","overview":"通常のスタックの機能に加えて，undoを持つ．\nundoした操作をundo出来る．","code":"struct PersistentStack {\n  using value_t = int;\n  struct Node {\n    enum Type { PUSH, POP, NONE };\n    Type type;\n    value_t val;\n    int next_idx;\n    Node(Type t = PUSH, value_t v = 0) : type(t), val(v) {}\n  };\n\n  vector<Node> history;\n\n  PersistentStack() { history.emplace_back(Node::Type::NONE); }\n\n  inline void push(value_t val) {\n    Node node = Node(Node::Type::PUSH, val);\n    node.next_idx = history.size() - 1;\n    history.push_back(node);\n  }\n  inline void pop() {\n    Node node = Node(Node::Type::POP);\n    node.next_idx = history.size() - 1;\n    history.push_back(node);\n  }\n\n  inline void undo(int count) {\n    int n = history.size();\n    assert(0 <= (n - 1 - count));\n    history.push_back(history[n - 1 - count]);\n  }\n\n  inline vector<value_t> get() {\n    Node* p = &(history.back());\n\n    vector<value_t> res;\n    int popcount = 0;\n    while (p->type != Node::Type::NONE) {\n      if (p->type == Node::Type::PUSH) {\n        if (popcount > 0)\n          --popcount;\n        else\n          res.push_back(p->val);\n      } else if (p->type == Node::Type::POP) {\n        ++popcount;\n      }\n      p = &(history[p->next_idx]);\n    }\n    reverse(res.begin(), res.end());\n    return res;\n  }\n};","lang":"cpp","path":"/src/cpp/container/persistent/pstack.hpp","require":"#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;","references":["https://www.slideshare.net/qnighy/re-15443018"],"words":["persistent","stack","eizoku"],"verified":["乱数"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"有向グラフ(隣接頂点)","overview":"隣接頂点の情報を持つ．\n必要な空間計算量は |V|+2|E|","code":"class DGraph {\n public:\n  int n;\n  vector<vector<int>> vertex_to;\n  vector<vector<int>> vertex_from;\n\n  explicit DGraph(int n = 1) : n(n), vertex_to(n), vertex_from(n) {}\n\n  inline int size() const { return n; }\n  void resize(int _n) {\n    n = _n;\n    vertex_to.resize(_n);\n    vertex_from.resize(_n);\n  }\n  void connect(int from, int to) {\n    vertex_to[(int)from].emplace_back(to);\n    vertex_from[(int)to].emplace_back(from);\n  }\n};","lang":"cpp","path":"/src/cpp/graph/datastructure/dgraph.hpp","require":"#include <vector>\nusing namespace std;","references":[],"words":["graphstruct"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/graph/datastructure/wrapper/2sat.cpp"]},{"title":"有向グラフ(辺集合)","overview":"辺集合の情報を持つ．\n辺には1つの値を持たせることができる．\n必要な空間計算量は |V|+5|E|","code":"class DGraphE {\n public:\n  using W_T = int;\n  struct Arc {\n    int from, to;\n    W_T value;\n    Arc(int f = 0, int t = 0, W_T value = 0) : from(f), to(t), value(value) {}\n    inline int pair(int _v) const { return _v == to ? from : to; }\n  };\n  int n;\n  vector<vector<int>> vertex_to;\n  vector<vector<int>> vertex_from;\n  vector<Arc> arcs;\n\n  explicit DGraphE(int n = 1) : n(n), vertex_to(n), vertex_from(n) {}\n\n  inline int size() const { return n; }\n  void resize(int _n) {\n    n = _n;\n    vertex_to.resize(_n);\n    vertex_from.resize(_n);\n  }\n  void connect(int from, int to, W_T val = 0) {\n    vertex_to[(int)from].push_back((int)arcs.size());\n    vertex_from[(int)to].push_back((int)arcs.size());\n    arcs.emplace_back(from, to, val);\n  }\n};","lang":"cpp","path":"/src/cpp/graph/datastructure/dgraphe.hpp","require":"#include <vector>\nusing namespace std;","references":[],"words":["graphstruct"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"無向グラフ(隣接頂点)","overview":"隣接頂点の情報を持つ．\n必要な空間計算量は |V|+2|E|","code":"class Graph {\n public:\n  int n;\n  vector<vector<int>> vertex_to;\n\n  explicit Graph(int n = 1) : n(n), vertex_to(n) {}\n\n  inline int size() const { return n; }\n  void resize(int _n) { vertex_to.resize(n = _n); }\n  void connect(int from, int to) {\n    vertex_to[(int)from].emplace_back(to);\n    vertex_to[(int)to].emplace_back(from);\n  }\n};","lang":"cpp","path":"/src/cpp/graph/datastructure/graph.hpp","require":"#include <vector>\nusing namespace std;","references":[],"words":["graphstruct"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/graph/method/vertexcover.cpp","test/cpp/graph/method/vertexcover.cpp"]},{"title":"無向グラフ(隣接行列)","overview":"隣接行列を持つ．\n必要な空間計算量は |V|^2","code":"class Graph2d {\n public:\n  using W_T = int;\n  int n;\n  vector<W_T> matrix;\n\n  explicit Graph2d(int size) : n(size), matrix(size * size){};\n\n  inline int size() const { return n; }\n  void resize(int s) {\n    n = s;\n    matrix.resize(n * n);\n  }\n  void resize(int s, W_T val) {\n    n = s;\n    matrix.resize(n * n, val);\n  }\n\n  inline W_T& at(int y, int x) { return matrix[y * n + x]; }\n  inline W_T& operator()(int y, int x) { return matrix[y * n + x]; }\n  inline W_T at(int y, int x) const { return matrix[y * n + x]; }\n  inline W_T operator()(int y, int x) const { return matrix[y * n + x]; }\n\n  inline void connect(int u, int v, W_T dist = 1) { at(u, v) = at(v, u) = dist; }\n  inline void connect_d(int from, int to, W_T dist = 1) {  // directedEdge u->v\n    at(from, to) = dist;\n  }\n};","lang":"cpp","path":"/src/cpp/graph/datastructure/graph2d.hpp","require":"#include <vector>\nusing namespace std;","references":[],"words":["graphstruct"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"無向グラフ(辺集合)","overview":"辺集合の情報を持つ．\n辺には1つの値を持たせることができる．\n必要な空間計算量は |V|+5|E|","code":"// Edge構造体を定義する無向グラフ\nclass GraphE {\n public:\n  using W_T = int;\n  struct Edge {\n    int u, v;\n    W_T value;\n    Edge(int from = 0, int to = 0, W_T value = 0) : u(from), v(to), value(value) {}\n    inline int to(int _v) const { return _v == v ? u : v; }\n  };\n  size_t n;\n  vector<vector<int>> vertex_to;\n  vector<Edge> edges;\n\n  explicit GraphE(int n = 1) : n(n), vertex_to(n) {}\n\n  inline size_t size() const noexcept { return n; }\n  void resize(size_t _n) { vertex_to.resize(n = _n); }\n  void connect(int from, int to, W_T val = 0) {\n    vertex_to[(size_t)from].push_back((int)edges.size());\n    vertex_to[(size_t)to].push_back((int)edges.size());\n    edges.emplace_back(from, to, val);\n  }\n  void connect(vector<Edge>&& es) {\n    edges = move(es);\n    for (int i = 0; (size_t)i < edges.size(); ++i) {\n      vertex_to[edges[i].u].push_back(i);\n      vertex_to[edges[i].v].push_back(i);\n    }\n  }\n};","lang":"cpp","path":"/src/cpp/graph/datastructure/graphe.hpp","require":"#include <vector>\nusing namespace std;","references":[],"words":["graphstruct"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"有向グラフ(最大流用)","overview":"辺集合の情報を持つ．","code":"class DGraphF {\n public:\n  typedef int cap_t;\n  int n_;\n  struct Arc {\n    int from, to;\n    // 残量\n    cap_t left;\n    // 容量\n    cap_t cap;\n\n    Arc(int from = 0, int to = 0, cap_t w = 1) : from(from), to(to), left(w), cap(w) {}\n    inline bool operator<(const Arc& a) const {\n      return (left != a.left) ? left < a.left\n                              : (left < a.left) | (cap < a.cap) | (from < a.from) | (to < a.to);\n    }\n    inline bool operator==(const Arc& a) const {\n      return (from == a.from) && (to == a.to) && (left == a.left) && (cap == a.cap);\n    }\n  };\n  vector<vector<int>> vertex_to;\n  vector<vector<int>> vertex_from;\n  vector<Arc> edges;\n\n  explicit DGraphF(int n = 1) : n_(n), vertex_to(n), vertex_from(n) {}\n\n  void connect(int from, int to, cap_t left) {\n    vertex_to[(int)from].push_back((int)edges.size());  // toto\n    vertex_from[(int)to].push_back((int)edges.size());  // fromfrom\n    edges.emplace_back(from, to, left);\n  }\n\n  inline int size() const { return n_; }\n};","lang":"cpp","path":"/src/cpp/graph/datastructure/graphflow.hpp","require":"#include <vector>\nusing namespace std;","references":[],"words":["graphstruct"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/graph/method/flow/dinic.cpp"]},{"title":"Unionfind","overview":"頂点数N，辺∅のグラフがある．\nグラフに対して，辺の追加と同じ連結成分かどうかの判定を行う．int","code":"class Unionfind {\n public:\n  vector<int> data;\n  explicit Unionfind(int size) : data(size, -1) {}\n  bool connect(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x != y) {\n      if (data[y] < data[x])\n        swap(x, y);\n      data[x] += data[y];\n      data[y] = (int)x;\n    }\n    return x != y;\n  }\n  inline bool same(int x, int y) { return root(x) == root(y); }\n  inline int root(int x) { return (int)(data[x] < 0 ? x : data[x] = root(data[x])); }\n  inline int size(int x) { return -data[root(x)]; }\n};","lang":"cpp","path":"/src/cpp/graph/datastructure/unionfind.hpp","require":"#include <vector>\n#include <algorithm>\nusing namespace std;","references":[],"words":[],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"2-SAT Solver","overview":"2-SATを解く．\n強連結成分分解は内包済み．DGraphが必要．","code":"class Sat2 {\n public:\n  int n;\n  DGraph graph;\n\n  Sat2(int n) : n(n), graph(n * 2) {}\n\n private:\n  inline int _cv(int v) { return 0 < v ? (v - 1) * 2 : (-v - 1) * 2 + 1; }\n\n  vector<int> label_, postorder_;\n\n  void solveScc_dfs1(int v) {\n    if (label_[v] < 0)\n      return;\n    label_[v] = -1;\n    for (int to : graph.vertex_to[v])\n      solveScc_dfs1(to);\n    postorder_.push_back(v);\n  }\n\n  void solveScc_dfs2(int v, int rank) {\n    if (label_[v] > 0)\n      return;\n    label_[v] = rank;\n    for (int to : graph.vertex_from[v])\n      solveScc_dfs2(to, rank);\n  }\n\n public:\n  // 1 <= a <= n OR -1 >= a >= -n\n  // 正ならばx_a，負ならばNOT x_aを表現．\n  inline void push(int a, int b) {\n    assert(a != 0 && b != 0);\n    graph.connect(_cv(-a), _cv(b));\n    graph.connect(_cv(-b), _cv(a));\n  }\n\n  vector<int> solve() {\n    label_.resize(graph.n);\n    postorder_.reserve(graph.n);\n\n    for (int i = 0; i < graph.n; ++i)\n      solveScc_dfs1(i);\n    for (int i = (int)postorder_.size() - 1; 0 <= i; --i)\n      solveScc_dfs2(postorder_[i], i + 1);\n\n    vector<int> result(n);\n    for (int i = 0; i < n; ++i) {\n      if (label_[i * 2] == label_[i * 2 + 1])\n        return {};\n      result[i] = (label_[i * 2] < label_[i * 2 + 1]);\n    }\n    return result;\n  }\n};","lang":"cpp","path":"/src/cpp/graph/datastructure/wrapper/2sat.hpp","require":"#include <cassert>\n#include <vector>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/dgraph.hpp\"","references":["http://www.prefield.com/algorithm/misc/2-sat.html","プログラミングコンテストチャレンジブック"],"words":[],"verified":["https://yukicoder.me/submissions/496242"],"commits":[{"sha":"4419a2cd32b7fbe0c22f268c76eb3222c596fd14","date":"2020-06-30 19:05:57 +0000","message":"Add tests (#65)"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/graph/datastructure/wrapper/2sat.cpp"]},{"title":"LCA","overview":"根付き木が与えられたとき，準備O(NlogN)，次のクエリにO(1)で答えるアルゴリズム・データ構造．\n- 頂点u,vに共通する最も若い祖先\nLCA問題は，構築処理さえ済めば各質問をRMQの時間で解くことが出来る．\n\nループを含むグラフを与えた場合，再帰処理が終わらない可能性がある．","code":"class LCATable {\n  vector<int> visited_;\n  vector<int> visited_inv_;\n  SparseTable<int> depth_;\n\n public:\n  LCATable(const Graph& g, int root = 0) : visited_(g.n * 2), visited_inv_(g.n), depth_(g.n * 2) {\n    build(g, root);\n  }\n\n  int _tour_dfs(const Graph& g, int idx, int from = -1, int step = 0, int dep = 0) {\n    depth_[step] = dep;\n    visited_inv_[idx] = step;\n    visited_[step] = idx;\n\n    for (int to : g.vertex_to[idx]) {\n      if (to == from)\n        continue;\n      step = _tour_dfs(g, to, idx, ++step, dep + 1);\n      depth_[step] = dep;\n      visited_[step] = idx;\n    }\n    return ++step;\n  }\n\n  inline void build(const Graph& g, int root = 0) {\n    _tour_dfs(g, root);\n    depth_.build();\n  }\n\n  inline int operator()(int u, int v) {\n    return visited_inv_[u] <= visited_inv_[v]\n               ? visited_[depth_.getminrangeIdx(visited_inv_[u], visited_inv_[v])]\n               :\n               operator()(v, u);\n  }\n};","lang":"cpp","path":"/src/cpp/graph/datastructure/wrapper/lca.hpp","require":"#include <vector>\nusing namespace std;\n#include \"src/cpp/container/likermq/rmq_sparsetable.hpp\"\n#include \"src/cpp/graph/datastructure/graph.hpp\"","references":["thanks."],"words":["lca"],"verified":["problem."],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"最小流量制限付き最大フロー","overview":"最小流量制限なしソルバーを使って、最小流制限ありの問題を解く。\n\n＃ 解説 ＃\n\n面倒なので，最小流l,最大流hで頂点uから頂点vへ流れる有向辺を(u,v)[l,h]と表記する．\n\n+ s→tな最大最小流量制限付きフローG=(V,E)を考える．最大流量制限付きフローG'を作りたい．\n+ 新たに頂点S,Tを作る．\n+ (u,v)[c,c+d]がGに存在するとき，G'に(u,v)[0,d],(u,T)[0,c],(S,v)[0,c]を与える．\n+ G'に多重辺が出来ることがある．\n+ S→T,S→t,s→T,s→tの順に最大流を求める．S,Tに隣接する辺に優先して流すため．\n+ S,Tに隣接する辺が全てemptyになっていれば，条件を満たすフローが存在\n+ 流量は(u,v)+(u,T)\n\n事前に全体の流量が把握出来るならば， #137248のように,S→s,t→Tの辺を作ってS→Tを流せばよい","code":"class FlowMinMax {\n public:\n  DGraphF graph;\n  const int v_source;  // vertex of new source\n  FlowMinMax(int n) : graph(n + 2), v_source(n) {}\n\n private:\n  bool _solve_maxflow_edge(map<pair<int, int>, int>& result_edge, int i_source, int i_sink) {\n    vector<int> resflow(graph.size(), 0);\n\n    dinic(graph, resflow, v_source, v_source + 1);\n    dinic(graph, resflow, v_source, i_sink);\n    dinic(graph, resflow, i_source, v_source + 1);\n    dinic(graph, resflow, i_source, i_sink);\n\n    for (int e : graph.vertex_from[v_source + 1]) {\n      const DGraphF::Arc& a = graph.edges[e];\n      if (0 < a.left)\n        return false;\n    }\n    for (int u = 0; u < graph.size() - 2; u++) {\n      for (int ei : graph.vertex_to[u]) {            // TODO:最適化の余地あり(らしい)\n        const DGraphF::Arc& a_uv = graph.edges[ei];  // u -> v\n        if (a_uv.to >= graph.size() - 2) {\n          if (0 < a_uv.left)\n            return false;\n          continue;\n        }\n\n        const DGraphF::Arc& a_sv = graph.edges[ei + 1];  // S -> v\n        int flow;\n        if (a_uv.to != a_sv.to) {\n          flow = a_uv.cap - a_uv.left;\n        } else {\n          if (0 < a_sv.left)\n            return false;\n          flow = a_sv.cap + a_uv.cap - a_sv.left - a_uv.left;\n        }\n        if (0 < flow)\n          result_edge[make_pair(u, a_uv.to)] += flow;\n      }\n    }\n    return true;\n  }\n\n public:\n  void connect(int from, int to, int w_min, int w_max) {\n    if (w_max == w_min) {\n      graph.connect(v_source, to, w_min);\n      graph.connect(from, v_source + 1, w_min);\n    } else if (w_min == 0) {\n      graph.connect(from, to, w_max - w_min);\n    } else {\n      graph.connect(from, v_source + 1, w_min);\n      graph.connect(from, to, w_max - w_min);\n      graph.connect(v_source, to, w_min);\n    }\n  }\n\n  inline bool solve_maxflow_edge(map<pair<int, int>, int>& result_edge, int i_source, int i_sink) {\n    return _solve_maxflow_edge(result_edge, i_source, i_sink);\n  }\n};","lang":"cpp","path":"/src/cpp/graph/datastructure/wrapper/minmaxflow.hpp","require":"#include <vector>\n#include <map>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graphflow.hpp\"\n#include \"src/cpp/graph/method/flow/dinic.hpp\"","references":["http://snuke.hatenablog.com/entry/2016/07/10/043918"],"words":["maxflow","dinic"],"verified":["http://yukicoder.me/submissions/137248","http://yukicoder.me/submissions/143696"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"ProjectSelection","overview":"project p_1..p_n があり，それぞれのprojectは状態Bである．\n今，いくつかのpeojectを状態Aに移すことができる．\n- (i, r) p_iが状態Aの時，利益(損失)rを得る．\n- (i, j, q)p_iが状態Aでp_jが状態Bの時，qの損失が発生する．\n利益を最大化する．\n燃やす埋めるフローの考察の補助に使うことができる．．","code":"class ProjectSelection {\n public:\n  int n_;\n  DGraphF graph_;\n  const DGraphF::cap_t inf_ = 1e9;\n  DGraphF::cap_t potential_ = 0;\n\n  ProjectSelection(int _n) : n_(_n), graph_(_n + 2) {}\n\n  // p_iが状態Aの時，利益(損失)rを得る．\n  inline void push_revenue(int i, DGraphF::cap_t r) {\n    potential_ += max(DGraphF::cap_t(0), r);\n    if (r > 0)\n      graph_.connect(n_, i, r);\n    else if (r < 0)\n      graph_.connect(i, n_ + 1, -r);\n  }\n  // p_iが状態Aでp_jが状態Bの時，qの損失が発生する．\n  inline void push_purchase(int i, int j, DGraphF::cap_t q) { graph_.connect(i, j, q); }\n\n  DGraphF::cap_t solve() {\n    std::vector<DGraphF::cap_t> result;\n    dinic(graph_, result, n_, n_ + 1);\n    return potential_ - result[n_ + 1];\n  }\n};","lang":"cpp","path":"/src/cpp/graph/datastructure/wrapper/projectselection.hpp","require":"#include <vector>\n// #include \"src/cpp/graph/datastructure/graphflow.hpp\" // duplicate\n#include \"src/cpp/graph/method/flow/dinic.hpp\"","references":["https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem#Project_selection_problem","http://tokoharuland.hateblo.jp/entry/2017/11/12/234636"],"words":[],"verified":["verified(ARC)"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"TSP solver 2opt","overview":"2-opt 法で近似解を焼きなます。\n無向グラフのみ利用可能。逆順でも距離が変わらないもの。","code":"ll swap2opt(const F<ll>& dist, int p, int q, int pb, int qa) {\n  return dist(pb, q) + dist(p, qa) - dist(pb, p) - dist(q, qa);\n}\n\nvector<int> solveTSP2opt(const F<ll>& dist) {\n  const int N = dist.width;\n  vector<int> sequence(N);\n  iota(all(sequence), 0);\n\n  ll current_distance = dist(sequence[0], sequence[N - 1]);\n  repeat(i, N - 1) { current_distance += dist(sequence[i], sequence[i + 1]); }\n\n  clog << current_distance << endl;\n  repeat(_, 9999) {\n    // repeat(_, 100) {\n    // do not change startp\n    int a = rand(1, N - 2);\n    int b = rand(2, N - 1);\n    if (a == b)\n      b += 1;\n    if (a > b)\n      swap(a, b);\n\n    int p = sequence[a];\n    int q = sequence[b];\n    int pb = sequence[a == 0 ? N - 1 : a - 1];\n    int qa = sequence[b == N - 1 ? 0 : b + 1];\n\n    ll dd = swap2opt(dist, p, q, pb, qa);\n    if (dd < 0) {\n      if (a < b)\n        reverse(sequence.begin() + a, sequence.begin() + b + 1);\n      else\n        reverse(sequence.begin() + b, sequence.begin() + a + 1);\n      current_distance += dd;\n    }\n  }\n  return sequence;\n}","lang":"cpp","path":"/src/cpp/graph/method/2opt.hpp","require":"#include <vector>\nusing namespace std;\n#include \"src/cpp/grid/datastructure/euclid.hpp\"","references":[],"words":["tsp 2opt"],"verified":["yukicoder5007"],"commits":[{"sha":"2ff65424b95861b831cb50d56fd2be7bcc06da02","date":"2022-07-31 23:53:39 +0000","message":"2opt"}],"tested_by":[]},{"title":"関節点検出","overview":"[TODO] validation","code":"vector<int> detectArticulationPoint(const Graph& graph) {\n  vector<int> out(graph.n, 0);\n  vector<int> visited(graph.n);\n\n  int cnt = 1;\n  function<int(int)> dfs = [&](int idx) {\n    // printf(\"%d: called %d\\n\",idx,visited[idx]);\n    int p = visited[idx];\n    for (int to : graph.vertex_to[idx]) {\n      if (visited[to]) {\n        p = min(p, visited[to]);\n      } else {\n        visited[to] = ++cnt;\n        int q = dfs(to);\n        if (visited[idx] == q)\n          out[idx] = 1;\n        p = min(p, q);\n      }\n    }\n    // printf(\"%d: return %d\\n\",idx,p);\n    return p;\n  };\n  for (int root = 0; root < graph.n; ++root) {\n    if (visited[root])\n      continue;\n    visited[root] = 1;\n    int start_degree = 0;\n    for (int to : graph.vertex_to[root]) {\n      if (!visited[to]) {\n        ++start_degree;\n        visited[to] = ++cnt;\n        dfs(to);\n      }\n    }\n    if (2 <= start_degree)\n      out[root] = 1;\n  }\n  return out;\n}","lang":"cpp","path":"/src/cpp/graph/method/articulation.hpp","require":"#include <vector>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graph.hpp\"","references":[],"words":["articulation"],"verified":[],"commits":[{"sha":"72c5efff10710759997140488c89515750b5afc1","date":"2021-09-13 23:15:38 +0000","message":"support nonconnective"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"bellmanFord","overview":"bellmanFord法。\n頂点数と辺情報を引数とする。\nループする場合、空のvectorを返す。","code":"vector<DGraphE::W_T> bellmanFord(int n, const vector<DGraphE::Arc>& arcs, int start = 0) {\n  using T = DGraphE::W_T;\n  vector<T> dist(n, numeric_limits<T>::min() / 2);\n  dist[start] = 0;\n  bool running = true;\n  while (running && --n >= 0) {\n    running = false;\n    for (auto& arc : arcs) {\n      if (dist[arc.to] < dist[arc.from] + arc.value) {\n        dist[arc.to] = dist[arc.from] + arc.value;\n        running = true;\n        if (n <= 0)\n          return vector<T>();\n      }\n    }\n  }\n  return dist;\n}","lang":"cpp","path":"/src/cpp/graph/method/bellmanford.hpp","require":"#include <vector>\n#include <limits>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/dgraphe.hpp\"","references":[],"words":["bellmanford"],"verified":["https://atcoder.jp/contests/abc137/submissions/6908127"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"橋検出","overview":"","code":"// 橋を探す\n//\nvoid detect_bridge(const GraphE& graph, vector<int>& out) {\n  out.resize(graph.edges.size());\n  fill(out.begin(), out.end(), 0);\n  vector<int> visited(graph.n);\n\n  int cnt = 1;\n  function<int(int, int)> dfs = [&](int idx, int from) {\n    // printf(\"%d: called %d\\n\",idx,visited[idx]);\n    int p = visited[idx];\n    for (int ei : graph.vertex_to[idx]) {\n      if (ei == from)\n        continue;\n      auto& edge = graph.edges[ei];\n      int to = edge.to(idx);\n      if (visited[to]) {\n        p = min(p, visited[to]);\n      } else {\n        visited[to] = ++cnt;\n        int q = dfs(to, ei);\n        if (visited[idx] < q)\n          out[ei] = 1;\n        p = min(p, q);\n      }\n    }\n    // printf(\"%d: return %d\\n\",idx,p);\n    return p;\n  };\n  visited[0] = 1;\n  dfs(0, -1);\n}","lang":"cpp","path":"/src/cpp/graph/method/bridge.hpp","require":"#include <vector>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graphe.hpp\"","references":[],"words":["bridge"],"verified":["contests/abc075/submissions/1688087"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"強連結成分分解","overview":"機能豊富すぎるSCCクラス\n機能豊富すぎるので、例えば2satはこのスニペットには依存しない\n[TODO] validation\nよく使っているので問題ないとは思いますが…","code":"class SCComps {\n public:\n  // sccが1頂点に纏められたグラフ\n  DGraph sccg;\n  // 元の頂点番号からscc後の頂点番号を求める\n  vector<int> ori2scc;\n  // scc後の頂点番号から元の頂点番号を求める\n  vector<vector<int>> scc2ori;\n\n private:\n  int strongly_connected_components(const DGraph& graph, Unionfind& result) {\n    stack<int> stk;\n    vector<int> num(graph.size()), low(graph.size()), flg(graph.size());\n    int cnt = 0;\n    int n_components = graph.n;\n\n    function<void(int)> dfs = [&](int idx) {\n      low[idx] = num[idx] = ++cnt;\n      stk.push(idx);\n      flg[idx] = true;\n\n      for (int to : graph.vertex_to[idx]) {\n        if (num[to] == 0) {\n          dfs(to);\n          low[idx] = min(low[idx], low[to]);\n        } else if (flg[to]) {  // ?\n          low[idx] = min(low[idx], num[to]);\n        }\n      }\n      if (low[idx] == num[idx]) {\n        while (!stk.empty()) {\n          int v = stk.top();\n          stk.pop();\n          flg[v] = false;\n          if (idx == v)\n            break;\n          n_components -= result.connect(idx, v);\n        }\n      }\n    };\n    for (int i = 0; i < graph.size(); ++i) {\n      if (num[i] == 0)\n        dfs(i);\n    }\n    return n_components;\n  }\n\n public:\n  void build(const DGraph& orig) {\n    Unionfind uf(orig.size());\n    strongly_connected_components(orig, uf);\n\n    int n = 0;\n    for (int i = 0; i < orig.size(); ++i) {\n      int r = uf.root(i);\n      if (ori2scc[r] == -1) {\n        ori2scc[r] = n++;\n        scc2ori.emplace_back();\n      }\n      ori2scc[i] = ori2scc[r];\n      scc2ori[ori2scc[i]].push_back(i);\n    }\n    sccg.resize(n);\n\n    for (int i = 0; i < orig.size(); ++i) {\n      for (int to : orig.vertex_to[i]) {\n        if (ori2scc[i] == ori2scc[to])\n          continue;\n        sccg.connect(ori2scc[i], ori2scc[to]);\n      }\n    }\n  }\n\n  inline const vector<int>& vertex_to(int v) const { return sccg.vertex_to[v]; }\n  inline const vector<int>& vertex_from(int v) const { return sccg.vertex_from[v]; }\n  inline int size() const { return sccg.n; }\n\n  SCComps(const DGraph& g) : sccg(1), ori2scc(g.size(), -1) { build(g); }\n};","lang":"cpp","path":"/src/cpp/graph/method/connectedcomponent/scc.hpp","require":"#include <vector>\n#include <stack>\n#include <functional>\n#include \"src/cpp/graph/datastructure/dgraph.hpp\"\n#include \"src/cpp/graph/datastructure/unionfind.hpp\"","references":[],"words":["scc"],"verified":[],"commits":[{"sha":"4419a2cd32b7fbe0c22f268c76eb3222c596fd14","date":"2020-06-30 19:05:57 +0000","message":"Add tests (#65)"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"ダイクストラ法(無向・重み無し)","overview":"","code":"vector<int> dijkstra(const Graph& graph, int startIndex) {\n  vector<int> dist(graph.size(), numeric_limits<int>::max());\n\n  queue<pair<int, int>> que;  // <dist, idx>\n  que.emplace(0, startIndex);\n  dist[startIndex] = 0;\n\n  while (!que.empty()) {\n    int d = que.front().first;\n    int v = que.front().second;\n    que.pop();\n    if (dist[v] < d)\n      continue;\n\n    for (int u : graph.vertex_to[v])\n      if (d + 1 < dist[u])\n        que.emplace(dist[u] = d + 1, u);\n  }\n  return move(dist);\n}","lang":"cpp","path":"/src/cpp/graph/method/dijkstra/dijkstra.hpp","require":"#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graph.hpp\"","references":[],"words":["dijkstra"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"ダイクストラ法(有向・重み無し)","overview":"","code":"vector<int> dijkstraD(const DGraph& graph, int startIndex) {\n  vector<int> dist(graph.size(), numeric_limits<int>::max());\n\n  queue<pair<int, int>> que;  // <dist, idx>\n  que.emplace(0, startIndex);\n  dist[startIndex] = 0;\n\n  while (!que.empty()) {\n    int d = que.front().first;\n    int v = que.front().second;\n    que.pop();\n    if (dist[v] < d)\n      continue;\n\n    for (int u : graph.vertex_to[v])\n      if (d + 1 < dist[u])\n        que.emplace(dist[u] = d + 1, u);\n  }\n  return move(dist);\n}","lang":"cpp","path":"/src/cpp/graph/method/dijkstra/dijkstraD.hpp","require":"#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/dgraph.hpp\"","references":[],"words":["dijkstra"],"verified":["https://atcoder.jp/contests/abc132/submissions/6175759"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"ダイクストラ法(有向・辺重み)","overview":"","code":"vector<DGraphE::W_T> dijkstraDEdgeWeighted(const DGraphE& graph, int startIndex) {\n  using T = DGraphE::W_T;\n  vector<T> dist(graph.size(), numeric_limits<T>::max());\n\n  priority_queue<pair<T, int>> que;  // <dist, idx>\n  que.emplace(0, startIndex);\n  dist[startIndex] = 0;\n\n  while (!que.empty()) {\n    T d = -que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (dist[v] < d)\n      continue;\n\n    for (int ei : graph.vertex_to[v]) {\n      auto e = graph.arcs[ei];\n      int u = e.to;\n      if (d + e.value < dist[u]) {\n        que.emplace(-(dist[u] = d + e.value), u);\n      }\n    }\n  }\n  return move(dist);\n}","lang":"cpp","path":"/src/cpp/graph/method/dijkstra/dijkstraDWE.hpp","require":"#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/dgraphe.hpp\"","references":[],"words":["dijkstra"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"ダイクストラ法(無向・辺重み)","overview":"","code":"vector<GraphE::W_T> dijkstraEdgeWeighted(const GraphE& graph, int startIndex) {\n  using T = GraphE::W_T;\n  vector<T> dist(graph.size(), numeric_limits<T>::max());\n\n  priority_queue<pair<T, int>> que;  // <dist, idx>\n  que.emplace(0, startIndex);\n  dist[startIndex] = 0;\n\n  while (!que.empty()) {\n    T d = -que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (dist[v] < d)\n      continue;\n\n    for (int ei : graph.vertex_to[v]) {\n      auto e = graph.edges[ei];\n      int u = e.to(v);\n      if (d + e.value < dist[u]) {\n        que.emplace(-(dist[u] = d + e.value), u);\n      }\n    }\n  }\n  return move(dist);\n}","lang":"cpp","path":"/src/cpp/graph/method/dijkstra/dijkstraWE.hpp","require":"#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graphe.hpp\"","references":[],"words":["dijkstra"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"ダイクストラ法(無向・頂点重み)","overview":"","code":"template <typename T, typename VECTOR>\nvector<T> dijkstraVertexWeighted(const Graph& graph, int startIndex, const VECTOR& weight) {\n  vector<T> dist(graph.size(), numeric_limits<int>::max());\n\n  priority_queue<pair<T, int>> que;  // <dist, idx>\n  que.emplace(0, startIndex);\n  dist[startIndex] = 0;\n\n  while (!que.empty()) {\n    T d = -que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (dist[v] < d)\n      continue;\n\n    for (int u : graph.vertex_to[v])\n      if (d + weight[u] < dist[u])\n        que.emplace(-(dist[u] = d + weight[u]), u);\n  }\n  return move(dist);\n}","lang":"cpp","path":"/src/cpp/graph/method/dijkstra/dijkstraWV.hpp","require":"#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graph.hpp\"","references":[],"words":["dijkstra"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"SPFA","overview":"shortest path faster algorithm\n負閉路検出可能・負辺動作可能。\nベルマンフォードより速いらしい。\nただし閉路検出が遅いような気がする。","code":"vector<DGraphE::W_T> shortestPathFasterAlgorithm(const DGraphE& graph,\n                                                 int start = 0,\n                                                 bool* detectNegativeCycle = nullptr) {\n  using T = DGraphE::W_T;\n  const int n = graph.n;\n  vector<bool> incl(n);\n  vector<T> dist(n, numeric_limits<T>::max() / 2);\n  vector<int> counter;\n  if (detectNegativeCycle)\n    *detectNegativeCycle = false, counter.resize(n);\n\n  queue<int> que;\n  que.push(start);\n  incl[start] = true;\n  dist[start] = 0;\n  while (!que.empty()) {\n    int v = que.front();\n    que.pop();\n    incl[v] = false;\n    for (auto ai : graph.vertex_to[v]) {\n      auto a = graph.arcs[ai];\n\n      if (dist[a.to] <= dist[v] + a.value)\n        continue;\n      dist[a.to] = dist[v] + a.value;\n\n      if (incl[a.to])\n        continue;\n      incl[a.to] = true;\n      que.push(a.to);\n\n      if (detectNegativeCycle && ++counter[a.to] >= n) {\n        *detectNegativeCycle = true;\n        return move(dist);\n      }\n    }\n  }\n  return move(dist);\n}","lang":"cpp","path":"/src/cpp/graph/method/distance/spfa.hpp","require":"#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/dgraphe.hpp\"","references":["http://hogloid.hatenablog.com/entry/20120409/1333973448","https://tubo28.me/compprog/algorithm/spfa/"],"words":[],"verified":["https://atcoder.jp/contests/abc137/submissions/7173578"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"warshall-floyd","overview":"全ペアの最短経路を求める．\n[note] 辺が無い頂点ペアの距離はinfで埋めておくこと．","code":"void warshall_floyd(Graph2d& g) {\n  int i, j, k;\n  for (i = 0; i < g.n; i++) {\n    for (j = 0; j < g.n; j++) {\n      for (k = 0; k < g.n; k++) {\n        g(j, k) = std::min(g(j, k), g(j, i) + g(i, k));\n      }\n    }\n  }\n}","lang":"cpp","path":"/src/cpp/graph/method/distance/warshallfloyd.hpp","require":"#include <algorithm>\n#include \"src/cpp/graph/datastructure/graph2d.hpp\"","references":[],"words":[],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"オイラー路検出(テスト用)","overview":"","code":"DGraphE gen_random_eulerialTrail(int N, int M) {\n  vector<pair<int, int>> route;\n  route.reserve(M);\n  int la = 0;\n  repeat(i, M - 1) {\n    int e = rand(0, N - 1);\n    route.emplace_back(la, e);\n    la = e;\n  }\n  shuffle(route.begin(), route.end(), randdev);\n\n  vector<int> shuffler(N);\n  iota(shuffler.begin(), shuffler.end(), 0);\n  shuffle(shuffler.begin(), shuffler.end(), randdev);\n\n  DGraphE graph(N);\n  for (auto p : route)\n    graph.connect(shuffler[p.first], shuffler[p.second]);\n\n  return graph;\n}\n\nbool check_eulerialTrail(const DGraphE& graph, vector<int> trail) {\n  vector<int> chkvertex(graph.size());\n  vector<int> chkedge(graph.arcs.size());\n\n  int v = trail[0];\n\n  for (int i = 1; i < trail.size(); ++i) {\n    int t = trail[i];\n    if (i % 2 == 1) {\n      auto e = graph.arcs[t];\n      if (chkedge[t])\n        return false;\n      if (e.from != v)\n        return false;\n      v = e.to;\n    } else {\n      if (v != t)\n        return false;\n    }\n  }\n  return true;\n}","lang":"cpp","path":"/src/cpp/graph/method/euleriantrail_checker.hpp","require":"#include \"src/cpp/implements/compe.hpp\"\n#include \"src/cpp/graph/datastructure/dgraphe.hpp\"\n#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;","references":[],"words":["euler"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"オイラー路検出","overview":"要は一筆書き．\nまだ汚いのでそのうち\nTODO: fix -Wsign-compare","code":"// オイラー路が存在するかどうか\n// 存在しなかったら(-1,-1)，存在したら(始点,終点)\n// 閉路なら 始点==終点\npair<int, int> has_eulerialTrail(const DGraphE& graph) {\n  Unionfind uf(graph.size());\n\n  int vstart = -1, vgoal = -1;\n\n  for (int i = 0; i < graph.size(); ++i) {\n    if (graph.vertex_from[i].size() + 1 == graph.vertex_to[i].size()) {\n      if (vstart >= 0)\n        return make_pair(-1, -1);\n      vstart = i;\n    } else if (graph.vertex_from[i].size() == graph.vertex_to[i].size() + 1) {\n      if (vgoal >= 0)\n        return make_pair(-1, -1);\n      vgoal = i;\n    } else if (graph.vertex_from[i].size() != graph.vertex_to[i].size())\n      return make_pair(-1, -1);\n  }\n  if ((vstart == -1) != (vgoal == -1))\n    return make_pair(-1, -1);\n  for (const auto& a : graph.arcs) {\n    uf.connect(a.from, a.to);\n  }\n  if (uf.size(0) < graph.size())\n    return make_pair(-1, -1);\n\n  if (vstart == -1)\n    vgoal = vstart = 0;\n\n  return make_pair(vstart, vgoal);\n}\n\nvector<int> find_eulerialTrail(const DGraphE& graph, int startEdge = 0) {\n  using boolean = int;\n\n  // 辺集合を複数のサイクルに分割したとき，属するサイクル番号\n  vector<int> group(graph.arcs.size(), -1);\n  //\n  vector<int> prior(graph.arcs.size(), -1);\n\n  int groupCount = 0;\n\n  // ループ辺は独立した1つのサイクルとして分割\n  for (int ei = 0; ei < graph.arcs.size(); ++ei)\n    if (graph.arcs[ei].from == graph.arcs[ei].to)\n      group[ei] = groupCount++;\n\n  // 辺集合を複数のサイクルに分割\n  for (int idx_ = -1; idx_ < (int)graph.arcs.size(); ++idx_) {\n    int idx = idx_ == -1 ? startEdge : idx_;\n    if (group[idx] >= 0)\n      continue;\n\n    group[idx] = groupCount++;\n    // int tail = graph.arcs[idx].from;\n    int v = graph.arcs[idx].to;\n\n    int tim = 0;\n    prior[idx] = 0;\n\n    for (bool running = true; running;) {\n      running = false;\n      for (int ie : graph.vertex_to[v]) {\n        if (group[ie] >= 0)\n          continue;\n\n        prior[ie] = ++tim;\n        group[ie] = group[idx];\n        v = graph.arcs[ie].to;\n        running = true;\n        break;\n      }\n    }\n  }\n  vector<int> result;\n  stack<int> history;\n\n  int tail = graph.arcs[startEdge].from;\n  int curr = graph.arcs[startEdge].to;\n  history.push(group[startEdge]);\n\n  result.push_back(tail);\n  result.push_back(startEdge);\n  result.push_back(curr);\n\n  vector<boolean> encountedGroup(groupCount);\n  encountedGroup[group[startEdge]] = true;\n\n  group[startEdge] = -1;\n\n  for (int step = 1; step < graph.arcs.size(); ++step) {\n    bool prfound = false;\n    map<int, pair<int, int>> connected;  // [group] = prior, edgeid\n    for (int ie : graph.vertex_to[curr]) {\n      // 通過済みの辺\n      if (group[ie] < 0)\n        continue;\n\n      int g = group[ie];\n\n      // 通過したことが無いサイクルならば\n      if (!encountedGroup[g]) {\n        history.push(g);\n        encountedGroup[g] = true;\n\n        group[ie] = -1;\n        curr = graph.arcs[ie].to;\n        result.push_back(ie);\n        result.push_back(curr);\n\n        prfound = true;\n        break;\n      } else {\n        if (connected.count(g) == 0)\n          connected[g] = make_pair(prior[ie], ie);\n        else\n          connected[g] = min(connected[g], make_pair(prior[ie], ie));\n      }\n    }\n    if (prfound)\n      continue;\n    if (connected.empty())\n      break;\n\n    {\n      // 今通過しているサイクルを一通り巡回したならば，1つ前のサイクルに乗り換える\n      while (connected.count(history.top()) == 0) {\n        history.pop();\n        if (history.empty())\n          return result;  // assertion\n      }\n      // 1つ前のサイクルに乗り換える，辺id\n      int ie = connected[history.top()].second;\n      group[ie] = -1;\n      curr = graph.arcs[ie].to;\n\n      result.push_back(ie);\n      result.push_back(curr);\n    }\n  }\n\n  return result;\n}","lang":"cpp","path":"/src/cpp/graph/method/find_euleriantrail.hpp","require":"#include <vector>\n#include <algorithm>\n#include <stack>\n#include <map>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/unionfind.hpp\"\n#include \"src/cpp/graph/datastructure/dgraphe.hpp\"","references":["http://shonen9th.blog.fc2.com/blog-entry-147.html"],"words":["euler"],"verified":["[TODO]"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"dinic(最大流ソルバー)","overview":"dinic法で最大流問題を解く。\nLPの特殊な形とも捉えることができる。","code":"void dinic(DGraphF& graph, vector<DGraphF::cap_t>& result, int i_source, int i_sink) {\n  assert(i_source != i_sink);\n\n  result.resize(graph.n_);\n  vector<int> dist(graph.n_);\n  vector<bool> visited(graph.n_);\n\n  function<DGraphF::cap_t(int, int, DGraphF::cap_t)> _dfs =\n      [&](int u, int i_sink, DGraphF::cap_t mini) -> DGraphF::cap_t {\n    // DAG\n    // TODO: 経路再利用\n    if (i_sink == u)\n      return mini;\n    if (visited[u])\n      return -1;\n    visited[u] = true;\n\n    DGraphF::cap_t sumw = 0;\n    bool term = true;\n    for (int edgeidx : graph.vertex_to[u]) {\n      auto& edge = graph.edges[edgeidx];\n      if (edge.left > 0 && dist[u] > dist[edge.to]) {\n        DGraphF::cap_t f = (mini < 0) ? edge.left : min(edge.left, mini);\n\n        f = _dfs(edge.to, i_sink, f);\n        if (f == -1)\n          continue;\n        edge.left -= f;\n        result[edge.to] += f;\n\n        sumw += f;\n        mini -= f;\n        term = false;\n        visited[u] = false;  // TODO: 末尾では?\n        if (mini == 0)\n          return sumw;\n      }\n    }\n    for (int edgeidx : graph.vertex_from[u]) {\n      auto& edge = graph.edges[edgeidx];\n      if (edge.cap > edge.left && dist[u] > dist[edge.from]) {\n        DGraphF::cap_t f = (mini < 0) ? (edge.cap - edge.left) : min(edge.cap - edge.left, mini);\n\n        f = _dfs(edge.from, i_sink, f);\n        if (f == -1)\n          continue;\n        edge.left += f;\n        result[edge.to] -= f;\n\n        sumw += f;\n        mini -= f;\n        term = false;\n        visited[u] = false;\n        if (mini == 0)\n          return sumw;\n      }\n    }\n    return term ? -1 : sumw;\n  };\n\n  queue<int> que;\n  for (int distbegin = 0;; distbegin += (int)graph.n_) {\n    // sinkからsourceへの距離を計算．\n    que.emplace(i_sink);\n    dist[i_sink] = distbegin + 1;\n    while (!que.empty()) {\n      int v = que.front();\n      que.pop();\n      for (int edgeidx : graph.vertex_from[v]) {\n        const auto edge = graph.edges[edgeidx];\n        if (0 < edge.left && dist[edge.from] <= distbegin) {\n          dist[edge.from] = dist[v] + 1;\n          que.push(edge.from);\n        }\n      }\n      for (int edgeidx : graph.vertex_to[v]) {\n        const auto edge = graph.edges[edgeidx];\n        if (edge.left < edge.cap && dist[edge.to] <= distbegin) {\n          dist[edge.to] = dist[v] + 1;\n          que.push(edge.to);\n        }\n      }\n    }\n    fill(visited.begin(), visited.end(), false);\n\n    if (dist[i_source] <= distbegin)\n      break;\n    else\n      result[i_source] += _dfs(i_source, i_sink, -1);\n  }\n}","lang":"cpp","path":"/src/cpp/graph/method/flow/dinic.hpp","require":"#include <vector>\n#include <functional>\n#include <queue>\n#include <cassert>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graphflow.hpp\"","references":["http://tubo28.me/algorithm/dinic/","http://topcoder.g.hatena.ne.jp/Mi_Sawa/20140311"],"words":[],"verified":["[TODO] リファクタリング後のコードのverify","https://yukicoder.me/submissions/208764"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/graph/method/flow/dinic.cpp"]},{"title":"最大独立集合 (分岐限定法)","overview":"グラフの最大独立集合の大きさと選ぶ頂点集合を求める．\n入力グラフは単純グラフであること．多重辺はNG．\n最小頂点被覆，最大クリークに転用可能．\n分岐限定法．","code":"pair<int, vector<int>> independentSet(const Graph& graph) {\n  int bestScore = 0;\n  vector<int8_t> bestSelection;\n\n  vector<int8_t> selection(graph.size());\n  vector<int> degree(graph.size());\n\n  for (int i = 0; i < graph.size(); ++i)\n    degree[i] = graph.vertex_to[i].size();\n\n  auto deleteVtxSel = [&](int vtx, int id) -> int {\n    int del = 1;\n    selection[vtx] = id;\n    for (int to : graph.vertex_to[vtx])\n      if (selection[to] == 0) {\n        selection[to] = -id;\n        ++del;\n      }\n    for (int to : graph.vertex_to[vtx])\n      if (selection[to] == -id)\n        for (int to2 : graph.vertex_to[to])\n          if (selection[to2] == 0)\n            degree[to2]--;\n    return del;\n  };\n\n  auto undoVtxSel = [&](int vtx, int id) {\n    for (int to : graph.vertex_to[vtx])\n      if (selection[to] == -id)\n        for (int to2 : graph.vertex_to[to])\n          if (selection[to2] == 0)\n            degree[to2]++;\n    for (int to : graph.vertex_to[vtx])\n      if (selection[to] == -id)\n        selection[to] = 0;\n    selection[vtx] = 0;\n  };\n\n  auto deleteVtxUnsel = [&](int vtx, int id) -> int {\n    selection[vtx] = -id;\n    for (int to : graph.vertex_to[vtx])\n      if (selection[to] == 0)\n        degree[to]--;\n    return 1;\n  };\n\n  auto undoVtxUnsel = [&](int vtx, int id) {\n    for (int to : graph.vertex_to[vtx])\n      if (selection[to] == 0)\n        degree[to]++;\n    selection[vtx] = 0;\n  };\n\n  auto dfs = [&](auto& dfs, int depth, int rem, int score) -> void {\n    if (rem == 0) {\n      if (bestScore < score) {\n        bestScore = score;\n        bestSelection = selection;\n      }\n      return;\n    }\n    if (score + rem < bestScore)\n      return;\n\n    int minDeg = 1e9, minDegi = 0;\n    int maxDeg = 0, maxDegi = 0;\n    int zeroDegCnt = 0;\n    for (int i = 0; i < graph.size(); ++i) {\n      if (selection[i] != 0)\n        continue;\n      if (degree[i] == 0) {\n        ++zeroDegCnt;\n        selection[i] = depth;\n      }\n      if (minDeg > degree[i]) {\n        minDeg = degree[i];\n        minDegi = i;\n      }\n      if (maxDeg < degree[i]) {\n        maxDeg = degree[i];\n        maxDegi = i;\n      }\n    }\n\n    if (zeroDegCnt > 0) {\n      dfs(dfs, depth + 1, rem - zeroDegCnt, score + zeroDegCnt);\n      for (int i = 0; i < graph.size(); ++i) {\n        if (selection[i] == depth)\n          selection[i] = 0;\n      }\n      return;\n    }\n\n    if (minDeg == 1 || (minDeg == 2 && maxDeg == 2)) {\n      int dl = deleteVtxSel(minDegi, depth);\n      dfs(dfs, depth + 1, rem - dl, score + 1);\n      undoVtxSel(minDegi, depth);\n      return;\n    }\n\n    {\n      deleteVtxUnsel(maxDegi, depth);\n      dfs(dfs, depth + 1, rem - 1, score);\n      undoVtxUnsel(maxDegi, depth);\n\n      int dl = deleteVtxSel(maxDegi, depth);\n      dfs(dfs, depth + 1, rem - dl, score + 1);\n      undoVtxSel(maxDegi, depth);\n    }\n  };\n\n  dfs(dfs, 1, graph.size(), 0);\n\n  vector<int> idxs;\n  for (int i = 0; i < graph.size(); ++i)\n    if (bestSelection[i] > 0)\n      idxs.push_back(i);\n  idxs.shrink_to_fit();\n  return make_pair(bestScore, idxs);\n}","lang":"cpp","path":"/src/cpp/graph/method/independentset.hpp","require":"#include <vector>\n#include <cstdint>\n#include \"src/cpp/graph/datastructure/graph.hpp\"","references":["FV Fomin, Exact Exponential Algorithms, Springer."],"words":["vertexcover"," independentSet"],"verified":["https://atcoder.jp/contests/code-thanks-festival-2017-open/submissions/4080519"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/graph/method/vertexcover.cpp"]},{"title":"根付き木解析","overview":"根からの距離を計算する\n機能が単純すぎるので、高機能にしたい","code":"class RootedTree {\n  struct Node {\n    int depth = 0;\n  };\n  vector<Node> node_;\n\n  void dfs(const Graph& g, int v, int from) {\n    for (auto to : g.vertex_to[v]) {\n      if (to == from)\n        continue;\n      node_[to].depth = node_[v].depth + 1;\n      dfs(g, to, v);\n    }\n  }\n\n public:\n  RootedTree() {}\n  void build(const Graph& g) {\n    node_.resize(g.size());\n    node_[0].depth = 0;\n    dfs(g, 0, -1);\n  }\n  const Node& node(int v) const { return node_[v]; }\n};\n#endif  // SRC_CPP_GRAPH_METHOD_ROOTED_TREE_HPP__","lang":"cpp","path":"/src/cpp/graph/method/rooted_tree.hpp","require":"#include <vector>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graph.hpp\"","references":[],"words":[],"verified":[],"commits":[{"sha":"38f30c3190385ce1e570a1258b891ddb16d1da21","date":"2022-01-25 21:30:59 +0000","message":"add doubling"}],"tested_by":[]},{"title":"トポロジカルソート","overview":"トポロジカルソートについては次のリンクを参照\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_4_B&lang=jp","code":"vector<int> topologicalSort(const DGraph& graph) {\n  const int n = graph.n;\n  vector<int> result;\n  result.reserve(n);\n  vector<int> start;\n  start.reserve(n);\n  vector<int> sync(n);\n\n  for (int i = 0; i < n; ++i) {\n    int x = graph.vertex_from[i].size();\n    if (x == 0)\n      start.push_back(i);\n    else\n      sync[i] = x;\n  }\n\n  function<void(int)> dfs = [&](int idx) {\n    result.push_back(idx);\n    for (int to : graph.vertex_to[idx]) {\n      if (--sync[to] <= 0)\n        dfs(to);\n    }\n  };\n  for (int s : start)\n    dfs(s);\n  return result;\n}","lang":"cpp","path":"/src/cpp/graph/method/topological_sort.hpp","require":"#include <vector>\n#include <functional>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/dgraph.hpp\"","references":[],"words":[],"verified":["http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2641044#1"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"巡回セールスマン問題(bitDP)","overview":"巡回セールスマン問題をbitDPで解く．\n三角不等式を満たしていなくても解ける．\nTODO","code":"vector<int> tsProblem(int n, const Graph2d& graph) {\n  using dist_T = long long;\n  using ull = unsigned long long;\n\n  if (n <= 1)\n    return {0};\n  if (n == 2)\n    return {0, 1};\n\n  vector<vector<dist_T>> dp;\n  ull bit;\n\n  // initialize\n  dp.resize(n);\n  for (auto& v : dp)\n    v.resize(1 << n), fill(v.begin(), v.end(), (dist_T)5e15);\n\n  // bitdp\n  dp[0][1] = 0;\n  for (int bit_i = 1; bit_i < (1 << n) - 1; ++bit_i) {\n    bit = bit_i;\n\n    for (int from = 0; from < n; ++from) {\n      if (!(bool)(bit & (1ull << from)))\n        continue;\n      dist_T pt = dp[from][bit_i];\n\n      for (int to = 0; to < n; ++to) {\n        if ((bool)(bit & (1ull << to)))\n          continue;\n        dp[to][bit_i | (1ull << to)] = min(dp[to][bit_i | (1 << to)], pt + graph(from, to));\n      }\n    }\n  }\n  // 末尾を探す\n  dist_T best = 5e15;\n  int tail = 0;\n  for (int i = 0; i < n; ++i)\n    if (dp[i][(1 << n) - 1] + graph(i, 0) < best)\n      best = dp[i][(1 << n) - 1] + graph(i, 0), tail = i;\n\n  // 復元\n  vector<int> tourist;\n  tourist.reserve(n);\n  bit = (1ull << n) - 1ull;\n  for (int z = 0; z < n - 1; ++z) {\n    ull b = bit;\n    tourist.push_back(tail);\n    bit ^= bit & (1ull << tail);\n    ull c = bit;\n\n    for (int nxt = 0; nxt < n; ++nxt) {\n      if ((bit & (1ull << (ull)nxt)) && abs(dp[tail][b] - dp[nxt][c] - graph(nxt, tail)) == 0) {\n        tail = nxt;\n        break;\n      }\n    }\n  }\n  tourist.push_back(0);\n  reverse(tourist.begin(), tourist.end());\n  return tourist;\n}","lang":"cpp","path":"/src/cpp/graph/method/tsp.hpp","require":"#include <vector>\n#include <algorithm>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graph2d.hpp\"\ncpp/graph/datastructure/graph2dcpp","references":[],"words":["tsp"],"verified":["http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2588066#1","http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2641075#1"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"最小頂点被覆 (半分全列挙)","overview":"グラフの最小頂点被覆の大きさと選ぶ頂点集合を求める．\n最大独立集合，最大クリークに転用可能．\n半分全列挙の実装","code":"inline int bitcount(int x) {\n  return bitset<31>(x).count();\n}\n\n// 半分全列挙\npair<int, vector<int>> vertexCover(const Graph& graph) {\n  const int n = graph.n;\n  const int n_A = n / 2;\n  const int n_B = n - n_A;\n  const int inf = 1e9;\n\n  // group A : i <  n_A\n  // group B : i >= n_A\n\n  // dp[S] : S \\subseteq V_A，\n  vector<int> ans_partial_A(1 << n_A, 0);\n\n  // Sが独立集合なら0，独立集合でないならinfとなるように初期状態を構成する．\n  for (int i = 0; i < n_A; ++i) {\n    int bit = 1 << i;\n    for (int j : graph.vertex_to[i])\n      if (j < n_A)\n        ans_partial_A[bit | (1 << j)] = inf;  // 頂点数2\n  }\n  for (int bit = 3; bit < 1 << n_A; ++bit) {\n    if (bitcount(bit) <= 1)\n      continue;\n    for (int i = 0; i < n_A; ++i) {\n      ans_partial_A[bit | (1 << i)] |= ans_partial_A[bit];\n    }\n  }\n\n  // groupA の部分集合の解を全列挙\n  // ここでは groupA と groupB のカットエッジの被覆は考えない．\n  for (int bit = 1; bit < 1 << n_A; ++bit) {\n    for (int i = 0; i < n_A; ++i) {\n      if (bit & (1 << i))\n        continue;\n      ans_partial_A[bit | (1 << i)] = min(ans_partial_A[bit | (1 << i)], ans_partial_A[bit] + 1);\n    }\n  }\n\n  // dp[S] Sは独立集合ではない\n  vector<bool> not_independent_B(1 << n_B, 0);\n  for (int _i = 0; _i < n_B; ++_i) {\n    int bit = 1 << _i;\n    for (int j : graph.vertex_to[n_A + _i])\n      if (n_A <= j)\n        not_independent_B[bit | (1 << (j - n_A))] = 1;\n  }\n  for (int bit = 3; bit < 1 << n_B; ++bit) {\n    if (bitcount(bit) <= 1)\n      continue;\n    for (int _i = 0; _i < n_B; ++_i) {\n      not_independent_B[bit | (1 << _i)] =\n          not_independent_B[bit | (1 << _i)] | not_independent_B[bit];\n    }\n  }\n\n  // dp[S] Sに隣接する頂点のbit配列\n  vector<int> adjacent2B(1 << n_B, 0);\n  for (int _i = 0; _i < n_B; ++_i) {\n    int bit = 0;\n    for (int j : graph.vertex_to[n_A + _i])\n      if (j < n_A)\n        bit |= 1 << j;\n    adjacent2B[1 << _i] = bit;\n  }\n  for (int bit = 1; bit < 1 << n_B; ++bit) {\n    for (int _i = 0; _i < n_B; ++_i) {\n      adjacent2B[bit | (1 << _i)] |= adjacent2B[bit];\n    }\n  }\n\n  // answer\n  int best = inf;\n  pair<int, int> vtx_selection;\n\n  // groupB の部分集合を全列挙\n  for (int bit = 0; bit < 1 << n_B; ++bit) {\n    // choice_Bが頂点被覆でないなら，reject\n    if (not_independent_B[((1 << n_B) - 1) ^ bit])\n      continue;\n\n    int mask_A = (1 << n_A) - 1;\n    int fix_A = 0;\n\n    int adj = adjacent2B[((1 << n_B) - 1) ^ bit];\n    for (int i = 0; i < n_A; ++i) {\n      // choice_B で選んでいない頂点が，groupAと隣接するならば\n      if (adj & (1 << i)) {\n        // そのgroupAの頂点は必ず選択する．\n        mask_A ^= 1 << i;  // 頂点jは考慮しなくてよい\n        ++fix_A;           // 必ず選択することにしたので\n      }\n    }\n\n    int score = ans_partial_A[mask_A] + bitcount(bit) + fix_A;\n    if (score < best) {\n      best = score;\n      vtx_selection.first = mask_A;\n      vtx_selection.second = bit;\n    }\n  }\n\n  // 選んだ頂点の復元\n  vector<int> selection;\n  for (int i = 0; i < n_B; ++i) {\n    if (vtx_selection.second & (1 << i))\n      selection.push_back(n_A + i);\n  }\n  for (int i = 0; i < n_A; ++i) {\n    if ((vtx_selection.first & (1 << i)) == 0)\n      selection.push_back(i);\n  }\n  {\n    int m = vtx_selection.first;\n    int curr = ans_partial_A[m];\n    while (m > 0) {\n      int bi;\n      for (int i = 0; i < n_A; ++i) {\n        if ((m & (1 << i)) == 0)\n          continue;\n        int a = ans_partial_A[m ^ (1 << i)];\n        if (curr == a) {\n          bi = -1;\n          m ^= (1 << i);\n          break;\n        } else if (curr - 1 == a) {\n          bi = i;\n        }\n      }\n      if (bi >= 0) {\n        m ^= (1 << bi);\n        selection.push_back(bi);\n        --curr;\n      }\n    }\n  }\n  sort(selection.begin(), selection.end());\n  selection.shrink_to_fit();\n\n  return make_pair(best, selection);\n}","lang":"cpp","path":"/src/cpp/graph/method/vertexcover.hpp","require":"#include <vector>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n#include \"src/cpp/graph/datastructure/graph.hpp\"\ncpp/graph/datastructure/graph.hpp","references":[],"words":["vertexcover"],"verified":["http://buyoh.hateblo.jp/entry/2017/12/10/184345","https://atcoder.jp/contests/code-thanks-festival-2017-open/submissions/4065305"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/graph/method/vertexcover.cpp"]},{"title":"2次元グリッドと二次元座標","overview":"ゲームAI用。\nクラス名は極端に短くしてある。","code":"struct P {\n  using T = int;\n  T y, x;\n\n  inline explicit P(T _y, T _x) : y(_y), x(_x) {}\n  inline P() : y(0), x(0) {}\n\n  inline bool operator==(P p) const { return y == p.y && x == p.x; }\n  inline bool operator<(P p) const { return y == p.y ? x < p.x : y < p.y; }\n  inline P operator+(P p) const { return P(y + p.y, x + p.x); }\n  inline P operator-(P p) const { return P(y - p.y, x - p.x); }\n  inline P& operator+=(P p) {\n    y += p.y;\n    x += p.x;\n    return *this;\n  }\n  inline P& operator-=(P p) {\n    y -= p.y;\n    x -= p.x;\n    return *this;\n  }\n  inline P& operator*=(T m) {\n    y *= m;\n    x *= m;\n    return *this;\n  }\n  inline T distM(P p) const { return abs(y - p.y) + abs(x - p.x); }\n  inline T distC(P p) const { return max(abs(y - p.y), abs(x - p.x)); }\n  template <typename ITR>\n  ITR nearestM(ITR begin, ITR end) const {\n    if (begin == end)\n      return end;\n    T best = distM(*begin);\n    ITR besti = begin;\n    for (ITR it = begin; ++it, it != end;) {\n      T m = distM(*it);\n      if (best < m) {\n        best = m;\n        besti = it;\n      }\n    }\n    return besti;\n  }\n};\ninline ostream& operator<<(ostream& os, P p) {\n  os << '(' << p.y << ',' << p.x << ')';\n  return os;\n}\n\nconst P FourMoving[] = {P(-1, 0), P(0, 1), P(1, 0), P(0, -1)};\nconst P FiveMoving[] = {P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(0, 0)};\nconst P EightMoving[] = {P(-1, 0),  P(0, 1),  P(1, 0),  P(0, -1),\n                         P(-1, -1), P(-1, 1), P(1, -1), P(1, 1)};\n\ninline P operator*(P::T m, P p) noexcept {\n  return P(m * p.y, m * p.x);\n}\n\ntemplate <typename T>\n// using T = int;\nstruct F {\n  int height, width;\n  vector<T> data;\n\n  explicit F(int h, int w) : height(h), width(w), data(h * w) {}\n  F() : F(1, 1) {}\n#if 0\n  void assert_safe(int y, int x) const {\n    if (!safe(y, x)) {\n      clog << \"assertion failed: field=\" << height << \"x\" << width\n           << \": try=\" << y << \",\" << x << endl;\n      assert(safe(y, x));\n    }\n  }\n  inline T &operator()(int y, int x) {\n    assert_safe(y, x);\n    return data[x + y * width];\n  }\n  inline T &operator()(P p) {\n    assert_safe(p);\n    return data[p.x + p.y * width];\n  }\n  inline T operator()(int y, int x) const {\n    assert_safe(y, x);\n    return data[x + y * width];\n  }\n  inline T operator()(P p) const {\n    assert_safe(p);\n    return data[p.x + p.y * width];\n  }\n#else\n  inline T& operator()(int y, int x) { return data[x + y * width]; }\n  inline T& operator()(P p) { return data[p.x + p.y * width]; }\n  inline T operator()(int y, int x) const { return data[x + y * width]; }\n  inline T operator()(P p) const { return data[p.x + p.y * width]; }\n#endif\n  inline bool safe(int y, int x) const { return 0 <= y && y < height && 0 <= x && x < width; }\n  inline bool safe(P p) const { return 0 <= p.y && p.y < height && 0 <= p.x && p.x < width; }\n\n  inline void fill(T e) { std::fill(data.begin(), data.end(), e); }\n  inline void resize(int h, int w) {\n    height = h;\n    width = w;\n    data.resize(h * w);\n  }\n\n  void print(ostream& os, int setw_arg = 4) {\n    for (int y = 0; y < height; ++y) {\n      for (int x = 0; x < width; ++x)\n        os << setw(setw_arg) << operator()(y, x) << ' ';\n      os << '\\n';\n    }\n  }\n};","lang":"cpp","path":"/src/cpp/grid/datastructure/euclid.hpp","require":"#include <cmath>\n#include <ostream>\n#include <iomanip>\n#include <vector>\nusing namespace std;","references":[],"words":["grid"," field"," point"," game"],"verified":[],"commits":[{"sha":"072992c3f1605b90d247b53f3484dd25f1e4cccc","date":"2022-11-13 09:35:25 +0000","message":"refactor by Github Actions"},{"sha":"68099ce9166ddf3f370ce50c82e64bc0e27ffce8","date":"2022-11-11 02:51:51 +0000","message":"Add assertion"},{"sha":"471262d7edc58353eb19a849cb1dba01ac24b1d6","date":"2021-09-09 02:10:52 +0000","message":"use explicit constructor"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"2次元グリッド上の距離(マンハッタン距離)","overview":"","code":"template <typename T>\nF<int> make_distancetable(int height,\n                          int width,\n                          const vector<P>& start_point,\n                          function<bool(P)> ismoveable) {\n  constexpr int inf = numeric_limits<int>::max();\n\n  F<int> result(height, width);\n  result.fill(inf);\n\n  queue<P> q;\n  for (const P& p : start_point)\n    q.push(p), result(p) = 0;\n\n  while (!q.empty()) {\n    P p = q.front();\n    q.pop();\n    int d = result(p);\n    if (0 < p.y && result(p.y - 1, p.x) == inf && ismoveable(P(p.y - 1, p.x)))\n      q.emplace(p.y - 1, p.x), result(p.y - 1, p.x) = d + 1;\n    if (p.y < height - 1 && result(p.y + 1, p.x) == inf && ismoveable(P(p.y + 1, p.x)))\n      q.emplace(p.y + 1, p.x), result(p.y + 1, p.x) = d + 1;\n    if (0 < p.x && result(p.y, p.x - 1) == inf && ismoveable(P(p.y, p.x - 1)))\n      q.emplace(p.y, p.x - 1), result(p.y, p.x - 1) = d + 1;\n    if (p.x < width - 1 && result(p.y, p.x + 1) == inf && ismoveable(P(p.y, p.x + 1)))\n      q.emplace(p.y, p.x + 1), result(p.y, p.x + 1) = d + 1;\n  }\n  return result;\n}","lang":"cpp","path":"/src/cpp/grid/method/distance.hpp","require":"#include <functional>\n#include <limits>\n#include <queue>\nusing namespace std;\n#include \"src/cpp/grid/datastructure/euclid.hpp\"","references":[],"words":["grid"," field"," point"],"verified":["[TODO]"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"2次元グリッド上のダイクストラ","overview":"全てのセルに対してstartからの距離を求める","code":"/// <summary>\n/// 全てのセルに対してstartからの距離を求める\n/// </summary>\n/// <param name=\"height\">gridの高さ</param>\n/// <param name=\"width\">gridの幅</param>\n/// <param name=\"start\">開始地点</param>\n/// <param name=\"costFunc\">costFunc(curr, dest):\n/// 現在地点currから隣接点destに移動する時に掛かるコストを返す関数</param>\n/// <returns>開始地点からの最短距離</returns>\nF<ll> gridDistance(int height, int width, P start, function<ll(P, P)> costFunc) {\n  priority_queue<pair<ll, P>> pque;\n\n  F<ll> dist(height, width);\n  dist.fill(numeric_limits<ll>::max());\n  pque.emplace(0, start);\n  dist(start) = 0;\n\n  while (!pque.empty()) {\n    auto dx = pque.top();\n    pque.pop();\n    dx.first = -dx.first;\n\n    for (auto y : FourMoving) {\n      y += dx.second;\n      if (!dist.safe(y))\n        continue;\n      auto c = costFunc(dx.second, y);\n      if (c >= 0 && dist(y) > dx.first + c) {\n        dist(y) = dx.first + c;\n        pque.emplace(-(dx.first + c), y);\n      }\n    }\n  }\n\n  return dist;\n}","lang":"cpp","path":"/src/cpp/grid/method/griddistance.hpp","require":"#include <functional>\n#include <limits>\n#include <queue>\nusing namespace std;\n#include \"src/cpp/grid/datastructure/euclid.hpp\"\nusing ll = long long;","references":[],"words":["grid"," dij"],"verified":["https://yukicoder.me/submissions/294734"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"競技プログラミング用デバッグ・効率化","overview":"悪しき慣例であるrepマクロ等をまとめたもの．","code":"#pragma GCC optimize(\"O3\")\n#include \"bits/stdc++.h\"\n\n// clang-format off\nusing namespace std;\nusing ll = long long int;\n\n#define all(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(typename remove_const<typename remove_reference<decltype(l)>::type>::type cnt={};(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define increase(cnt,b,e) for(auto cnt=(b);(cnt)<(e);++(cnt))\n#define decrease(cnt,b,e) for(auto cnt=(b);(e)<=(cnt);--(cnt))\nconst long long MD = 998244353; const long double PI = 3.1415926535897932384626433832795L;\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename T> inline T& chmax(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& chmin(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T, typename Random = decltype(randdev), typename enable_if<is_integral<T>::value>::type* = nullptr>\ninline T rand(T l, T h, Random& rand = randdev) { return uniform_int_distribution<T>(l, h)(rand); }\ntemplate<typename T, typename Random = decltype(randdev), typename enable_if<is_floating_point<T>::value>::type* = nullptr>\ninline T rand(T l, T h, Random& rand = randdev) { return uniform_real_distribution<T>(l, h)(rand); }template<typename T>\nstatic ostream& operator<<(ostream& o, const std::vector<T>& v) {\n  o << \"[ \"; for(const auto& e : v) o<<e<<' '; return o << ']';\n}\n\ntemplate <typename I> struct MyRangeFormat{ I b,e; MyRangeFormat(I _b, I _e):b(_b),e(_e){} };\ntemplate<typename I> static ostream& operator<<(ostream& o, const MyRangeFormat<I>& f) {\n  o << \"[ \"; iterate(i,f.b,f.e) o<<*i<<' '; return o << ']';\n}\ntemplate <typename I> struct MyMatrixFormat{\n  const I& p; long long n, m;\n  MyMatrixFormat(const I& _p, long long _n, long long _m):p(_p),n(_n),m(_m){}\n};\ntemplate<typename I> static ostream& operator<<(ostream& o, const MyMatrixFormat<I>& f) {\n  o<<'\\n';\n  repeat(i,(f.n)) {\n    repeat(j,f.m) o<<f.p[i][j]<<' ';\n    o<<'\\n';\n  }\n  return o;\n}\nstruct LOG_t { ~LOG_t() { cout << endl; } };\n#define LOG (LOG_t(),cout<<'L'<<__LINE__<<\": \")\n#define FMTA(m,w) (MyRangeFormat<decltype(m+0)>(m,m+w))\n#define FMTR(b,e) (MyRangeFormat<decltype(e)>(b,e))\n#define FMTV(v) FMTR(v.begin(),v.end())\n#define FMTM(m,h,w) (MyMatrixFormat<decltype(m+0)>(m,h,w))\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getc_x _getc_nolock\n#define putc_x _putc_nolock\n#elif defined(__GNUC__)\n#define getc_x getc_unlocked\n#define putc_x putc_unlocked\n#else\n#define getc_x getc\n#define putc_x putc\n#endif\nclass MaiScanner {\n  FILE* fp_;\n  constexpr bool isvisiblechar(char c) noexcept { return (0x21<=(c)&&(c)<=0x7E); }\npublic:\n  inline MaiScanner(FILE* fp):fp_(fp){}\n  template<typename T> void input_integer(T& var) noexcept {\n    var = 0; T sign = 1;\n    int cc = getc_x(fp_);\n    for (; cc < '0' || '9' < cc; cc = getc_x(fp_))\n      if (cc == '-') sign = -1;\n    for (; '0' <= cc && cc <= '9'; cc = getc_x(fp_))\n      var = (var << 3) + (var << 1) + cc - '0';\n    var = var * sign;\n  }\n  inline int c() noexcept { return getc_x(fp_); }\n  template<typename T, typename enable_if<is_integral<T>::value, nullptr_t>::type = nullptr>\n  inline MaiScanner& operator>>(T& var) noexcept { input_integer<T>(var); return *this; }\n  inline MaiScanner& operator>>(string& var) {\n    int cc = getc_x(fp_);\n    for (; !isvisiblechar(cc); cc = getc_x(fp_));\n    for (; isvisiblechar(cc); cc = getc_x(fp_))\n      var.push_back(cc);\n    return *this;\n  }\n  template<typename IT> inline void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n};\nclass MaiPrinter {\n  FILE* fp_;\npublic:\n  inline MaiPrinter(FILE* fp):fp_(fp){}\n  template<typename T>\n  void output_integer(T var) noexcept {\n    if (var == 0) { putc_x('0', fp_); return; }\n    if (var < 0)\n      putc_x('-', fp_),\n      var = -var;\n    char stack[32]; int stack_p = 0;\n    while (var)\n      stack[stack_p++] = '0' + (var % 10),\n      var /= 10;\n    while (stack_p)\n      putc_x(stack[--stack_p], fp_);\n  }\n  inline MaiPrinter& operator<<(char c) noexcept { putc_x(c, fp_); return *this; }\n  template<typename T, typename enable_if<is_integral<T>::value, nullptr_t>::type = nullptr>\n  inline MaiPrinter& operator<<(T var) noexcept { output_integer<T>(var); return *this; }\n  inline MaiPrinter& operator<<(char* str_p) noexcept { while (*str_p) putc_x(*(str_p++), fp_); return *this; }\n  inline MaiPrinter& operator<<(const string& str) {\n    const char* p = str.c_str();\n    const char* l = p + str.size();\n    while (p < l) putc_x(*p++, fp_);\n    return *this;\n  }\n  template<typename IT> void join(IT begin, IT end, char sep = ' ') { for (bool b = 0; begin != end; ++begin, b = 1) b ? *this << sep << *begin : *this << *begin; }\n};\nMaiScanner scanner(stdin);\nMaiPrinter printer(stdout);\n// clang-format on","lang":"cpp","path":"/src/cpp/implements/compe.hpp","require":"","references":[],"words":["kyopuro"," rep"],"verified":[],"commits":[{"sha":"9e1cdb5dee484a1b904f76c6a20048c18f19bc77","date":"2021-09-02 22:56:30 +0000","message":"Update compe.hpp"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"前半を共有できるリスト","overview":"落ちゲーのビームサーチなどでコマンドを記憶する時などにつかえる。\n以下の機能を持つ。\n- 列の末尾に要素を追加する (定数時間)\n- 列を複製する (定数時間)\n- 列をstd::vectorに書き出す (要素数に比例する時間)\nデストラクタの実行時間については改善を行っていないので、注意。\n競技プログラミング用途であれば、強制メモリリークも考えてみる。","code":"// using T = int;\ntemplate <typename T>\nclass CommandChain {\n public:\n  static shared_ptr<CommandChain> createEmpty() {\n    static shared_ptr<CommandChain> p = shared_ptr<CommandChain>(new CommandChain());\n    return p;\n  }\n\n  static shared_ptr<CommandChain> pushed(shared_ptr<CommandChain>& me, T cmd) {\n    assert(me.get());\n    auto new_chain = make_shared<CommandChain>();\n    new_chain->prev_ = me;\n    new_chain->node_ = std::move(cmd);\n    return new_chain;\n  }\n  void dumpRefTo(vector<const T*>& out) const {\n    if (prev_.get()) {\n      prev_->dumpRefTo(out);\n      // root does not have value\n      out.push_back(&node_);\n    }\n  }\n  vector<const T*> dumpRef() const {\n    vector<const T*> out;\n    dumpRefTo(out);\n    return out;\n  }\n\n  void dumpTo(vector<T>& out) const {\n    if (prev_.get()) {\n      prev_->dumpTo(out);\n      // root does not have value\n      out.push_back(node_);\n    }\n  }\n  vector<T> dump() const {\n    vector<T> out;\n    dumpTo(out);\n    return out;\n  }\n\n  // TODO: make private...\n  CommandChain() : prev_(), node_() {}\n  // CommandChain(shared_ptr<CommandChain> &prev) : prev_(prev), node_() {}\n\n private:\n  shared_ptr<CommandChain> prev_;\n  T node_;\n};\n\n#endif  // SRC_CPP_IMPLEMENTS_DATASTRUCTURE_COMMANDCHAIN_HPP__","lang":"cpp","path":"/src/cpp/implements/datastructure/commandchain.hpp","require":"#include <memory>\n#include <vector>\nusing namespace std;","references":[],"words":["command"],"verified":[],"commits":[{"sha":"6a411e84f3c8077adb0b85dbb4bba7eff48ddc84","date":"2022-11-11 02:50:18 +0000","message":"Add command chain"}],"tested_by":[]},{"title":"前半を共有できるリスト(2bit)","overview":"CommandChain派生。2bitに制限する変わりに効率を良くしたもの。\nコマンドが前後左右だけ、などであれば、こちらが早い可能性がある。\nチューニングは不完全なのでもう少し頑張りたい","code":"class CommandChain {\n public:\n  using Direction = int;  // 2bit\n  struct Node {\n    Node() : value(0), len(0) {}\n    void push(Direction dir) {\n      value |= (uint64_t)(dir & 3) << (uint64_t)len;\n      len += 2;\n    }\n    bool full() const { return len >= 64; }\n    void dump(vector<int>& out) const {\n      for (uint64_t p = 0; p < uint64_t(len); p += 2)\n        out.push_back((value >> p) & 3);\n    }\n    int last() const { return (value >> uint64_t(len - 2)) & 3; }\n\n    uint64_t value;\n    int len = 0;\n  };\n\n  static shared_ptr<CommandChain> createEmpty() { return make_shared<CommandChain>(root()); }\n\n  static shared_ptr<CommandChain> pushed(shared_ptr<CommandChain>& me, Direction cmd) {\n    // assert(me.get());\n    if (me->node_.full()) {\n      auto new_chain = make_shared<CommandChain>(me);\n      new_chain->node_.push(cmd);\n      return new_chain;\n    } else {\n      auto copied_chain = make_shared<CommandChain>(*me);\n      copied_chain->node_.push(cmd);\n      return copied_chain;\n    }\n  }\n\n  int last() const { return node_.last(); }\n\n  void dumpTo(vector<int>& out) const {\n    if (prev_.get()) {\n      prev_->dumpTo(out);\n      // root does not have value\n      node_.dump(out);\n    }\n  }\n  vector<int> dump() const {\n    vector<int> out;\n    dumpTo(out);\n    return out;\n  }\n\n  // TODO: make private...\n  CommandChain(shared_ptr<CommandChain>& prev) : prev_(prev), node_() {}\n\n private:\n  // friend shared_ptr<CommandChain>;\n  static shared_ptr<CommandChain>& root() {\n    static shared_ptr<CommandChain> e(new CommandChain());\n    return e;\n  };\n\n  shared_ptr<CommandChain> prev_;\n  Node node_;\n  CommandChain() : prev_(), node_() {}\n};\n\n#endif  // SRC_CPP_IMPLEMENTS_DATASTRUCTURE_COMMANDCHAIN2_HPP__","lang":"cpp","path":"/src/cpp/implements/datastructure/commandchain2.hpp","require":"#include <memory>\n#include <vector>\nusing namespace std;","references":[],"words":["command"],"verified":[],"commits":[{"sha":"6a411e84f3c8077adb0b85dbb4bba7eff48ddc84","date":"2022-11-11 02:50:18 +0000","message":"Add command chain"}],"tested_by":[]},{"title":"std::hashの追加定義","overview":"std::hashに定義を追加することでunordered_setが扱える型を増やす．\nstd::pair<T1,T2> のみ","code":"namespace std {\ntemplate <typename T1, typename T2>\nstruct hash<pair<T1, T2>> {\n  constexpr inline size_t operator()(const pair<T1, T2>& x) const {\n    return hash<T1>()(x.first) ^ hash<T2>()(x.second);\n  }\n};\n}  // namespace std","lang":"cpp","path":"/src/cpp/implements/datastructure/hashes.hpp","require":"#include <unordered_set>\n#include <unordered_map>\nusing namespace std;","references":[],"words":[],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"getc,putcによる入出力実装．","overview":"_WIN64 OR _WIN32 環境なら _getc_nolock を，\n__GNUC__         環境なら getc_unlocked を，\nそれ以外の環境なら getc を使う．(codeforcesでも使える)\n実数には対応しない．対応したとしてもscanf,printfでごまかします．\n\nstringを読み込む際，変数をクリアしない．\nこれを使って，入力値を文字で囲むことができる．\nstring str = \"#\"; scanner >> str; str.push_back('#');\n\nFILE* 型の外部ファイル読み込みにも対応した．\nMaiScanner sc(fp); と書く．","code":"#if defined(_WIN32) || defined(_WIN64)\n#define getc_x _getc_nolock\n#define putc_x _putc_nolock\n#elif defined(__GNUC__)\n#define getc_x getc_unlocked\n#define putc_x putc_unlocked\n#else\n#define getc_x getc\n#define putc_x putc\n#endif\nclass MaiScanner {\n  FILE* fp_;\n  constexpr bool isvisiblechar(char c) noexcept { return (0x21 <= (c) && (c) <= 0x7E); }\n\n public:\n  inline MaiScanner(FILE* fp) : fp_(fp) {}\n  template <typename T>\n  void input_integer(T& var) noexcept {\n    var = 0;\n    T sign = 1;\n    int cc = getc_x(fp_);\n    for (; cc < '0' || '9' < cc; cc = getc_x(fp_))\n      if (cc == '-')\n        sign = -1;\n    for (; '0' <= cc && cc <= '9'; cc = getc_x(fp_))\n      var = (var << 3) + (var << 1) + cc - '0';\n    var = var * sign;\n  }\n  inline int c() noexcept { return getc_x(fp_); }\n  template <typename T, typename enable_if<is_integral<T>::value, nullptr_t>::type = nullptr>\n  inline MaiScanner& operator>>(T& var) noexcept {\n    input_integer<T>(var);\n    return *this;\n  }\n  inline MaiScanner& operator>>(string& var) {\n    int cc = getc_x(fp_);\n    for (; !isvisiblechar(cc); cc = getc_x(fp_))\n      ;\n    for (; isvisiblechar(cc); cc = getc_x(fp_))\n      var.push_back(cc);\n    return *this;\n  }\n  template <typename IT>\n  inline void in(IT begin, IT end) {\n    for (auto it = begin; it != end; ++it)\n      *this >> *it;\n  }\n};\nclass MaiPrinter {\n  FILE* fp_;\n\n public:\n  inline MaiPrinter(FILE* fp) : fp_(fp) {}\n  template <typename T>\n  void output_integer(T var) noexcept {\n    if (var == 0) {\n      putc_x('0', fp_);\n      return;\n    }\n    if (var < 0)\n      putc_x('-', fp_), var = -var;\n    char stack[32];\n    int stack_p = 0;\n    while (var)\n      stack[stack_p++] = '0' + (var % 10), var /= 10;\n    while (stack_p)\n      putc_x(stack[--stack_p], fp_);\n  }\n  inline MaiPrinter& operator<<(char c) noexcept {\n    putc_x(c, fp_);\n    return *this;\n  }\n  template <typename T, typename enable_if<is_integral<T>::value, nullptr_t>::type = nullptr>\n  inline MaiPrinter& operator<<(T var) noexcept {\n    output_integer<T>(var);\n    return *this;\n  }\n  inline MaiPrinter& operator<<(char* str_p) noexcept {\n    while (*str_p)\n      putc_x(*(str_p++), fp_);\n    return *this;\n  }\n  inline MaiPrinter& operator<<(const string& str) {\n    const char* p = str.c_str();\n    const char* l = p + str.size();\n    while (p < l)\n      putc_x(*p++, fp_);\n    return *this;\n  }\n  template <typename IT>\n  void join(IT begin, IT end, char sep = ' ') {\n    for (bool b = 0; begin != end; ++begin, b = 1)\n      b ? *this << sep << *begin : *this << *begin;\n  }\n};\nMaiScanner scanner(stdin);\nMaiPrinter printer(stdout);","lang":"cpp","path":"/src/cpp/implements/datastructure/io/stdio.hpp","require":"#include <cstdio>\n#include <string>\nusing namespace std;","references":["cLay"],"words":["io"],"verified":["http://codeforces.com/contest/71/submission/33012760","https://csacademy.com/contest/archive/task/addition/","https://yukicoder.me/submissions/221925"],"commits":[{"sha":"c8312aa34f149ea9302128d213cd983db5440e1a","date":"2020-07-03 21:19:58 +0000","message":"use metafunction"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"ぐるぐるイテレータ","overview":"正方形限定","code":"struct DreamcastScan {\n  const int Width;\n  constexpr DreamcastScan(int _w) : Width(_w) {}\n  struct Iterator {\n    int w;     // width\n    int i, o;  // index, offset\n    constexpr Iterator(int _w, int _i, int _o) : w(_w), i(_i), o(_o) {}\n\n    inline pair<int, int> operator*() const {\n      if (i < w - 1)\n        return make_pair(o + i, o);\n      else if (i < (w - 1) * 2)\n        return make_pair(o + w - 1, o + i - (w - 1));\n      else if (i < (w - 1) * 3)\n        return make_pair(o + (w - 1) * 3 - i, o + w - 1);\n      else\n        return make_pair(o, o + (w - 1) * 4 - i);\n    }\n    inline Iterator& operator++() {\n      if (++i >= (w - 1) * 4)\n        i = 0, w -= 2, o += 1;\n      return *this;\n    }\n    inline bool operator!=(const Iterator& it) const { return w != it.w || i != it.i; }\n  };\n  constexpr inline Iterator begin() const { return Iterator(Width, 0, 0); }\n  constexpr inline Iterator end() const { return Iterator(-(Width & 1), 0, 0); }\n};","lang":"cpp","path":"/src/cpp/implements/datastructure/iterator/dreamcast.hpp","require":"#include <algorithm>\nusing namespace std;","references":[],"words":["yuyuko"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"iterator with index","overview":"イテレータにインデックスを付け加える．","code":"template <typename ITER>\nclass IteratorWithIndex {\n  // using ITER = int*;\n  const ITER begin_;\n  const ITER end_;\n\n public:\n  IteratorWithIndex(ITER _begin, ITER _end) : begin_(move(_begin)), end_(move(_end)) {}\n  struct Iterator {\n    ITER it;\n    int i;\n    Iterator(ITER _it, int _i) : it(move(_it)), i(_i) {}\n    inline pair<int, decltype(*it)> operator*() const { return pair<int, decltype(*it)>(i, *it); }\n    inline Iterator& operator++() {\n      ++it, ++i;\n      return *this;\n    }\n    inline auto operator!=(const Iterator& another) const -> decltype(it != another.it) {\n      return it != another.it;\n    }\n  };\n  inline Iterator begin() const { return Iterator(begin_, 0); }\n  inline Iterator end() const { return Iterator(end_, 0); }\n};\ntemplate <typename ITER>\ninline IteratorWithIndex<ITER> make_IteratorWithIndex(ITER _begin, ITER _end) {\n  return IteratorWithIndex<ITER>(_begin, _end);\n}","lang":"cpp","path":"/src/cpp/implements/datastructure/iterator/iteratorwithindex.hpp","require":"#include <algorithm>\nusing namespace std;","references":[],"words":["iterator","index"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"Tag","overview":"std::pairに似ているが，secondは比較の対象にならない．\nTag.firstが等価であれば，構造体も等価であるとみなされる．\nマラソンマッチ用","code":"template <typename T1, typename T2>\nstruct Tag {\n  T1 first;\n  T2 second;\n\n  Tag(T1 t1, T2 t2) : first(t1), second(t2) {}\n  Tag(const pair<T1, T2>& p) : first(p.first), second(p.second) {}\n  Tag(const pair<T1, T2>&& p) : first(p.first), second(p.second) {}\n\n  inline bool operator==(const Tag& t) const { return first == t.first; }\n  inline bool operator<(const Tag& t) const { return first < t.first; }\n};","lang":"cpp","path":"/src/cpp/implements/datastructure/tag.hpp","require":"#include <utility>\nusing namespace std;","references":[],"words":["kyopuro"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"ビット演算","overview":"1単位の整数に対して，立っているビットの数を数えたりする．\nコンパイラ組込み関数があれば，なるべくそれを使うようにする．\n計算量は最悪でもlog(bitsize)時間．\n\nnote: __lzcntはCPU依存なので実装から除外","code":"namespace BitAlgo {\n// 1が立っている数(f(1) = 1, f(6) = 2)\ninline int popcount32(uint32_t v) noexcept {\n#if defined(__GNUC__)\n  return __builtin_popcount(v);\n#elif defined(_MSC_VER)\n  return __popcnt(v);\n#else\n  v = (v & 0x55555555) + (v >> 1 & 0x55555555);\n  v = (v & 0x33333333) + (v >> 2 & 0x33333333);\n  v = (v & 0x0f0f0f0f) + (v >> 4 & 0x0f0f0f0f);\n  v = (v & 0x00ff00ff) + (v >> 8 & 0x00ff00ff);\n  return (v & 0x0000ffff) + (v >> 16 & 0x0000ffff);\n#endif\n}\n// 1が立っている数(f(1) = 1, f(6) = 2)\ninline int popcount64(uint64_t v) noexcept {\n#if defined(__GNUC__)\n  return __builtin_popcountll(v);\n#elif defined(_MSC_VER)\n  return __popcnt64(v);\n#else\n  v = (v & 0x5555555555555555ll) + (v >> 1 & 0x5555555555555555ll);\n  v = (v & 0x3333333333333333ll) + (v >> 2 & 0x3333333333333333ll);\n  v = (v & 0x0f0f0f0f0f0f0f0fll) + (v >> 4 & 0x0f0f0f0f0f0f0f0fll);\n  v = (v & 0x00ff00ff00ff00ffll) + (v >> 8 & 0x00ff00ff00ff00ffll);\n  v = (v & 0x0000ffff0000ffffll) + (v >> 16 & 0x0000ffff0000ffffll);\n  return (v & 0x00000000ffffffffll) + (v >> 32 & 0x00000000ffffffffll);\n#endif\n}\n// popcount % 2\ninline int parity32(uint32_t v) noexcept {\n#if defined(__GNUC__)\n  return __builtin_parity(v);\n#else\n  return popcount32(v) & 1;\n#endif\n}\n// popcount % 2\ninline int parity64(uint64_t v) noexcept {\n#if defined(__GNUC__)\n  return __builtin_parityll(v);\n#else\n  return popcount32(v) & 1;\n#endif\n}\n// 2進で表した場合に小さい方から何桁目に初めて1が現れるか\n// (f(3) = 1, f(8) = 4, f(0) = 0)\n// 関連：__builtin_ctz\ninline int ffs32(uint32_t v) noexcept {\n#if defined(__GNUC__)\n  return __builtin_ffs(v);\n#else\n  int c = 1;\n  if (v == 0)\n    return 0;\n  if (!(v & 0xFFFF))\n    c += 16, v >>= 16;\n  if (!(v & 0x00FF))\n    c += 8, v >>= 8;\n  if (!(v & 0x000F))\n    c += 4, v >>= 4;\n  if (!(v & 0x0003))\n    c += 2, v >>= 2;\n  if (!(v & 0x0001))\n    c += 1;\n  return c;\n#endif\n}\n// 2進で表した場合に小さい方から何桁目に初めて1が現れるか\n// (f(3) = 1, f(8) = 4, f(0) = 0)\n// 関連：__builtin_ctzll\ninline int ffs64(uint64_t v) noexcept {\n#if defined(__GNUC__)\n  return __builtin_ffsll(v);\n#else\n  int c = 1;\n  if (v == 0)\n    return 0;\n  if (!(v & 0xFFFFFFFFll))\n    c += 32, v >>= 32;\n  if (!(v & 0x0000FFFFll))\n    c += 16, v >>= 16;\n  if (!(v & 0x00FF))\n    c += 8, v >>= 8;\n  if (!(v & 0x000F))\n    c += 4, v >>= 4;\n  if (!(v & 0x0003))\n    c += 2, v >>= 2;\n  if (!(v & 0x0001))\n    c += 1;\n  return c;\n#endif\n}\n// 末尾から続く0の個数\n// (f(2) = 30, f(0) = 32)\ninline int clz32(uint32_t x) noexcept {\n#if defined(__GNUC__)\n  return x == 0 ? 32 : __builtin_clz(x);\n// #elif defined(_MSC_VER)\n//         return __lzcnt(x); // _BitScanReverse\n#else\n  union {\n    uint32_t i;\n    float f;\n  } data;\n  data.f = (float)x + 0.5;\n  return 158 - (data.i >> 23);\n#endif\n}\n// 末尾から続く0の個数\n// (f(2) = 62, f(0) = 64)\ninline int clz64(uint64_t x) noexcept {\n#if defined(__GNUC__)\n  return x == 0 ? 64 : __builtin_clzll(x);\n// #elif defined(_MSC_VER)\n//         return __lzcnt64(x);\n#else\n  union {\n    uint64_t i;\n    double f;\n  } datad;\n  datad.f = (double)x + 0.5;\n  return int(1086 - (datad.i >> 52));\n#endif\n}\n}  // namespace BitAlgo","lang":"cpp","path":"/src/cpp/implements/method/bitalgo.hpp","require":"#include <cstdint>\nusing namespace std;","references":["http://naoyat.hatenablog.jp/entry/2014/05/12/143650","http://www.nminoru.jp/~nminoru/programming/bitcount.html","http://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html","https://docs.microsoft.com/ja-jp/cpp/intrinsics/alphabetical-listing-of-intrinsic-functions"],"words":[],"verified":["乱数"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"浮動小数点の高速入出力","overview":"やるだけ","code":"template <typename T>\nvoid output_float(T var, int d) noexcept {\n  if (var < 0)\n    putchar_unlocked('-'), var = -var;\n  T i = floor(var);\n  printer << (long long)i;\n  var -= i;\n  putchar_unlocked('.');\n  while (d-- > 0 && var > 0) {\n    var *= 10.0;\n    int i = floor(var);\n    putchar_unlocked('0' + i);\n    var -= i;\n  }\n}","lang":"cpp","path":"/src/cpp/implements/method/io/stdio_float.hpp","require":"#include \"src/cpp/implements/datastructure/io/stdio.hpp\"","references":[],"words":["io"],"verified":["https://yukicoder.me/submissions/285892"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"時間計測用マクロ","overview":"ticで開始、tocで経過時間を返す。\ntic/tocという名称はmatlabで使われている。","code":"template <typename C = std::chrono::milliseconds>\nclass Timer {\n  std::chrono::system_clock::time_point tp_;\n\n public:\n  static inline auto now() { return std::chrono::system_clock::now(); }\n  inline void tic() { tp_ = now(); }\n  inline auto toc() const { return std::chrono::duration_cast<C>(now() - tp_).count(); }\n  inline Timer() : tp_(now()) {}\n};\ninline std::ostream& operator<<(std::ostream& o, const Timer<>& t) {\n  return o << (long long)t.toc();\n}","lang":"cpp","path":"/src/cpp/implements/method/time/tictoc.hpp","require":"#include <chrono>\n#include <ostream>","references":[],"words":["time","tic","toc"],"verified":[],"commits":[{"sha":"d491359b6dcb5858f42729b6824539b722c9936f","date":"2020-07-11 05:28:00 +0000","message":"Update tictoc as class"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"剰余演算付き整数型(llmod)","overview":"MODを法として計算する．\nMODを超える値の引き算を行う際に値を拾うと，負になることがある．\njustifyを呼ぶことで，llmod::val_を[0,MOD) の範囲に収める．","code":"class llmod {\n private:\n  using value_type = long long;\n  value_type val_;\n  // inline ll cut(ll v) const { return ((v%MOD) + MOD) % MOD; } // safe\n public:\n  static const value_type MOD = 1000000007;  // <=\n\n  llmod() : val_(0) {}\n  llmod(value_type num) : val_(((num % MOD) + MOD) % MOD) {}\n\n  inline operator value_type() const { return val_; }\n  inline value_type operator*() const { return val_; }\n  inline llmod& operator=(const llmod& lm) {\n    val_ = lm.val_;\n    return *this;\n  }\n  inline llmod& operator=(value_type v) {\n    val_ = (v) % MOD;\n    return *this;\n  }\n\n  inline llmod& operator+=(value_type v) {\n    val_ = (val_ + v) % MOD;\n    return *this;\n  }\n  inline llmod& operator+=(const llmod& l) {\n    val_ = (val_ + l.val_) % MOD;\n    return *this;\n  }\n  inline llmod& operator-=(value_type v) {\n    val_ = (val_ - v + MOD) % MOD;\n    return *this;\n  }\n  inline llmod& operator-=(const llmod& l) {\n    val_ = (val_ - l.val_ + MOD) % MOD;\n    return *this;\n  }\n  inline llmod& operator*=(value_type v) {\n    val_ = (val_ * v) % MOD;\n    return *this;\n  }\n  inline llmod& operator*=(const llmod& l) {\n    val_ = (val_ * l.val_) % MOD;\n    return *this;\n  }\n  inline llmod& operator++() {\n    val_ = (val_ + 1) % MOD;\n    return *this;\n  }\n  inline llmod operator++(int) {\n    llmod t = *this;\n    val_ = (val_ + 1) % MOD;\n    return t;\n  }\n  inline llmod& justify() {\n    val_ = ((val_ % MOD) + MOD) % MOD;\n    return *this;\n  }\n  friend llmod pow(llmod, long long);\n};\ninline std::ostream& operator<<(std::ostream& os, const llmod& l) {\n  os << *l;\n  return os;\n}\n\ninline llmod operator+(llmod t, const llmod& r) {\n  return t += r;\n}\ninline llmod operator-(llmod t, const llmod& r) {\n  return t -= r;\n}\ninline llmod operator*(llmod t, const llmod& r) {\n  return t *= r;\n}\n\n// MEMO : 逆元...pow(n,MD-2)\nllmod pow(llmod x, long long p) {\n  llmod::value_type y = 1;\n  llmod::value_type xval = x.justify();\n  while (0 < p) {\n    if (p & 1)\n      y = (xval * y) % llmod::MOD;\n    xval = (xval * xval) % llmod::MOD;\n    p >>= 1;\n  }\n  return llmod(y);\n}\n\ninline llmod& operator/=(llmod& l, const llmod& r) {\n  return l *= pow(r, llmod::MOD - 2);\n}","lang":"cpp","path":"/src/cpp/math/datastructure/llmod.hpp","require":"#include <ostream>","references":[],"words":[],"verified":["verify: https://yukicoder.me/submissions/183521","verify: https://yukicoder.me/submissions/183523"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"行列の基本操作","overview":"行列同士の+-*，スカラーとの+-*/，べき乗を実装","code":"template <typename T, typename Container = valarray<T>>\n// using T = double;\nclass Matrix {\n public:\n  size_t height_, width_;\n  Container data_;\n  Matrix(size_t height = 1, size_t width = 1)\n      : height_(height), width_(width), data_(height * width) {}\n  template <typename V>\n  Matrix(size_t height, size_t width, const V& data)\n      : height_(height), width_(width), data_(data) {}\n  Matrix(size_t height, size_t width, initializer_list<T> init)\n      : height_(height), width_(width), data_(init) {}\n\n  static Matrix<T> makeDiag(size_t n, T val) {\n    Matrix<T> mat(n, n);\n    for (size_t i = 0; i < n; ++i)\n      mat(i, i) = val;\n    return mat;\n  }\n\n  inline T& operator()(size_t y, size_t x) { return data_[y * width_ + x]; }\n  inline T operator()(size_t y, size_t x) const { return data_[y * width_ + x]; }\n  inline T& operator[](size_t i) { return data_[i]; }\n  inline T operator[](size_t i) const { return data_[i]; }\n  inline void resize(size_t h, size_t w) {\n    height_ = h;\n    width_ = w;\n    data_.resize(h * w);\n  }\n  inline void resize(size_t h, size_t w, T val) {\n    height_ = h;\n    width_ = w;\n    data_.resize(h * w, val);\n  }\n  inline void fill(T val) { data_ = val; }\n  void transpose() {\n    for (size_t y = 0; y < height_; ++y)\n      for (size_t x = y + 1; x < width_; ++x)\n        swap(operator()(y, x), operator()(x, y));\n  }\n  Matrix<T> transposed() const {\n    auto m = *this;\n    m.transpose();\n    return m;\n  }\n\n  void print(ostream& os) {\n    os << \"- - -\" << endl;  //  << setprecision(3)\n    for (size_t y = 0; y < height_; ++y) {\n      for (size_t x = 0; x < width_; ++x) {\n        os << setw(7) << operator()(y, x) << ' ';\n      }\n      os << endl;\n    }\n  }\n};\ntemplate <typename T>\ninline ostream& operator<<(ostream& os, Matrix<T> mat) {\n  mat.print(os);\n  return os;\n}\n\ntemplate <typename T>\nMatrix<T> multiply(const Matrix<T>& mat1, const Matrix<T>& mat2) {\n  assert(mat1.width_ == mat2.height_);\n  Matrix<T> result(mat1.height_, mat2.width_);\n  for (size_t i = 0; i < mat1.height_; ++i)\n    for (size_t j = 0; j < mat2.width_; ++j)\n      for (size_t k = 0; k < mat1.width_; ++k)\n        result(i, j) += mat1(i, k) * mat2(k, j);\n  return result;\n}\ntemplate <typename T, typename V>\nV multiply(const Matrix<T>& mat1, const V& vec2) {\n  assert(mat1.width_ == vec2.size());\n  V result(mat1.height_);\n  for (size_t i = 0, j; i < mat1.height_; ++i)\n    for (j = 0; j < mat1.width_; ++j)\n      result[i] += mat1(i, j) * vec2[j];\n  return result;\n}\n\ntemplate <typename T>\ninline Matrix<T>& operator+=(Matrix<T>& mat, T val) {\n  mat.data_ += val;\n  return mat;\n}\ntemplate <typename T>\ninline Matrix<T>& operator-=(Matrix<T>& mat, T val) {\n  mat.data_ -= val;\n  return mat;\n}\ntemplate <typename T>\ninline Matrix<T>& operator*=(Matrix<T>& mat, T val) {\n  mat.data_ *= val;\n  return mat;\n}\ntemplate <typename T>\ninline Matrix<T>& operator/=(Matrix<T>& mat, T val) {\n  mat.data_ /= val;\n  return mat;\n}\ntemplate <typename T>\ninline Matrix<T>& operator^=(Matrix<T>& mat, T val) {\n  mat.data_ ^= val;\n  return mat;\n}\ntemplate <typename T>\ninline Matrix<T>& operator+=(Matrix<T>& mat1, const Matrix<T>& mat2) {\n  mat1.data_ += mat2.data_;\n  return mat1;\n}\ntemplate <typename T>\ninline Matrix<T> operator+(Matrix<T>& mat1, const Matrix<T>& mat2) {\n  return Matrix<T>(mat1.height_, mat1.width_, mat1.data_ + mat2.data_);\n}\ntemplate <typename T>\ninline Matrix<T>& operator-=(Matrix<T>& mat1, const Matrix<T>& mat2) {\n  mat1.data_ -= mat2.data_;\n  return mat1;\n}\ntemplate <typename T>\ninline Matrix<T> operator-(Matrix<T>& mat1, const Matrix<T>& mat2) {\n  return Matrix<T>(mat1.height_, mat1.width_, mat1.data_ - mat2.data_);\n}\ntemplate <typename T>\ninline Matrix<T>& operator*=(Matrix<T>& mat1, const Matrix<T>& mat2) {\n  mat1 = multiply(mat1, mat2);\n  return mat1;\n}\ntemplate <typename T>\ninline Matrix<T> operator*(const Matrix<T>& mat1, const Matrix<T>& mat2) {\n  return multiply(mat1, mat2);\n}\ntemplate <typename T, typename V>\ninline V operator*(const Matrix<T>& mat1, const V& vec2) {\n  return multiply(mat1, vec2);\n}\n\ntemplate <typename T>\nMatrix<T> pow(Matrix<T> a, long long p) {\n  assert(a.height_ == a.width_);\n  auto b = Matrix<T>::makeDiag(a.height_, 1);\n  while (0 < p) {\n    if (p & 1)\n      b *= a;\n    a *= a;\n    p >>= 1;\n  }\n  return b;\n}","lang":"cpp","path":"/src/cpp/math/datastructure/matrix.hpp","require":"#include <cassert>\n#include <iomanip>\n#include <valarray>\n#include <ostream>\nusing namespace std;","references":[],"words":[],"verified":["https://beta.atcoder.jp/contests/arc027/submissions/3095831","など"],"commits":[{"sha":"dd5810ad20cb83c9b539c707878f939afd60bd6c","date":"2021-06-06 05:31:17 +0000","message":"refactor matrix"},{"sha":"ee9ee37696d5823dc64e84260563a06c5f8bdc87","date":"2021-06-05 23:58:02 +0000","message":"LU decomposition"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/math/method/matrix/lu.cpp"]},{"title":"組合せ計算(都度計算)","overview":"愚直に組合せの計算をする。","code":"// MEMO : inverse ...pow_md(n,MOD-2,MOD)\ntemplate <typename T>\nT pow_md(T x, T p, T mod) {\n  T y = 1;\n  x = x % mod;\n  for (; 0 < p; p >>= 1) {\n    if (p & 1)\n      y = y * x % mod;\n    x = x * x % mod;\n  }\n  return y;\n}\ntemplate <typename T>\nT fact_md(T n, T mod) {\n  T p = 1;\n  for (; 1 < n; p = (p * n--) % mod)\n    ;\n  return p;\n}\ntemplate <typename T>\nT nPr_md(T n, T r, T mod) {\n  T p = 1;\n  for (r = n - r; r < n; p = (p * n--) % mod)\n    ;\n  return p;\n}\ntemplate <typename T>\nT nCr_md(T n, T r, T mod) {\n  if (n < 0 || r < 0 || n < r)\n    return 0;\n  if (n / 2 < r)\n    return nCr_md(n, n - r, mod);\n  T num = 1, den = 1;\n  for (; 0 < r; --r, --n)\n    num = num * n % mod, den = den * r % mod;\n  return num * pow_md(den, mod - 2, mod) % mod;\n}\ntemplate <typename T>\ninline T nHr_md(T n, T r, T mod) {\n  if (n == 0 && r == 0)\n    return 1;\n  if (n == 0)\n    return 0;\n  return nCr_md(n - 1 + r, n - 1, mod);\n}\n\ntemplate <typename T>\nT nCr(T n, T r) {\n  if (n / 2 < r)\n    return nCr(n, n - r);\n  T p = 1;\n  for (T t = 1; t <= r; ++t)\n    p = p * (n - t + 1) / t;\n  return p;\n}\ntemplate <typename T>\ninline T nHr(T n, T r) {\n  if (n == 0 && r == 0)\n    return 1;\n  if (n == 0)\n    return 0;\n  return nCr(n - 1 + r, n - 1);\n}","lang":"cpp","path":"/src/cpp/math/method/combinatorics.hpp","require":"","references":[],"words":["pow","fact","ncr","npr","nhr","nck","npk","nhk"],"verified":[],"commits":[{"sha":"feccdb4f6b9c01d782c56d5ea3dfc75432f0b8d5","date":"2022-01-09 00:00:36 +0000","message":"add precalc combinatorics"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/math/method/ncr.cpp"]},{"title":"組合せ計算(完全前計算)","overview":"範囲内の conbination を全て事前に計算しておく。\n取得は O(1) 時間。","code":"template <int MaxN, long long Mod>\nclass nCrTable {\n  using value_type = long long;\n  value_type table_[MaxN][MaxN];  // nCr[r-1][n-1]; only r <= n\n\n  constexpr void build() {\n    for (int n = 0; n < MaxN; ++n)\n      table_[0][n] = (n + 1) % Mod;\n    for (int n = 1; n < MaxN; ++n) {\n      for (int r = 1; r <= n; ++r) {\n        table_[r][n] = (table_[r][n - 1] + table_[r - 1][n - 1]) % Mod;\n      }\n    }\n  }\n\n public:\n  constexpr nCrTable() { build(); }\n\n  constexpr value_type nCr(int n, int r) const {\n    return n < r ? 0\n                 : r > n ? nCr(n, n - r)\n                         : n == 0 && r == 0 ? 1 : n <= 0 ? 0 : r <= 0 ? 1 : table_[r - 1][n - 1];\n  }\n\n  constexpr value_type nHr(value_type n, value_type r) const {\n    if (n == 0 && r == 0)\n      return 1;\n    if (n == 0)\n      return 0;\n    return nCr(n - 1 + r, n - 1);\n  }\n};","lang":"cpp","path":"/src/cpp/math/method/combinatorics_precalc.hpp","require":"","references":[],"words":["ncr"," nck"],"verified":["https://atcoder.jp/contests/abc234/submissions/28419041"],"commits":[{"sha":"feccdb4f6b9c01d782c56d5ea3dfc75432f0b8d5","date":"2022-01-09 00:00:36 +0000","message":"add precalc combinatorics"}],"tested_by":["test/cpp/math/method/ncr.cpp"]},{"title":"組合せ計算(階乗前計算)","overview":"inverse, conbination, permutation, factorial を計算する。\nfactorial を事前に計算しメモすることで、conbination, permutation を高速に計算する。\n逆数の計算がボトルネックになっており、対数時間掛かる。","code":"template <int MaxN, long long Mod>\nclass Combinatorics {\n  using value_type = long long;\n  value_type fact_[MaxN + 1];\n  // value_type inv_[MaxN + 1]; // iranai\n\n public:\n  constexpr value_type pow(value_type x, value_type p) const {\n    value_type y = 1;\n    x = x % Mod;\n    for (; 0 < p; p >>= 1) {\n      if (p & 1)\n        y = y * x % Mod;\n      x = x * x % Mod;\n    }\n    return y;\n  }\n\n  constexpr Combinatorics() : fact_() {\n    fact_[0] = 1;\n    fact_[1] = 1;\n    for (value_type n = 2; n <= MaxN; ++n)\n      fact_[n] = (fact_[n - 1] * n) % Mod;\n    // inv_[Max] := calculate;\n    // iterate => inv_[i] = inv_[i+1] * (i+1) % Mod;\n  }\n  constexpr value_type fact(int n) const { return fact_[n]; }\n\n  constexpr value_type inv(value_type n) const { return pow(n, Mod - 2); }\n\n  constexpr value_type nPr(value_type n, value_type r) const {\n    if (r < 0 || n < r)\n      return 0;\n    return fact_[n] * inv(fact_[n - r]) % Mod;\n  }\n  constexpr value_type nCr(value_type n, value_type r) const {\n    if (n < r)\n      return 0;\n    return ((fact_[n] * inv(fact_[n - r]) % Mod) * inv(fact_[r])) % Mod;\n  }\n  constexpr value_type nHr(value_type n, value_type r) const {\n    if (n == 0 && r == 0)\n      return 1;\n    if (n == 0)\n      return 0;\n    return nCr(n - 1 + r, n - 1);\n  }\n};","lang":"cpp","path":"/src/cpp/math/method/combinatorics_static.hpp","require":"","references":[],"words":["fact","ncr","npr","nck","npk"],"verified":["https://yukicoder.me/submissions/286997"],"commits":[{"sha":"feccdb4f6b9c01d782c56d5ea3dfc75432f0b8d5","date":"2022-01-09 00:00:36 +0000","message":"add precalc combinatorics"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/math/method/ncr.cpp"]},{"title":"回転角","overview":"1周をmodで表現するような角度の単位系で，\n角度xから角度yへ向きを変えるとき，xに加算するべき値\n例えば，mod=360の時，\nx=45, y=135ならば，return=90\nx=45, y=315ならば，return=-90\nx=45, y=450ならば，return=45\nx=45, y=-45ならば，return=-90","code":"// 1周をmodで表現するような角度の単位系で，\n// 角度xから角度yへ向きを変えるとき，xに加算するべき値\ninline double diffangle(double x, double y, double mod) {\n  double a1 = fmod(y - x, mod), a2 = fmod(y - x + mod, mod), a3 = fmod(y - x - mod, mod);\n  return abs(a2) < abs(a1) ? (abs(a3) < abs(a2) ? a3 : a2) : (abs(a3) < abs(a1) ? a3 : a1);\n}","lang":"cpp","path":"/src/cpp/math/method/diffangle.hpp","require":"#include <cmath>\nusing namespace std;","references":[],"words":[],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/math/method/diffangle.cpp"]},{"title":"桁 dp","overview":"0 以上 h未満のうち 1 を含まない値の数を求める。\n桁 dpのたたき台として使う。","code":"class DigitDPState {\n public:\n  int total_[2];\n  DigitDPState() { fill(total_, total_ + 2, 0); }\n  static DigitDPState initialValue() {\n    DigitDPState s;\n    s.total_[0] = 1;\n    return s;\n  }\n  void apply(const DigitDPState& src, int digit_idx, int digit_num) {\n    // digit_idx: '上'からi番目\n    bool one = digit_num == 1;\n    total_[one] += src.total_[0];\n    total_[1] += src.total_[1];\n  }\n\n  int answer() const { return total_[1]; }\n};\n\nDigitDPState digit2dp(const long long h) {\n  const int m = 62;\n  // [上からi桁目][h未満かどうか]\n  static DigitDPState dp[m + 1][2];\n  fill(dp[0], dp[m + 1], DigitDPState());\n  dp[0][0] = DigitDPState::initialValue();\n  for (int i = 0; i < m; ++i) {\n    long long c = (h >> (m - i - 1)) & 1ll;\n    for (int lower_than = 0; lower_than < 2; ++lower_than) {\n      for (int v = 0; v < 2; ++v) {\n        if (lower_than || v <= c) {\n          dp[i + 1][lower_than || v < c].apply(dp[i][lower_than], i, v);\n        }\n      }\n    }\n  }\n  return dp[m][1];\n}\n\nDigitDPState digit10strdp(const string& h) {\n  const int km = 99;\n  // [上からi桁目][h未満かどうか]\n  static DigitDPState dp[km + 2][10];\n  const int m = int(h.size());\n  fill(dp[0], dp[km + 2], DigitDPState());\n  dp[0][0] = DigitDPState::initialValue();\n  for (int i = 0; i < m; ++i) {\n    long long c = h[i] - '0';\n    for (int lower_than = 0; lower_than < 2; ++lower_than) {\n      for (int v = 0; v < 10; ++v) {\n        if (lower_than || v <= c) {\n          dp[i + 1][lower_than || v < c].apply(dp[i][lower_than], i, v);\n        }\n      }\n    }\n  }\n  return dp[m][1];\n}","lang":"cpp","path":"/src/cpp/math/method/digitdp.hpp","require":"#include <string>\nusing namespace std;","references":[],"words":["keta"," ketadp"],"verified":[],"commits":[{"sha":"c16f2b6c97b3f088a1e534632e4bb735b0d8c9b3","date":"2021-11-23 12:57:39 +0000","message":"digit dp"}],"tested_by":[]},{"title":"最大公約数・最小公倍数","overview":"","code":"template <typename T>\ninline T gcd(T a, T b) {\n  while (b) {\n    T t = a % b;\n    a = b;\n    b = t;\n  }\n  return a;\n}\ntemplate <typename T>\ninline T lcm(T a, T b) {\n  return a * b / gcd(a, b);\n}","lang":"cpp","path":"/src/cpp/math/method/gcdlcm.hpp","require":"","references":[],"words":["gcd","lcm"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"一次方程式","overview":"焼きなましの近似式など．","code":"inline double lerp(double px, double py, double qx, double qy, double x) {\n  return py + (qy - py) * (x - px) / (qx - px);\n}\n// inline double lerp(const d2::Point& p, const d2::Point& q, double x) {\n//   return lerp(p.x, p.y, q.x, q.y, x);\n// }","lang":"cpp","path":"/src/cpp/math/method/lerp.hpp","require":"","references":[],"words":[],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"ガウス・ザイデル法","overview":"線形連立方程式を反復法で解く\n行列が対角優位でない場合は収束する保証は無い\n動作未検証","code":"template <typename T>\nMatrix<T> gauss_seidel(const Matrix<T>& aa, const Matrix<T>& bb, int iter = 100) {\n  assert(aa.height_ == aa.width_);\n  assert(aa.height_ == bb.height_);\n  assert(bb.width_ == 1);\n  auto n = bb.height_;\n  auto xx = bb;\n  for (int _ = iter; _ > 0; --iter) {\n    for (int i = 0; i < n; ++i) {\n      T total = 0;\n      for (int j = 0; j < n; ++j) {\n        if (j != i)\n          total += aa(i, j) * xx(j, 0);\n      }\n      xx(i, 0) = bb(i, 0) - total;\n      xx(i, 0) /= aa(i, i);\n    }\n  }\n  return xx;\n}","lang":"cpp","path":"/src/cpp/math/method/matrix/gauss_seidel.hpp","require":"#include \"src/cpp/math/datastructure/matrix.hpp\"\nusing namespace std;","references":[],"words":[],"verified":[],"commits":[{"sha":"94eedac2f24df71275ddd49853264b1248d59211","date":"2021-06-06 05:44:01 +0000","message":"fix dependencies"},{"sha":"7a0eeeff046c3d1aacf1108a04ace2f86af3fdc9","date":"2021-06-06 05:32:14 +0000","message":"add matrix applications"}],"tested_by":[]},{"title":"LU decomposition","overview":"LU 分解をする\ndeterminant (行列式)も計算する。\n0除算により失敗するときは空を返す。\ndet が 0 になるとき必ず decomposition が失敗するとは限らない。","code":"template <typename T>\nclass LUDecomposition {\n  const size_t n_;\n  vector<int> pivot_;\n  vector<T> elem_;\n  T det_;\n  LUDecomposition(size_t n) : n_(n), det_(1){};\n\n public:\n  bool valid() const { return n_ > 0; }\n  static LUDecomposition decompose(Matrix<T> mat) {\n    constexpr double eps = 1e-9;\n    // 引数matはコピー\n    assert(mat.height_ == mat.width_);\n    LUDecomposition lu(mat.height_);\n    const int n = mat.height_;\n\n    vector<int> pv(n);\n    lu.pivot_.reserve(n);\n    for (int i = 0; i < n; ++i)\n      pv[i] = i;\n\n    for (int i = 0; i < n; ++i) {\n      int p = i;\n      for (int j = i + 1; j < n; ++j)\n        if (abs(mat(pv[j], i)) > abs(mat(pv[p], i)))\n          p = j;\n      if (p != i) {\n        swap(pv[p], pv[i]);\n        lu.det_ *= -1;\n      }\n      lu.pivot_.push_back(p);\n\n      for (int j = i + 1; j < n; ++j) {\n        if (abs(mat(pv[i], i)) <= eps)\n          return LUDecomposition(0);\n        mat(pv[j], i) /= mat(pv[i], i);\n        for (int k = i + 1; k < n; ++k) {\n          mat(pv[j], k) -= mat(pv[i], k) * mat(pv[j], i);\n        }\n        lu.elem_.push_back(mat(pv[j], i));\n      }\n    }\n    for (int i = n - 1; i >= 0; --i) {\n      for (int j = i + 1; j < n; ++j)\n        lu.elem_.push_back(mat(pv[i], j));\n      auto t = mat(pv[i], i);\n      lu.elem_.push_back(t);\n      lu.det_ *= t;\n    }\n    return lu;\n  }\n  template <typename V>\n  V solve(V v) const {\n    assert(valid());\n    int c = 0;\n    const int n = n_;\n    for (int i = 0; i < n; ++i) {\n      swap(v[pivot_[i]], v[i]);\n      for (int j = i + 1; j < n; ++j) {\n        v[j] -= v[i] * elem_[c++];\n      }\n    }\n    for (int i = n - 1; i >= 0; --i) {\n      for (int j = i + 1; j < n; ++j)\n        v[i] -= v[j] * elem_[c++];\n      v[i] /= elem_[c++];\n    }\n    return v;\n  }\n  T det() const { return det_; }\n};","lang":"cpp","path":"/src/cpp/math/method/matrix/lu_decomposition.hpp","require":"#include \"src/cpp/math/datastructure/matrix.hpp\"\n#include <vector>\nusing namespace std;","references":[],"words":[],"verified":[],"commits":[{"sha":"94eedac2f24df71275ddd49853264b1248d59211","date":"2021-06-06 05:44:01 +0000","message":"fix dependencies"},{"sha":"dd5810ad20cb83c9b539c707878f939afd60bd6c","date":"2021-06-06 05:31:17 +0000","message":"refactor matrix"},{"sha":"ee9ee37696d5823dc64e84260563a06c5f8bdc87","date":"2021-06-05 23:58:02 +0000","message":"LU decomposition"}],"tested_by":["test/cpp/math/method/matrix/lu.cpp"]},{"title":"回文数の数え上げ","overview":"1以上val以下の整数で回文数が何個あるか数える．\nかなり甘い実装\n[TODO] 文字列に対しても実装する．","code":"// 1以上10^i-1以下の整数\nll _kaibunsu_dec(int keta) {\n  if (keta <= 1)\n    return 9;\n  ll r = 1;\n  for (int i = 0; i < (keta + 1) / 2; ++i)\n    r *= 10;\n  return r - (r / 10) + _kaibunsu_dec(--keta);\n}\n// dfs列挙\nll _kaibunsu_dfs(ll low, ll high, ll kcl, ll kch, ll num = 0) {\n  if (kcl > kch) {\n    return (low <= num && num <= high);\n  }\n  ll result = 0;\n  for (ll k = (kcl == 1); k <= 9; ++k) {\n    result += _kaibunsu_dfs(low, high, kcl * 10, kch / 10, num + kcl * k + kch * k * (kcl != kch));\n  }\n  return result;\n}\n\n// 1以上val以下の整数で回文数が何個あるか\nll kaibunsu(ll val) {\n  if (val <= 9)\n    return val;\n  ll dec = 1;\n  int keta = 0;\n  while (val >= dec) {\n    dec *= 10;\n    ++keta;\n  }\n  dec /= 10;\n\n  return _kaibunsu_dfs(dec, val, 1, dec) + _kaibunsu_dec(--keta);\n}\n\n// 以下愚直．デバッグ用\n// --------------------------------------------------------------------------------\n//\nbool iskaibun(int val) {\n  if (val <= 9)\n    return 1;\n  int t, u;\n  t = 0;\n  u = val;\n  while (u) {\n    t = (t * 10) + (u % 10);\n    u /= 10;\n  }\n  while (t) {\n    if (val % 10 != t % 10)\n      return false;\n    val /= 10;\n    t /= 10;\n  }\n  return true;\n}\nint hetakuso(int val) {\n  int count = 0;\n  while (val) {\n    if (iskaibun(val--))\n      ++count;\n  }\n  return count;\n}","lang":"cpp","path":"/src/cpp/math/method/palindrome_number.hpp","require":"using ll = long long;","references":[],"words":[],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"約数列挙","overview":"約数を列挙してvectorに格納する。\nソートはされていない。","code":"std::vector<long long> generateDivisor(long long n) {\n  std::vector<long long> divs;\n  for (long long d = 1; d <= n / d; ++d) {\n    if (n / d * d == n) {\n      divs.push_back(d);\n      divs.push_back(n / d);\n    }\n  }\n  if (divs.size() >= 2 && divs[divs.size() - 1] == divs[divs.size() - 2])\n    divs.pop_back();\n  return divs;\n}","lang":"cpp","path":"/src/cpp/math/method/prime/generatedivisor.hpp","require":"#include <vector>","references":[],"words":["divisor"],"verified":["10..20"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"Miller窶迭abin primality test","overview":"素数判定する．\n2^63でも素数判定可能だが，__int128型を使う．","code":"ll powm_strict(ll x, ll p, ll mod = 1000000007ll) {\n  using ll128 = __int128_t;\n  ll y = 1;\n  x = x % mod;\n  while (0 < p) {\n    if ((p & 1) == 1)\n      y = (ll)((((ll128)y) * x) % mod);\n    x = (ll)((((ll128)x) * x) % mod);\n    p /= 2;\n  }\n  return y;\n}\n\n// Miller窶迭abin primality test\nbool isprime_MillerRabin(ll val) {\n  using ll128 = __int128_t;\n  static const ll test[12] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};\n  if (val <= 1 || (val & 1) == 0)\n    return val == 2;\n  for (auto t : test)\n    if (val % t == 0)\n      return val == t;\n  if (val < test[11] * test[11])\n    return true;\n  ll d = val - 1, s = 0;\n  while (!(d & 1)) {\n    ++s;\n    d >>= 1;\n  }  // d*2**s\n  for (auto t : test) {\n    ll z = powm_strict(t, d, val);\n    if (z == 1 || z == val - 1)\n      continue;\n    for (ll r = 1; r < s; ++r) {\n      z = (ll)((ll128)(z)*z % val);\n      if (z == val - 1)\n        goto l_isprime_mr_ct;\n    }\n    return false;\n  l_isprime_mr_ct:;\n  }\n  return true;\n}","lang":"cpp","path":"/src/cpp/math/method/prime/millerrabin.hpp","require":"using ll = long long;","references":["https://qiita.com/gushwell/items/ff9ed83ba55350aaa369","https://yukicoder.me/submissions/210680"],"words":[],"verified":["https://yukicoder.me/submissions/210977"],"commits":[{"sha":"075a829593f0893ad65cd6db299956b3de1cbdcd","date":"2021-09-04 22:17:15 +0000","message":"fix build error"},{"sha":"8e4bb0ba3e3a4bc7e390cf994e2ebc4ec105ed00","date":"2021-09-04 17:01:17 +0000","message":"Add a heavy prime class"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/math/method/prime/prime.cpp"]},{"title":"エラトステネスの篩","overview":"エラトステネスの篩\n生成する素数の数を静的に決めてしまう．\nコンパイルが異様に遅くなるので(compile TLE)，\n競技プログラミングではconstexprを付けないほうが無難\n\nPrimeList は IsPrime を引数に取って生成することができる。\nメモリはより消費するが、事前情報なしと比較してずっと速いのでこちらを使うべき。\nPrimeList のサイズも IsPrime のサイズもそれぞれ適切な値を指定する必要があり、面倒。\n例えば、IsPrime<200117> に対して PrimeList<17994>、\nIsPrime<1000117> に対して PrimeList<78505> など。","code":"template <int Max = 2000>\nclass IsPrime {\n public:                        // friend PrimeList\n  std::bitset<Max / 2 + 1> d_;  // 1,3,5,...\n\n public:\n  // constexpr IsPrime() : d_() {\n  IsPrime() : d_() {\n    d_[0] = 1;\n    for (int i = 3; i * i <= Max; i += 2) {\n      if (d_[i / 2] == 0) {\n        for (int j = i * i; j <= Max; j += i) {  // i*i\n          if (j & 1)\n            d_.set(j / 2);\n        }\n      }\n    }\n    for (int i = 0; i <= Max / 2; ++i)\n      d_[i] = !d_[i];\n  }\n  constexpr inline bool operator[](int x) const {\n    return (x <= 2) ? (x == 2) : (x & 1) ? d_[x / 2] : false;\n  }\n};\n\ntemplate <int Cnt = 2000>\nclass PrimeList {\n  int d_[Cnt];\n\n public:\n  // constexpr PrimeListC() : d_() {\n  PrimeList() : d_() {\n    // std::clog << \"we should construct with IsPrimeC\" << std::endl;\n    int n = 1;\n    d_[0] = 2;\n    for (int x = 3; n < Cnt; ++x) {\n      bool f = true;\n      for (int i = 0; d_[i] * d_[i] <= x; ++i)\n        if (x / d_[i] * d_[i] == x) {\n          f = false;\n          break;\n        }\n      if (f)\n        d_[n++] = x;\n    }\n  }\n  template <int M>\n  PrimeList(const IsPrime<M>& is_prime) : d_() {\n    int p = 0;\n    d_[p++] = 2;\n    for (int x = 1; x < M / 2; ++x) {\n      if (is_prime.d_[x]) {\n        d_[p++] = x * 2 + 1;\n      }\n    }\n  }\n  constexpr inline int operator[](int x) const { return d_[x]; }\n  template <int _Cnt>\n  class iterator {\n    const PrimeList<_Cnt>& pl;\n    int ptr = 0;\n\n   public:\n    constexpr iterator(const decltype(pl)& _pl, int _ptr = 0) : pl(_pl), ptr(_ptr) {}\n    constexpr int operator*() const { return pl[ptr]; }\n    constexpr iterator<_Cnt>& operator++() {\n      ptr++;\n      return *this;\n    }  // prefix\n    constexpr inline bool operator!=(const iterator<_Cnt>& it) const {\n      return ptr != it.ptr ? !(_Cnt < ptr && _Cnt < it.ptr) : false;\n    }\n    constexpr inline bool operator==(const iterator<_Cnt>& it) const {\n      return ptr != it.ptr ? (_Cnt < ptr && _Cnt < it.ptr) : true;\n    }\n  };\n  constexpr PrimeList::iterator<Cnt> begin() const { return PrimeList::iterator<Cnt>(*this, 0); }\n  constexpr PrimeList::iterator<Cnt> end() const { return PrimeList::iterator<Cnt>(*this, Cnt); }\n\n  std::map<long long, int> division(long long number) const {\n    std::map<long long, int> div;\n    for (int i = 0; number > 1 && i < Cnt; ++i) {\n      long long p = d_[i];\n      int c = 0;\n      while (number / p * p == number)\n        ++c, number /= p;\n      if (c > 0)\n        div[p] = c;\n    }\n    return div;\n  }\n};","lang":"cpp","path":"/src/cpp/math/method/prime/primesieve.hpp","require":"#include <map>\n#include <bitset>","references":[],"words":[],"verified":["[TODO]"],"commits":[{"sha":"075a829593f0893ad65cd6db299956b3de1cbdcd","date":"2021-09-04 22:17:15 +0000","message":"fix build error"},{"sha":"f3a76660e05733025a90fc7dd81b904683e879ae","date":"2021-09-04 08:02:36 +0000","message":"refactor by Github Actions"},{"sha":"8e4bb0ba3e3a4bc7e390cf994e2ebc4ec105ed00","date":"2021-09-04 17:01:17 +0000","message":"Add a heavy prime class"},{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/math/method/prime/prime.cpp"]},{"title":"素数（エラトステネスの篩）","overview":"エラトステネスの篩\n判定する素数の上限を静的に決める。\n素数判定、素数列挙、素因数分解が可能。\nメモリを (2*Max)*4byte ぐらい消費するが、競技ならこれで十分","code":"// template <int Max = 2000>\ntemplate <int Max>\nclass Prime {\n  int d_[Max + 1];\n  int n_;\n  int li_[std::max(10000, Max / 10)];\n\n public:\n  constexpr Prime() : d_(), n_(), li_() {\n    d_[0] = d_[1] = 0;\n    for (int i = 2; i <= Max; i += 2) {\n      d_[i] = 2;\n    }\n    n_ = 1;\n    li_[0] = 2;\n    int p = 3;\n    for (p = 3; p * p <= Max; p += 2) {\n      if (d_[p] != 0)\n        continue;\n      d_[p] = p;\n      li_[n_++] = p;\n      for (int j = p * p; j <= Max; j += p) {  // i*i\n        d_[j] = p;\n      }\n    }\n    for (; p <= Max; p += 2) {\n      if (d_[p] != 0)\n        continue;\n      d_[p] = p;\n      li_[n_++] = p;\n    }\n  }\n  constexpr inline bool isPrime(int x) const { return (x >= 2) && (x == 2 || d_[x] == x); }\n  constexpr inline int operator[](int i) const { return li_[i]; }\n\n  class iterator {\n    const Prime& pl;\n    int ptr = 0;\n\n   public:\n    constexpr iterator(const decltype(pl)& _pl, int _ptr = 0) : pl(_pl), ptr(_ptr) {}\n    constexpr int operator*() const { return pl[ptr]; }\n    constexpr iterator& operator++() {\n      ptr++;\n      return *this;\n    }  // prefix\n    constexpr inline bool operator!=(const iterator& it) const {\n      return ptr != it.ptr ? !(pl.n_ <= ptr && pl.n_ <= it.ptr) : false;\n    }\n    constexpr inline bool operator==(const iterator& it) const {\n      return ptr != it.ptr ? (pl.n_ <= ptr && pl.n_ <= it.ptr) : true;\n    }\n  };\n  constexpr Prime::iterator begin() const { return Prime::iterator(*this, 0); }\n  constexpr Prime::iterator end() const { return Prime::iterator(*this, n_); }\n\n  std::map<int, int> division(long long number) const {\n    std::map<int, int> div;\n    // for large number\n    for (int i = 0; (long long)Max <= number && i < n_; ++i) {\n      long long p = li_[i];\n      int c = 0;\n      while (number / p * p == number)\n        ++c, number /= p;\n      if (c > 0)\n        div[(int)p] = c;\n    }\n    if ((long long)Max <= number) {\n      // guess it's prime number.\n      div[number] += 1;\n      return div;\n    }\n    while (number >= 2) {\n      long long p = d_[number];\n      int c = 0;\n      while (number / p * p == number)\n        ++c, number /= p;\n      if (c > 0)\n        div[(int)p] = c;\n    }\n    return div;\n  }\n};","lang":"cpp","path":"/src/cpp/math/method/prime/util_prime_sieve.hpp","require":"#include <map>","references":[],"words":[],"verified":["https://yukicoder.me/submissions/696483"],"commits":[{"sha":"8e4bb0ba3e3a4bc7e390cf994e2ebc4ec105ed00","date":"2021-09-04 17:01:17 +0000","message":"Add a heavy prime class"}],"tested_by":["test/cpp/math/method/prime/prime.cpp"]},{"title":"高速ゼータ変換（メビウス逆変換）","overview":"ゼータ変換は，集合関数f(2^S)=Nを\ng(X) = sum{X⊆Y}(f(Y))\nに変換する．\nプログラミング上では，f,gは多くの場合，\n関数ではなく配列として表現される．\n高速ゼータ変換は，愚直に計算すると4^Nになるところ，\nN2^Nで計算するシンプルなDPである．","code":"using value_t = int;\nvector<value_t> zeta_transform(int n, vector<value_t> func) {\n  for (int i = 0; i < n; ++i)\n    for (int b = 0; b < (1 << n); ++b)\n      if (~b & (1 << i))\n        func[b] += func[b | (1 << i)];\n  return func;\n}\n\nusing value_t = int;\nvector<value_t> mebius_transform(int n, vector<value_t> func) {\n  for (int i = 0; i < n; ++i)\n    for (int b = 0; b < (1 << n); ++b)\n      if (~b & (1 << i))\n        func[b] -= func[b | (1 << i)];\n  return func;\n}","lang":"cpp","path":"/src/cpp/math/method/zeta.hpp","require":"#include <vector>\nusing namespace std;","references":["https://topcoder.g.hatena.ne.jp/iwiwi/20120422/1335065228","https://naoyat.hatenablog.jp/entry/zeta-moebius","講義資料"],"words":["zeta"," mebius"],"verified":["unverified!!!"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"簡易線形計画問題ソルバー[TODO]","overview":"等式形の線形計画問題を単体法で解く．","code":"class EasyLP {\n public:\n  const int dimension;\n  // 左辺\n  vector<vector<double>> equation;\n  // 定数項\n  vector<double> offset;\n  // 目的関数\n  vector<double> objective;\n  // 求まった目的関数の値\n  double objective_c;\n\n  EasyLP(int n) : dimension(n), objective(n) {}\n\n  // 目的関数を最小化する．\n  // 式の情報は書き換えられる．\n  double minimize() {\n    while (true) {\n      // printTableau();\n      // 目的関数の値を減少させることができる変数を探す\n      int idx = 0;\n      {\n        double val = objective[0];\n        for (int i = 1; i < dimension; ++i) {\n          if (val > objective[i]) {\n            val = objective[i];\n            idx = i;\n          }\n        }\n        // 無いなら最適解が得られた\n        if (val >= 0)\n          break;\n      }\n\n      // どの程度まで増やせば良いだろうか\n      int target = -1;\n      {\n        double val, lim = 0;\n        for (int i = 0; i < equation.size(); ++i) {\n          if (equation[i][idx] == 0)\n            continue;  // 0除算防止\n          val = offset[i] / equation[i][idx];\n          if (0 < val && (target == -1 || val < lim)) {\n            lim = val;\n            target = i;\n          }\n        }\n      };\n      if (target == -1)\n        break;\n      {\n        // ピボット係数\n        double p = equation[target][idx];\n\n        // ピボット係数を p で除算\n        for (double& e : equation[target])\n          e /= p;\n        offset[target] /= p;\n\n        // ピボット列の掃き出し\n        for (int i = 0; i < equation.size(); ++i) {\n          if (i == target)\n            continue;\n\n          double d = equation[i][idx];\n          for (int j = 0; j < dimension; j++) {\n            if (j != idx)\n              equation[i][j] -= d * equation[target][j];\n            else\n              equation[i][j] = 0;\n          }\n\n          offset[i] -= d * offset[target];\n        }\n        {\n          double d = objective[idx];\n          for (int j = 0; j < dimension; j++) {\n            if (j != idx)\n              objective[j] -= d * equation[target][j];\n            else\n              objective[j] = 0;\n          }\n\n          objective_c += d * offset[target];\n        }\n      }\n    }\n    return -objective_c;\n  }\n\n  void printTableau() {\n    for (int i = 0; i < equation.size(); ++i) {\n      for (double a : equation[i]) {\n        printf(\" %7.2f\", a);\n      }\n      printf(\" | %7.2f\\n\", offset[i]);\n    }\n    for (int i = equation.size(); 0 <= i; --i) {\n      printf(\"---------\");\n    }\n    printf(\"\\n\");\n    for (double a : objective) {\n      printf(\" %7.2f\", a);\n    }\n    printf(\" %7.2f\\n#####\\n\", objective_c);\n  }\n};\n\nint main() {\n  {\n      // EasyLP lp(5);\n      // lp.equation.push_back({ 60.0, 40.0,  1.0,  0.0, 0.0 }); lp.offset.push_back(3800.0);\n      // lp.equation.push_back({ 20.0, 30.0,  0.0,  1.0, 0.0 }); lp.offset.push_back(2100.0);\n      // lp.equation.push_back({ 20.0, 10.0,  0.0,  0.0, 1.0 }); lp.offset.push_back(1200.0);\n      // lp.objective = { -400.0, -300.0, 0.0, 0.0, 0.0 };   lp.objective_c = 0.0;\n      //\n      // printf(\"%.7f\\n\", lp.minimize());\n  } {\n    EasyLP lp(6);\n    lp.equation.push_back({5.0, 1.0, 2.0, 1.0, 0.0, 0.0});\n    lp.offset.push_back(20.0);\n    lp.equation.push_back({2.0, 2.0, 6.0, 0.0, 1.0, 0.0});\n    lp.offset.push_back(30.0);\n    lp.equation.push_back({2.0, 6.0, 4.0, 0.0, 0.0, 1.0});\n    lp.offset.push_back(40.0);\n    lp.objective = {-1.0, -1.0, -1.0, 0.0, 0.0};\n    lp.objective_c = 0.0;\n\n    printf(\"%.7f\\n\", lp.minimize());\n  }\n  return 0;\n}","lang":"cpp","path":"/src/cpp/math/solver/lp.hpp","require":"#include <vector>\n#include <cstdio>\nusing namespace std;","references":[],"words":[],"verified":["http://www.fujilab.dnj.ynu.ac.jp/lecture/system2.pdf","https://yukicoder.me/submissions/213095","http://dic.nicovideo.jp/a/%E7%B7%9A%E5%BD%A2%E8%A8%88%E7%94%BB%E5%95%8F%E9%A1%8C","[TODO]"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"決定木","overview":"決定木","code":"template <typename input_t, typename output_t>\nclass DecisionTree {\n  using comparator_t = function<bool(input_t)>;\n\n  bool leaf_;\n  comparator_t comparator_;\n  output_t out_;\n  unique_ptr<DecisionTree> childlen_[2];\n\n public:\n  DecisionTree() : leaf_(true), comparator_(nullptr) {}\n\n  inline DecisionTree& operator[](int i) { return *childlen_[i]; }\n  inline bool leaf() { return leaf_; }\n\n  inline void generate_leaf(output_t out) {\n    leaf_ = true;\n    childlen_[0].release();\n    childlen_[1].release();\n    out_ = out;\n  }\n\n  inline void generate_branch(comparator_t comparator) {\n    leaf_ = false;\n    childlen_[0].reset(new DecisionTree());\n    childlen_[1].reset(new DecisionTree());\n    comparator_ = comparator;\n  }\n\n  output_t eval(input_t val) { return leaf() ? out_ : childlen_[comparator_(val)]->eval(val); }\n};","lang":"cpp","path":"/src/cpp/predictor/datastructure/decisiontree.hpp","require":"#include <memory>\n#include <functional>\nusing namespace std;","references":[],"words":[],"verified":[],"commits":[{"sha":"1db90a85af02c8464666d2d8a6bb0273e2b2903d","date":"2021-11-13 10:39:18 +0000","message":"rename directory"}],"tested_by":[]},{"title":"線形式の最小二乗法","overview":"n変数一次方程式で表されるモデルを仮定する。\n各変数に掛かる係数が不明であるとする。\nq回の計測を行うと、各変数に掛かる係数を変数とする\nq個の方程式からなるn変数連立一次方程式ができる。\nこの記事の関数は、上の連立方程式を入力として、\n係数を推測するための連立一次方程式を出力する。","code":"pair<Matrix<double>, Matrix<double>> linearLeastSquare(const Matrix<double>& X,\n                                                       const Matrix<double>& Y) {\n  assert(Y.width_ == 1);\n  assert(Y.height_ == X.width_);\n  auto bb = X.transposed();\n  bb *= Y;\n  auto aa = X.transposed();\n  aa *= X;\n  return make_pair(move(aa), move(bb));\n}","lang":"cpp","path":"/src/cpp/predictor/datastructure/linear_least_square.hpp","require":"#include \"src/cpp/math/datastructure/matrix.hpp\"\nusing namespace std;","references":[],"words":[],"verified":[],"commits":[{"sha":"1db90a85af02c8464666d2d8a6bb0273e2b2903d","date":"2021-11-13 10:39:18 +0000","message":"rename directory"}],"tested_by":[]},{"title":"禁止可能な一様分布の乱数","overview":"一部の整数を取り出せないようにできるような，一様分布の乱数を生成する．\ninvalidな引数を与えた場合の動作は未定義．\n空間計算量 O(size) に注意する．","code":"class RandChooser {\n  int size;\n  int left_size;\n  vector<int> swapper;\n  vector<int> unswapper;\n\n public:\n  RandChooser(int s) : size(s), left_size(s), swapper(s), unswapper(s) {\n    for (int i = 0; i < s; ++i) {\n      swapper[i] = unswapper[i] = i;\n    }\n  }\n  inline int left() { return left_size; }\n\n  template <typename RANDOM>\n  inline int operator()(RANDOM& rd) {\n    uniform_int_distribution<int> rand_int(0, left_size - 1);\n    return swapper[rand_int(rd)];\n  }\n\n  inline int disable(int idx) {\n    swap(swapper[unswapper[idx]], swapper[left_size - 1]);\n    unswapper[swapper[unswapper[idx]]] = unswapper[idx];\n    return --left_size;\n  }\n};","lang":"cpp","path":"/src/cpp/random/datastructure/rand_chooser.hpp","require":"#include <vector>\n#include <random>\nusing namespace std;","references":[],"words":[],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"XorShift","overview":"高速な乱数生成器．64bit版を実装した．\n一部のrandomヘッダの関数(uniform_int_distribution等)にも使える．","code":"struct XorShift {\n  using result_type = uint64_t;\n  result_type x_;\n  XorShift(result_type x = 88172645463325252ull) : x_(x){};\n  static constexpr inline result_type min() { return 0ull; }\n  static constexpr inline result_type max() { return numeric_limits<result_type>::max(); }\n  inline result_type operator()() {\n    x_ ^= x_ << 7;\n    return x_ ^= x_ >> 9;\n  }\n  inline void discard(unsigned long long z) {\n    while (z--)\n      operator()();\n  }\n};\nXorShift randdev;","lang":"cpp","path":"/src/cpp/random/datastructure/xorshift.hpp","require":"#include <limits>\n#include <cstdint>\nusing namespace std;","references":["https://ja.wikipedia.org/wiki/Xorshift"],"words":[],"verified":["目視"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"1からnまでの乱数をm個重複せずランダムに選ぶ","overview":"1からnまでの乱数をm個重複せずランダムに選ぶ．\nこのアルゴリズムは空間計算量O(m)，時間計算量O(m)で済む（ハッシュ操作をO(1)とする）．\n簡単な実装方法として\n- 重複しないm個を取り出すまで乱数を引く (n>>m なら衝突しにくいので高速)\n- iotaしてshuffleしてeraseする（空間O(n)，時間O(n)）\nがあるが，計算量的には両者のどちらよりも優れていることが分かる．\nm/nの比でアルゴリズムを選択するハイブリッド実装でも良さそうである．\n\n[TODO] rand_int の除去","code":"//\nvoid pick_multirand(int n, int m, vector<int>& out) {\n  out.clear();\n  unordered_map<int, int> memo;\n  if (n < m)\n    m = n;\n  for (int low = 1; low <= m; ++low) {\n    int r = rand_int(low, n);\n    if (!memo[r]) {\n      out.emplace_back(r);\n    } else {\n      out.emplace_back(memo[r]);\n    }\n    int e = memo[low];\n    memo[r] = e ? e : low;\n  }\n}","lang":"cpp","path":"/src/cpp/random/method/rand_multi.hpp","require":"#include <vector>\n#include <unordered_map>\nusing namespace std;\n// rand_int の実装\nint rand_int(int, int);","references":[],"words":[],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"二分探索","overview":"境界を探す．func(x)==trueとなるxの中で，最も小さなxを探す．\nテンプレートを使うと，ラムダを引数に持てなくなるので，typedefで何とかしてある．[TODO]\nfunctionでwrapすれば済むだけの話だが，競技では面倒なので．","code":"using bsearch_t = long long;\nbsearch_t binarySearch(bsearch_t false_val, bsearch_t true_val, function<bool(bsearch_t)> func) {\n  while (abs(true_val - false_val) > 1) {\n    bsearch_t c = (true_val + false_val) / 2;\n    (func(c) ? true_val : false_val) = c;\n  }\n  return true_val;\n}","lang":"cpp","path":"/src/cpp/search/method/bin_search.hpp","require":"#include <functional>\nusing namespace std;","references":["めぐる式"],"words":[],"verified":["ABC020-C"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"二分探索（実数）","overview":"境界を探す．func(x)==trueとなるxの中で，最も小さなxを探す．\nテンプレートを使うと，ラムダを引数に持てなくなるので，typedefで何とかしてある．[TODO]\nfunctionでwrapすれば済むだけの話だが，競技では面倒なので．","code":"const double EPS = 1e-9;\ndouble binarySearchReal(double false_value, double true_value, function<bool(double)> func) {\n  for (int i = 0; i < 99; ++i) {\n    double mid = (true_value + false_value) / 2;\n    (func(mid) ? true_value : false_value) = mid;\n  }\n  return true_value;\n}","lang":"cpp","path":"/src/cpp/search/method/bin_search_real.hpp","require":"#include <functional>\nusing namespace std;","references":[],"words":[],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"並び替えないソート","overview":"- i番目の要素はソート後何番目の要素になるか？\n- ソート後i番目の要素はソート前何番目の要素だったか？\nを求める","code":"// ソートしてi番目の値は 元々idx[i]番目の値\n// 元々i番目の値は ソートするとidxr[i]番目の値\ntemplate <typename ITER>\nvoid sortedIndex(const ITER begin, const ITER end, vector<int>& idx, vector<int>& idxr) {\n  size_t n = end - begin;\n  idx.resize(n);\n  idxr.resize(n);\n  for (int i = 0; i < n; ++i)\n    idx[i] = i;\n  sort(idx.begin(), idx.end(), [&begin](int l, int r) { return begin[l] < begin[r]; });\n  for (int i = 0; i < n; ++i)\n    idxr[idx[i]] = i;\n}","lang":"cpp","path":"/src/cpp/search/method/sort.hpp","require":"#include <vector>\nusing namespace std;","references":[],"words":[],"verified":["atcoder"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"三分探索","overview":"minimize y = func(x)．ただし，func(x)は下に凸な関数．\nテンプレートを使うと，ラムダを引数に持てなくなるので，typedefで何とかしてある．[TODO]\nfunctionでwrapすれば済むだけの話だが，競技では面倒なので．","code":"using tsearch_t = long long;\nusing fval_t = long long;\ntsearch_t ternarySearchMinimize(tsearch_t left, tsearch_t right, function<fval_t(tsearch_t)> func) {\n  for (int lop = 0; lop < 60; ++lop) {\n    tsearch_t l = right - (2 * right - 2 * left) / 3;\n    tsearch_t r = right - (right - left) / 3;\n    fval_t lval = func(l);\n    fval_t rval = func(r);\n\n    if (lval <= rval)\n      right = r;\n    else\n      left = l;\n\n    if (right - left <= 2)\n      break;\n  }\n  fval_t best = func(left);\n  tsearch_t bestidx = left;\n  for (tsearch_t t = left + 1; t <= right; ++t) {\n    tsearch_t f = func(t);\n    if (best > f) {\n      best = f;\n      bestidx = t;\n    }\n  }\n  return bestidx;\n}","lang":"cpp","path":"/src/cpp/search/method/tri_search.hpp","require":"#include <functional>\nusing namespace std;","references":[],"words":[],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/search/method/tri_search.cpp"]},{"title":"manacher(一括回文判定)","overview":"manacher\ncount_num() はO(|S|)で動作するので注意 [TODO]","code":"class Manacher {\n public:\n  vector<int> radius_;\n\n  Manacher() {}\n  Manacher(const string& str) { build(str); }\n\n  void build(const string& str) {\n    int length = str.size() * 2 - 1;\n    radius_.resize(length);\n\n    int c = 0;\n    for (int i = 0; i < length; i++) {\n      int l = c - (i - c);\n      if (i + radius_[l] < c + radius_[c]) {\n        radius_[i] = radius_[l];\n      } else {\n        int j = c + radius_[c] - i;\n        for (; i - j >= 0 && i + j < length; j++) {\n          if (((i ^ j) & 1) == 1)\n            continue;\n          if (str[(i - j) / 2] != str[(i + j) / 2])\n            break;\n        }\n        radius_[i] = j;\n        c = i;\n      }\n    }\n  }\n\n  inline int operator[](int idx) const { return radius_[idx]; }\n  inline size_t size() const { return radius_.size(); }\n\n  // 部分文字列str[left..right]が回文かどうか．計算量O(1)\n  // left,rightに指定するインデックスは，基の文字列のインデックスを指定する．\n  inline bool operator()(int left, int right) { return radius_[left + right] > right - left; }\n\n  // 回文の個数を求める．\n  long long count_num() {\n    long long r = 0;\n    for (auto it = radius_.begin(); it < radius_.end(); ++it, ++it) {\n      r += (*it + 1ll) / 2ll;\n    }\n    for (auto it = radius_.begin() + 1; it < radius_.end(); ++it, ++it) {\n      r += (*it) / 2ll;\n    }\n    return r;\n  }\n\n  // void print(const string& str) {\n  //   for (int i = 0; i < str.size(); i++) {\n  //     cout << str[i] << \" \";\n  //   }\n  //   cout << endl;\n  //   for (int i = 0; i < radius_.size(); i++) {\n  //     cout << radius_[i];\n  //   }\n  //   cout << endl;\n  // }\n};","lang":"cpp","path":"/src/cpp/string/datastructure/manacher.hpp","require":"#include <vector>\n#include <string>\nusing namespace std;","references":["http://snuke.hatenablog.com/entry/2014/12/02/235837","https://yukicoder.me/problems/no/464/editorial"],"words":[],"verified":["https://yukicoder.me/submissions/139334"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/string/datastructure/manacher.cpp"]},{"title":"正規表現[TODO]","overview":"簡単に書いてみた．TODOリストとして追加．","code":"struct RegExp {\n  template <typename T>\n  struct Range {\n    T begin, tail;\n    inline Range(T _begin, T _end) : begin(_begin), tail(_end) {}\n    inline explicit Range(T _single) : begin(_single), tail(_single) {}\n    inline Range() : begin(0), tail(0) {}\n\n    inline bool cover(T x) const noexcept { return begin <= x && x <= tail; }\n  };\n\n  struct CharSet {\n    vector<pair<Range<char>, bool>> ranges_;\n    inline CharSet() {}\n    inline CharSet(const CharSet& cs) : ranges_(cs.ranges_) {}\n    inline CharSet(CharSet&& cs) : ranges_(move(cs.ranges_)) {}\n    inline explicit CharSet(const Range<char>& r) { push(r); }\n    inline explicit CharSet(char c) { push(Range<char>(c)); }\n\n    void push(const Range<char>& r, bool negative = false) { ranges_.emplace_back(r, negative); }\n    inline bool cover(char c) const {\n      return any_of(ranges_.begin(), ranges_.end(), [c](const pair<Range<char>, bool>& p) {\n        return p.second ^ (p.first.cover(c));\n      });\n    }\n    static const CharSet Any;\n  };\n\n  enum struct ERep {\n    J1,  // 1個\n    M1,  // 1個以上\n    M0,  // 0個以上\n    L1,  // 1個以下\n  };\n\n  struct Node {\n    CharSet chr;\n    ERep type;\n    inline explicit Node(CharSet&& _chr, ERep _type = ERep::J1) : chr(_chr), type(_type) {}\n    inline explicit Node(const CharSet& _chr, ERep _type = ERep::J1) : chr(_chr), type(_type) {}\n    inline bool match(char c) const { return chr.cover(c); }\n    // 0文字の一致を認めるか\n    inline bool isOk0() const noexcept { return type == ERep::L1 || type == ERep::M0; }\n    // 2文字以上の一致を認めるか\n    inline bool isOkMany() const noexcept { return type == ERep::M1 || type == ERep::M0; }\n  };\n\n  vector<Node> pattern_;  // TODO: Link NFA\n\n  tuple<size_t, CharSet> parseCharSet(const string& rawPattern, size_t startPtr = 0) {\n    int escape = 0;\n\n    CharSet charset;\n    bool enable_range = false;\n    bool enable_holderLastChr = false;\n    char holderLastChr;\n    bool negative = false;\n\n    for (size_t i = startPtr; i < rawPattern.size(); ++i) {\n      char c = rawPattern[i];\n      char cL = rawPattern[i - 1];  // C++11\n      char cP = rawPattern[i + 1];\n\n      if (escape == 0 && c == ']') {\n        assert(enable_range == false);\n        if (enable_holderLastChr)  // charが余っているならばcharsetに入れる\n          charset.push(Range<char>(holderLastChr));\n        return make_tuple(i, charset);\n      } else if (escape == 0 && c == '-') {\n        assert(enable_holderLastChr == true);\n        assert(enable_range == false);\n        enable_range = true;\n      } else if (escape == 0 && c == '^') {\n        assert(negative == false);\n        negative = true;\n      } else if (escape == 0 && c == '/') {\n        escape = 1;\n      } else {\n        if (enable_range) {\n          assert(enable_holderLastChr == true);\n          if (holderLastChr > c)\n            charset.push(Range<char>(c, holderLastChr));\n          else\n            charset.push(Range<char>(holderLastChr, c));\n          enable_holderLastChr = false;\n          enable_range = false;\n          negative = false;\n        } else {\n          if (enable_holderLastChr)  // charが余っているならばcharsetに入れる\n            charset.push(Range<char>(holderLastChr), negative), negative = false;\n          enable_holderLastChr = true;\n          holderLastChr = c;  // holderLastChrに値を入れておく\n        }\n        escape = 0;\n      }\n    }\n    abort();\n  }\n\n  int parse(const string& rawPattern, size_t startPtr = 0) {\n    int escape = 0;\n\n    for (size_t ptr = startPtr; ptr < rawPattern.size(); ++ptr) {\n      char c = rawPattern[ptr];\n      // char cL = rawPattern[ptr - 1]; // C++11\n      // char cP = rawPattern[ptr + 1];\n\n      // open\n      if (escape == 1) {\n        // escaped\n        // 特定の文字として解釈\n        pattern_.emplace_back(CharSet(c));\n        escape = 0;\n      } else if (c == '+') {\n        // 1つ以上\n        if (pattern_.empty())\n          abort();\n        pattern_.back().type = ERep::M1;  // TODO:\n      } else if (c == '*') {\n        // 0個以上\n        if (pattern_.empty())\n          abort();\n        pattern_.back().type = ERep::M0;\n      } else if (c == '?') {\n        // 0か1つ\n        if (pattern_.empty())\n          abort();\n        pattern_.back().type = ERep::L1;\n      } else if (c == '.') {\n        // 任意の文字\n        pattern_.emplace_back(CharSet::Any);\n      } else if (c == '[') {\n        // 特定の範囲の文字\n        auto ret = parseCharSet(rawPattern, ptr + 1);\n        ptr = get<0>(ret);\n        pattern_.emplace_back(move(get<1>(ret)));\n      } else if (c == '/') {\n        // escape\n        escape = 1;\n      } else {\n        // 特定の文字\n        pattern_.emplace_back(CharSet(c));\n      }\n    }\n  }\n\n  RegExp(const string& rawPattern) { parse(rawPattern); }\n\n  bool match(const string& text) {\n    vector<bool> dp1(pattern_.size() + 1);  // current dp\n    vector<bool> dp2(pattern_.size() + 1);  // next dp\n    dp1[0] = true;\n\n    for (char c : text) {\n      for (size_t pi = 0; pi < pattern_.size(); ++pi) {\n        if (!dp1[pi])\n          continue;\n\n        if (pattern_[pi].match(c)) {\n          dp2[pi + 1ull] = true;  // 次のパターンに進む\n          if (pattern_[pi].isOkMany())\n            dp2[pi] = true;  // 次のパターンに進まなくても良い\n        }\n        if (pattern_[pi].isOk0())\n          dp1[pi + 1ull] = true;  // 今のパターンをスキップする\n      }\n      dp1.swap(dp2);\n      fill(dp2.begin(), dp2.end(), false);\n    }\n\n    for (size_t pi = 0; pi < pattern_.size(); ++pi) {\n      if (!dp1[pi])\n        continue;\n      if (pattern_[pi].isOk0())\n        dp1[pi + 1ull] = true;  // 今のパターンをスキップする\n    }\n\n    return dp1[pattern_.size()];\n  }\n};\nconst RegExp::CharSet RegExp::CharSet::Any =\n    RegExp::CharSet(RegExp::Range<char>(numeric_limits<char>::min(), numeric_limits<char>::max()));\n\nvoid test() {\n  {\n    RegExp r(\"a.c\");\n    assert(r.match(\"abc\") == true);\n    assert(r.match(\"acc\") == true);\n    assert(r.match(\"abb\") == false);\n    assert(r.match(\"acd\") == false);\n    assert(r.match(\"ac\") == false);\n    assert(r.match(\"\") == false);\n  }\n  {\n    RegExp r(\"a+c\");\n    assert(r.match(\"aac\") == true);\n    assert(r.match(\"ac\") == true);\n    assert(r.match(\"c\") == false);\n    assert(r.match(\"acc\") == false);\n    assert(r.match(\"a\") == false);\n  }\n  {\n    RegExp r(\"a*c\");\n    assert(r.match(\"aac\") == true);\n    assert(r.match(\"ac\") == true);\n    assert(r.match(\"c\") == true);\n    assert(r.match(\"acc\") == false);\n    assert(r.match(\"a\") == false);\n  }\n  {\n    RegExp r(\"ab?c\");\n    assert(r.match(\"abc\") == true);\n    assert(r.match(\"ac\") == true);\n    assert(r.match(\"adc\") == false);\n    assert(r.match(\"acc\") == false);\n  }\n  {\n    RegExp r(\".\");\n    assert(r.match(\"a\") == true);\n    assert(r.match(\"z\") == true);\n    assert(r.match(\"aa\") == false);\n    assert(r.match(\"zz\") == false);\n    assert(r.match(\"\") == false);\n  }\n  {\n    RegExp r(\"..\");\n    assert(r.match(\"aa\") == true);\n    assert(r.match(\"zz\") == true);\n    assert(r.match(\"a\") == false);\n    assert(r.match(\"zzz\") == false);\n  }\n  {\n    RegExp r(\".*foo.*\");\n    assert(r.match(\"barfoobaz\") == true);\n    assert(r.match(\"foobaz\") == true);\n    assert(r.match(\"foo\") == true);\n    assert(r.match(\"fo\") == false);\n    assert(r.match(\"\") == false);\n  }\n  {\n    RegExp r(\".+a.*b.?\");\n    assert(r.match(\"xaybz\") == true);\n    assert(r.match(\"xxayybz\") == true);\n    assert(r.match(\"xwxab\") == true);\n    assert(r.match(\"aaab\") == true);\n    assert(r.match(\"aab\") == true);\n    assert(r.match(\"aabbbbb\") == true);\n    assert(r.match(\"abababa\") == true);\n    assert(r.match(\"abababaa\") == false);\n    assert(r.match(\"ab\") == false);\n    assert(r.match(\"abb\") == false);\n    assert(r.match(\"a\") == false);\n    assert(r.match(\"b\") == false);\n  }\n  {\n    RegExp r(\"b[b-dx]d\");\n    assert(r.match(\"bbd\") == true);\n    assert(r.match(\"bcd\") == true);\n    assert(r.match(\"bdd\") == true);\n    assert(r.match(\"bxd\") == true);\n    assert(r.match(\"bad\") == false);\n    assert(r.match(\"bed\") == false);\n    assert(r.match(\"ddd\") == false);\n    assert(r.match(\"bbb\") == false);\n  }\n  {\n    RegExp r(\"[a-z][a-z0-9]*\");\n    assert(r.match(\"regexp\") == true);\n    assert(r.match(\"mt19937\") == true);\n    assert(r.match(\"destr0yer\") == true);\n    assert(r.match(\"1024\") == false);\n    assert(r.match(\"200ok\") == false);\n    assert(r.match(\"a\") == true);\n    assert(r.match(\"1\") == false);\n  }\n  {\n    RegExp r(\"/[[o/-x]+/]\");\n    assert(r.match(\"[o-x]\") == true);\n    assert(r.match(\"[oo]\") == true);\n    assert(r.match(\"[-]\") == true);\n    assert(r.match(\"[]\") == false);\n    assert(r.match(\"[xx\") == false);\n    assert(r.match(\"[\") == false);\n    assert(r.match(\"[[ooxx]\") == false);\n  }\n\n  // cout << \"ok\" << endl;\n}","lang":"cpp","path":"/src/cpp/string/datastructure/regexp.hpp","require":"#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n#include <tuple>\nusing namespace std;","references":[],"words":[],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"ローリングハッシュ","overview":"連続した部分文字列のハッシュをO(N)で求める．\n2つのハッシュで撃墜をなるべく避ける．","code":"class RollingHash {\n public:\n  using rh_t = unsigned long long;\n\n private:\n  static const rh_t MD_1 = (rh_t)(1e9 + 21);\n  static const rh_t PW = (rh_t)(1e9 + 7);\n  static vector<rh_t> pow_table__[2];\n\n public:\n  vector<rh_t> hashes_[2];\n\n  RollingHash() {}\n  RollingHash(const string& s) { build(s); }\n\n  inline pair<rh_t, rh_t> operator()(int begin, int end) {\n    return pair<rh_t, rh_t>(\n        (hashes_[0][end] - hashes_[0][begin] * pow_table__[0][end - begin]),\n        (hashes_[1][end] - (hashes_[1][begin] * pow_table__[1][end - begin]) % MD_1 + MD_1) % MD_1);\n  }\n\n  void build_pow(size_t size) {\n    ++size;\n    if (pow_table__[0].size() < size) {\n      pow_table__[0].reserve(size);\n      pow_table__[1].reserve(size);\n      if (pow_table__[0].empty())\n        pow_table__[0].push_back(1), pow_table__[1].push_back(1);\n      for (size_t i = pow_table__[0].size(); i < size; ++i) {\n        pow_table__[0].push_back(pow_table__[0].back() * PW);\n        pow_table__[1].push_back(pow_table__[1].back() * PW % MD_1);\n      }\n    }\n  }\n  void build(const string& src) {\n    size_t m = src.size() + 1;\n    build_pow(m);\n    hashes_[0].resize(m);\n    hashes_[1].resize(m);\n    hashes_[0][0] = hashes_[1][0] = 0;\n    for (size_t i = 1; i < m; ++i) {\n      rh_t c = src[i - 1];\n      hashes_[0][i] = hashes_[0][i - 1] * PW + c;\n      hashes_[1][i] = (hashes_[1][i - 1] * PW + c) % MD_1;\n    }\n  }\n};\nvector<RollingHash::rh_t> RollingHash::pow_table__[2];","lang":"cpp","path":"/src/cpp/string/datastructure/rollinghash.hpp","require":"#include <vector>\n#include <string>\nusing namespace std;","references":["プログラミングチャレンジブック"],"words":[],"verified":["csaで使ったはず"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/string/datastructure/rollinghash.cpp"]},{"title":"SuffixArray","overview":"","code":"class SuffixArray {\n  const char* str;\n  int size;\n  vector<const char*> sa;\n  string keeper;\n\n public:\n  SuffixArray() {}\n  SuffixArray(const string& d) {\n    str = d.c_str();\n    size = d.size();\n    assert(str[size] == 0);\n    ++size;\n  }\n  SuffixArray(string&& d) {\n    keeper = move(d);\n    str = keeper.c_str();\n    size = keeper.size();\n    assert(str[size] == 0);\n    ++size;\n  }\n\n  void build() {\n    const int Alpha = 128;\n    vector<int> sfx(size);                  // suffix array permutation\n    vector<int> div(size);                  // division\n    vector<int> cnt(max(size + 1, Alpha));  // counter\n\n    for (int i = 0; i < size; ++i)\n      cnt[str[i]] += 1;\n    for (int i = 1; i < Alpha; ++i)\n      cnt[i] += cnt[i - 1];\n    for (int i = 0; i < size; ++i)\n      sfx[--cnt[str[i]]] = i;\n\n    div[sfx[0]] = 0;\n    for (int i = 1; i < size; ++i)\n      div[sfx[i]] = div[sfx[i - 1]] + (str[sfx[i - 1]] < str[sfx[i]]);\n\n    for (int d = 1; d < size; d *= 2) {\n      vector<int> sfx2(size);\n      {\n        fill(cnt.begin(), cnt.end(), 0);\n        for (int i = 0; i < size; ++i)\n          cnt[div[(sfx[i] - d + size) % size]] += 1;\n        for (int i = 1; i <= size; ++i)\n          cnt[i] += cnt[i - 1];\n        for (int i = size - 1; 0 <= i; --i) {\n          sfx2[--cnt[div[(sfx[i] - d + size) % size]]] = (sfx[i] - d + size) % size;\n        }\n      }\n      sfx2.swap(sfx);\n      vector<int> div2(size);\n      div2[sfx[0]] = 0;\n      int acc = 0;\n      for (int i = 1; i < size; ++i) {\n        pair<int, int> curr = {div[sfx[i]], div[(sfx[i] + d) % size]};\n        pair<int, int> prev = {div[sfx[i - 1]], div[(sfx[i - 1] + d) % size]};\n        div2[sfx[i]] = div2[sfx[i - 1]] + (curr != prev);\n      }\n      div2.swap(div);\n    }\n    sa.resize(size);\n    for (int i = 0; i < size; ++i)\n      sa[i] = str + sfx[i];\n  }\n\n  pair<bool, pair<int, int>> find(const string& keyword) {\n    auto n = keyword.size();\n\n    if (n == 0)\n      return make_pair(false, make_pair(0, -1));\n\n    int low = 0;\n    int high = sa.size() - 1;\n\n    for (int i = 0; i < n; ++i) {\n      int ng, ok;\n      ng = low - 1;\n      ok = high;\n      while (ok - ng > 1) {\n        int m = (ok + ng) / 2;\n        if (keyword[i] <= *(sa[m] + i))\n          ok = m;\n        else\n          ng = m;\n      }\n      low = ok;\n\n      ng = high + 1;\n      ok = low;\n      while (ng - ok > 1) {\n        int m = (ok + ng) / 2;\n        if (keyword[i] >= *(sa[m] + i))\n          ok = m;\n        else\n          ng = m;\n      }\n      high = ok;\n\n      if (low > high || keyword[i] != *(sa[low] + i) || keyword[i] != *(sa[high] + i))\n        return make_pair(false, make_pair(0, -1));\n    }\n    return make_pair(true, make_pair(low, high));\n  }\n\n  inline int foundToIdx(int found) { return sa[found] - str; }\n};","lang":"cpp","path":"/src/cpp/string/datastructure/suffixarray.hpp","require":"#include <vector>\n#include <string>\n#include <cassert>\nusing namespace std;","references":["蟻本","http://wk1080id.hatenablog.com/entry/2018/12/25/005926v"],"words":[],"verified":["tested"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":["test/cpp/string/datastructure/suffixarray.cpp"]},{"title":"trie tree","overview":"文字列(あるいは配列)の集合を管理する．\nmap<string,int> みたいなイメージ","code":"template <typename TKEY = char, typename TVAL = int>\nstruct TrieTree {\n  TVAL value;\n  map<TKEY, TrieTree> trie;\n  TrieTree(TVAL v) : value(v) {}\n  TrieTree() : value(0) {}\n\n  template <typename IBEGIN, typename IEND>\n  TVAL& operator()(IBEGIN begin, IEND end) {\n    auto begin_succ = begin;\n    return (begin == end) ? value : trie[*begin](++begin_succ, end);\n  }\n};","lang":"cpp","path":"/src/cpp/string/datastructure/trie.hpp","require":"#include <map>\nusing namespace std;","references":["プログラミングチャレンジブック"],"words":[],"verified":["(旧) : http://yukicoder.me/submissions/123054"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"Wavelet Tree (Wavelet Matrix)","overview":"試作品．メソッドは殆ど実装していない．\n完備辞書の代わりにBITを使っている","code":"class Wavelet {\n public:\n  const int kChrSizeLg = 5;\n  const int kChrSize = 1 << kChrSizeLg;\n\n  const int size_;\n  vector<Bitree<int>> tree_;\n  vector<int> zerocnt_;\n\n  void build(const vector<char>& _raw) {\n    tree_.reserve(kChrSizeLg);\n    for (int i = 0; i < kChrSizeLg; ++i)\n      tree_.emplace_back(size_);\n    zerocnt_.resize(kChrSizeLg);\n\n    vector<char> stac = _raw;\n    vector<char> stac0, stac1;\n    stac0.reserve(size_);\n    stac1.reserve(size_);\n\n    for (int d = 0; d < kChrSizeLg; ++d) {\n      stac0.clear();\n      stac1.clear();\n      int cnt = 0;\n      for (char c : stac) {\n        int bit = (c & (1 << d)) >> d;\n        tree_[d].add(cnt + 1, bit);\n        if (bit)\n          stac1.push_back(c);\n        else\n          stac0.push_back(c);\n        ++cnt;\n      }\n      stac.clear();\n      stac.insert(stac.end(), stac0.begin(), stac0.end());\n      stac.insert(stac.end(), stac1.begin(), stac1.end());\n      zerocnt_[d] = stac0.size();\n    }\n  }\n\n  // void dump() {\n  //   for (int d = 0; d < kChrSizeLg; ++d) {\n  //     for (int i = 0; i < size_; ++i)\n  //       cout << tree_[d].get(i + 1);\n  //     cout << endl;\n  //   }\n  // }\n\n  Wavelet(const vector<char>& _raw) : size_(_raw.size()) { build(_raw); }\n\n  char get(int i) {\n    char data = 0;\n    for (int d = 0; d < kChrSizeLg; ++d) {\n      char b = tree_[d].get(i + 1);  // 0 or 1\n      data |= b << d;\n      i = b ? zerocnt_[d] + tree_[d].sum(i) : i - tree_[d].sum(i);\n    }\n    return data;\n  }\n\n  // [0,i)の文字cの出現回数\n  int rank(int i, char c) { return 0; }  // TODO:\n};","lang":"cpp","path":"/src/cpp/string/datastructure/wavelet.hpp","require":"#include <vector>\n#include <string>\n#include \"src/cpp/container/likermq/bit.hpp\"\nusing namespace std;","references":["岡之原大輔，高速文字列解析の世界，岩波書店．"],"words":[],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"回文判定","overview":"コピペと手打ちどっちが速いかな","code":"bool iskaibun(const string& str) {\n  for (int left = 0, right = (int)str.size() - 1; left < right; ++left, --right)\n    if (str[left] != str[right])\n      return false;\n  return true;\n}","lang":"cpp","path":"/src/cpp/string/method/palindrome.hpp","require":"#include <string>\nusing namespace std;","references":[],"words":[],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"ece0b45f2a0f37c91fece075aebbcf5b39cfd902","date":"2020-06-24 00:23:28 +0000","message":"rename cpp to hpp (#62)"}],"tested_by":[]},{"title":"幾何(点と線と円)","overview":"点と線と円に関するクラスとメソッド．\n距離と交点のみ．","code":"class Point {\n    /**\n     * \n     * @param {number} x \n     * @param {number} y \n     */\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * \n     * @param {number} t\n     */\n    multiply(t) {\n        return new Point(t * this.x, t * this.y);\n    }\n    /**\n     * \n     * @param {Point} p \n     */\n    plus(p) {\n        return new Point(this.x + p.x, this.y + p.y);\n    }\n    /**\n     * \n     * @param {Point} p \n     */\n    minus(p) {\n        return new Point(this.x - p.x, this.y - p.y);\n    }\n    /**\n     * \n     * @param {Point} p \n     */\n    distance(p) {\n        return Math.hypot(this.x - p.x, this.y - p.y);\n    }\n    /**\n     * x*x+y*y\n     */\n    square() {\n        return this.x * this.x + this.y * this.y;\n    }\n    /**\n     * \n     * @param {Point} p \n     */\n    dot(p) {\n        return this.x * p.x + this.y * p.y;\n    }\n    /**\n     * \n     * @param {Point} p \n     */\n    cross(p) {\n        return this.x * p.y - p.x * this.y;\n    }\n    /**\n     * \n     * @param {Point} p \n     */\n    cos(p) {\n        return (this.x * p.x + this.y * p.y)\n            / (Math.sqrt(this.x * this.x + this.y * this.y)\n                * Math.sqrt(p.x * p.x + p.y * p.y));\n    }\n}\n\n\nclass Circle { // eslint-disable-line no-unused-vars\n    /**\n     * \n     * @param {Point} p 中心点\n     * @param {number} rad 半径\n     */\n    constructor(p, rad) {\n        this.p = p;\n        this.rad = rad;\n    }\n\n    /**\n     * 直線と円の交点\n     * 交点が存在しない場合，[null,null]\n     * @param {Line} li \n     * @returns {[Point,Point]}\n     */\n    intersectionLine(li) {\n        return li.intersectionCircle(this);\n    }\n\n    /**\n     * 円と円の交点\n     * 交点が存在しない場合，[null,null]\n     * @param {Circle} ci \n     * @returns {[Point,Point]}\n     */\n    intersectionCircle(ci) {\n        const a = (this.p.square() - ci.p.square() - this.rad * this.rad + ci.rad * ci.rad) / 2;\n        return Line.equation(this.p.x - ci.p.x, this.p.y - ci.p.y, -a).intersectionCircle(this);\n    }\n}\n\n\nclass Line {\n    /**\n     * pos+t*vel を満たす直線．\n     * |vel| < EPS の時，0除算が発生することがある．\n     * @param {Point} pos\n     * @param {Point} vel\n     */\n    constructor(pos, vel) {\n        this.pos = pos;\n        this.vel = vel;\n    }\n    /**\n     * p1,p2を通る直線を生成\n     * p1.distance(p2) < EPS の時，0除算が発生することがある．\n     * @param {Point} p1 \n     * @param {Point} p2 \n     */\n    static path(p1, p2) {\n        const lp = p1, lv = p2.plus(p1.multiply(-1));\n        return new Line(lp, lv);\n    }\n\n    /**\n     * ax + by + c = 0 を満たす直線を生成\n     * |a| < EPS, |b| < EPS の時，0除算が発生する．\n     * @param {number} a \n     * @param {number} b \n     * @param {number} c \n     */\n    static equation(a, b, c) {\n        if (Math.abs(a) < Math.abs(b))\n            return new Line(new Point(0, -c / b), new Point(b, -a));\n        else\n            return new Line(new Point(-c / a, 0), new Point(b, -a));\n    }\n\n    /**\n     * t をパラメータとする直線上の点 pos+t*vel を求める．\n     * @param {number} t \n     */\n    point(t) {\n        return this.pos.plus(this.vel.multiply(t));\n    }\n\n    /**\n     * 点と直線の距離\n     * 直線上で点に最寄りの座標\n     * @param {Point} p\n     * @returns {{distance: number, nearest: Point}}\n     */\n    distancePoint(p) {\n        const lp = this.pos, lv = this.vel;\n\n        const den = lv.square();\n\n        return {\n            distance: Math.abs(lv.cross(p.minus(lp))) / Math.sqrt(den),\n            nearest: this.point(lv.dot(p.minus(lp)) / den)\n        };\n    }\n\n    /**\n     * 直線と円の交点\n     * 交点が存在しない場合，[null,null]\n     * @param {Circle} ci \n     * @returns {[Point,Point]}\n     */\n    intersectionCircle(ci) {\n        const lp = this.pos, lv = this.vel;\n\n        const d = lv.x * (ci.p.y - lp.y) - lv.y * (ci.p.x - lp.x);\n        const den = lv.x * lv.x + lv.y * lv.y;\n        const det = (den) * ci.rad * ci.rad - d * d;\n        if (det < 0) return [null, null];\n\n        const num = lv.x * (ci.p.x - lp.x) + lv.y * (ci.p.y - lp.y);\n        const detsq = Math.sqrt(det);\n        return [this.point((num + detsq) / den), this.point((num - detsq) / den)];\n    }\n\n    /**\n     * 直線と直線の交点\n     * 存在しない場合はnull\n     * @param {Line} li\n     * @returns {Point} \n     */\n    intersectionLine(li) {\n        const num = -this.vel.cross(li.pos.minus(this.pos));\n        const den = this.vel.cross(li.vel);\n        if (den == 0) return null;\n        return li.point(num / den);\n    }\n\n}","lang":"javascript","path":"/src/javascript/2d/2d.js","require":"","references":["http://shogo82148.github.io/homepage/memo/geometry/circle-cross.html"],"words":["kika","vector"],"verified":["目視"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"eaae2fef0042b25dafbb8a49162264fa97631277","date":"2019-09-16 21:07:52 +0000","message":"Implement webdoc tools (#36)"},{"sha":"a095450ca16d4b7c8f44004cadf4f6766ff56c30","date":"2019-08-26 01:20:19 +0000","message":"Apply refactoring"},{"sha":"44871db3d7c0b4c4388e029b229bdaa62e03895f","date":"2019-02-22 20:27:39 +0000","message":"minor changes"},{"sha":"d5ca092221648a59677fda209971c2341d4cc8de","date":"2018-05-13 21:41:00 +0000","message":"幾何"}],"tested_by":[]},{"title":"組合せ・順列列挙","overview":"ジェネレータを返す．ジェネレータは，組合せ・順列を列挙する．\nruby の Array#permutation，Array#combination に似た挙動．\n高等なアルゴリズムは使わず，雑な再帰で実装．","code":"Array.prototype.permutation = function* () {\n    if (this.length <= 0) return;\n    const n = this.length;\n    const this_ = this;\n    function* dfs(p) {\n        if (p.length == n) {\n            yield p.map(i => this_[i]);\n            return;\n        }\n        for (let i = 0; i < n; ++i) {\n            if (p.some(e => e == i)) continue;\n            p.push(i);\n            for (let r of dfs(p)) yield r;\n            p.pop();\n        }\n    }\n    for (let r of dfs([])) yield r;\n};\n\nArray.prototype.combination = function* (k) {\n    if (this.length <= 0 || (this.length < k)) return;\n    const n = this.length;\n    const this_ = this;\n    function* dfs(c, idx) {\n        if (n - idx < k - c.length) return;\n        if (idx == n) {\n            if (c.length == k)\n                yield c.map(i => this_[i]);\n            return;\n        }\n        if (k > c.length) {\n            c.push(idx);\n            for (let r of dfs(c, idx + 1)) yield r;\n            c.pop();\n        }\n        for (let r of dfs(c, idx + 1)) yield r;\n    }\n    for (let r of dfs([], 0)) yield r;\n};","lang":"javascript","path":"/src/javascript/extends/array/combperm.js","require":"","references":["https://qiita.com/komaji504/items/62a0f8ea43053e90555a"],"words":["shuffle"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"a095450ca16d4b7c8f44004cadf4f6766ff56c30","date":"2019-08-26 01:20:19 +0000","message":"Apply refactoring"},{"sha":"a7120ad84c4d0e0fdce2949fcaca4c0c081d91a7","date":"2019-01-03 23:54:48 +0000","message":"shuffle, combiperm"}],"tested_by":[]},{"title":"shuffle (Fisher窶添ates)","overview":"配列をshuffleする\n配列はコピーされず書き換えられる","code":"Array.prototype.shuffle = function () {\n    for (let i = this.length - 1; i > 0; --i) {\n        let r = Math.floor(Math.random() * (i + 1));\n        let t = this[i];\n        this[i] = this[r];\n        this[r] = t;\n    }\n    return this;\n};","lang":"javascript","path":"/src/javascript/extends/array/shuffle.js","require":"","references":["https://qiita.com/komaji504/items/62a0f8ea43053e90555a"],"words":["shuffle"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"a7120ad84c4d0e0fdce2949fcaca4c0c081d91a7","date":"2019-01-03 23:54:48 +0000","message":"shuffle, combiperm"}],"tested_by":[]},{"title":"さいころの回転","overview":"無理やり感のある実装\n\nさいころのローカル座標軸はvecsで取得出来る．\nこれを使って，1はどの方向を向いているか？等の情報が得られる．\n\nvecsはフィールドですが，readonlyとして扱ってね．","code":"class Dice { // eslint-disable-line no-unused-vars\n\n    constructor() {\n        this.vecs = [\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ];\n    }\n\n    /**\n     * @param {1|-1} sign 1 or -1\n     */\n    rotateZ(sign = 1) {\n        sign = sign < 0 ? -1 : 1;\n        for (let i = 0; i < 3; ++i)\n            this.vecs[i] = [sign * this.vecs[i][1], -sign * this.vecs[i][0], this.vecs[i][2]];\n    }\n\n    /**\n     * @param {1|-1} sign 1 or -1\n     */\n    rotateY(sign = 1) {\n        sign = sign < 0 ? -1 : 1;\n        for (let i = 0; i < 3; ++i)\n            this.vecs[i] = [sign * this.vecs[i][2], this.vecs[i][1], -sign * this.vecs[i][0]];\n    }\n\n    /**\n     * @param {1|-1} sign 1 or -1\n     */\n    rotateX(sign = 1) {\n        sign = sign < 0 ? -1 : 1;\n        for (let i = 0; i < 3; ++i)\n            this.vecs[i] = [this.vecs[i][0], sign * this.vecs[i][2], -sign * this.vecs[i][1]];\n    }\n}","lang":"javascript","path":"/src/javascript/game/dice.js","require":"","references":[],"words":["dice","sai"],"verified":["todo"],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"eaae2fef0042b25dafbb8a49162264fa97631277","date":"2019-09-16 21:07:52 +0000","message":"Implement webdoc tools (#36)"},{"sha":"d4d78738f55dd6151299791ae3a686df62f545f7","date":"2018-10-25 12:38:25 +0000","message":"ファイル移動など"}],"tested_by":[]},{"title":"ccw(進行方向)","overview":"二次元座標上の点を表す構造体\na -> b -> c と進むときの方向を判定する。","code":"def ccw(a,b,c)\n  ax,ay = a\n  bx,by = by\n  cx,cy = c\n  bx -= ax\n  by -= ay\n  cx -= ax\n  cy -= ay\n  bx*cy - by*cx > 0 ?  1 : # 半時計周り\n  bx*cy - by*cx < 0 ? -1 : # 時計回り\n  bx*cx + by*cy < 0 ?  2 :       # c - a - b\n  bx*bx+by*by < cx*cx+cy*cy ? -2 # a - b - c\n                            :  0 # a - c - b\nend","lang":"ruby","path":"/src/ruby/2d/method/ccw.rb","require":"","references":["http://www.prefield.com/algorithm/geometry/ccw.html"],"words":["ccw"],"verified":[],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"1678cfb56f12f41c1677646f212f7ea0bb685681","date":"2019-11-12 12:35:34 +0000","message":"ccw"}],"tested_by":[]},{"title":"GCD,LCM,組み合わせ計算","overview":"todo","code":"def pow_md(x, w, mod)\n  y = 1\n  x = x%mod\n  while 0 < w\n      y = (y*x) % mod if w.odd?\n      x = (x*x) % mod\n      w >>= 1\n  end\n  y\nend\n\n\ndef nCr_md(n, r, mod)\n  return nCr_md(n, n-r, mod) if n/2 < r\n  num,den = 1,1\n  1.upto(r) do |i|\n      num = num*(n-i+1) % mod\n      den = den*i % mod\n  end\n  num * pow_md(den, mod-2, mod) % mod\nend","lang":"ruby","path":"/src/ruby/math/method/math_utils.ruby","require":"","references":["thanks."],"words":["math"],"verified":["problem."],"commits":[{"sha":"1703cfd5937491aed191816ef0f1d37908630f24","date":"2020-06-28 03:09:01 +0000","message":"Add include guard and Modify document formats (#64)"},{"sha":"6f691d253fac7a3d0ec73a20e05ff7652a3815c7","date":"2018-07-28 00:10:19 +0000","message":"rubymath"},{"sha":"d5ba50c7f084ce0cb615eaf406e4b869f4b28a66","date":"2018-04-17 01:07:01 +0000","message":"Revert \"Revert \"sinatradoc仮作成\"\""},{"sha":"bfa24b06e03b99ddd88c1e596ed02b63d5f5f968","date":"2018-04-17 01:05:50 +0000","message":"Revert \"sinatradoc仮作成\""},{"sha":"8c957ea22e2e264348e226acbb87dbd54892ea98","date":"2018-04-17 01:03:37 +0000","message":"sinatradoc仮作成"}],"tested_by":[]},{"title":"グラフ（隣接頂点）","overview":"無向・有向どちらも表現可能。\n辺に情報を持つことができる。\nただし、無向辺を双方向の有向辺と表現するため、\n無向辺に情報をもたせる場合は倍のリソースを消費する","code":"struct Graph<T: Clone = ()>(Vec<Vec<(usize, T)>>);\n\nimpl<T: Clone> Graph<T> {\n    fn to<'a>(&self, i: usize) -> &Vec<(usize, T)> {\n        &(self.0)[i]\n    }\n}\n\nstruct GraphBuilder<T: Clone = ()>(Graph<T>);\n\nimpl<T: Clone> GraphBuilder<T> {\n    fn new(n: usize) -> Self {\n        Self(Graph::<T>(vec![Vec::<(usize, T)>::new(); n]))\n    }\n    fn connect(&mut self, u: usize, v: usize, item: T) {\n        (self.0 .0)[u].push((v, item.clone()));\n        (self.0 .0)[v].push((u, item));\n    }\n    fn connect_d(&mut self, src: usize, dst: usize, item: T) {\n        (self.0 .0)[src].push((dst, item));\n    }\n    fn build(self) -> Graph<T> {\n        self.0\n    }\n}","lang":"rust","path":"/src/rust/graph/graph.rs","require":"","references":[],"words":[],"verified":["rand"],"commits":[{"sha":"f99b2398bf57ee3b711e4dd21c0dca846c7b3fae","date":"2021-04-24 00:01:15 +0000","message":"add basic features of rust"}],"tested_by":[]},{"title":"二次元グリッド","overview":"work in progress","code":"struct Field<T> {\n    h: usize,\n    w: usize,\n    dat: Vec<T>,\n}\n\nimpl<T: Clone> Field<T> {\n    fn new(h: usize, w: usize, zero: T) -> Self {\n        Self {\n            h,\n            w,\n            dat: vec![zero; w * h as usize],\n        }\n    }\n    fn fill(&mut self, val: T) {\n        self.dat.fill(val);\n    }\n    fn atc(&self, y: i32, x: i32) -> &T {\n        &self.dat[(y % self.h as i32) as usize * self.w + (x % self.w as i32) as usize]\n    }\n    fn atc_mut(&mut self, y: i32, x: i32) -> &mut T {\n        &mut self.dat[(y % self.h as i32) as usize * self.w + (x % self.w as i32) as usize]\n    }\n}\n\nimpl<T> std::ops::Index<(usize, usize)> for Field<T> {\n    type Output = T;\n    fn index(&self, yx: (usize, usize)) -> &Self::Output {\n        &self.dat[yx.0 * self.w + yx.1]\n    }\n}\nimpl<T> std::ops::IndexMut<(usize, usize)> for Field<T> {\n    fn index_mut(&mut self, yx: (usize, usize)) -> &mut Self::Output {\n        &mut self.dat[yx.0 * self.w + yx.1]\n    }\n}","lang":"rust","path":"/src/rust/grid/field.rs","require":"","references":[],"words":[],"verified":[],"commits":[{"sha":"1456ec6616373163824ae70f0b7cdbdc93055d3d","date":"2021-05-09 13:29:54 +0000","message":"add grid, xorshift"}],"tested_by":[]},{"title":"座標","overview":"work in progress","code":"#[derive(Clone, Copy)]\nstruct Pt {\n    y: i32,\n    x: i32,\n}\n\nimpl Pt {\n    fn dist(&self) -> i32 {\n        self.y.abs() + self.x.abs()\n    }\n}\n\nimpl std::ops::Add<Pt> for Pt {\n    type Output = Pt;\n    fn add(self, rhs: Pt) -> Pt {\n        Pt {\n            y: self.y + rhs.y,\n            x: self.x + rhs.x,\n        }\n    }\n}\nimpl std::ops::AddAssign<Pt> for Pt {\n    fn add_assign(&mut self, rhs: Pt) {\n        self.y += rhs.y;\n        self.x += rhs.x;\n    }\n}\nimpl std::ops::Sub<Pt> for Pt {\n    type Output = Pt;\n    fn sub(self, rhs: Pt) -> Pt {\n        Pt {\n            y: self.y - rhs.y,\n            x: self.x - rhs.x,\n        }\n    }\n}","lang":"rust","path":"/src/rust/grid/point.rs","require":"","references":[],"words":[],"verified":[],"commits":[{"sha":"1456ec6616373163824ae70f0b7cdbdc93055d3d","date":"2021-05-09 13:29:54 +0000","message":"add grid, xorshift"}],"tested_by":[]},{"title":"二分探索(整数)","overview":"","code":"fn binary_search<F: Fn(i64) -> bool>(ok_val: i64, ng_val: i64, check: F) -> i64 {\n    let mut ok = ok_val;\n    let mut ng = ng_val;\n    while (ok - ng).abs() > 1 {\n        let m = (ok + ng) / 2;\n        if check(m) {\n            ok = m;\n        } else {\n            ng = m;\n        }\n    }\n    ok\n}","lang":"rust","path":"/src/rust/search/binary_search.rs","require":"","references":[],"words":[],"verified":["rand"],"commits":[{"sha":"f99b2398bf57ee3b711e4dd21c0dca846c7b3fae","date":"2021-04-24 00:01:15 +0000","message":"add basic features of rust"}],"tested_by":[]},{"title":"標準入力マクロ(競技プログラミング用)","overview":"JavaのScannerのように値をBufReadから読み取る。\n数値型・文字列・配列・タプル・タプルの配列に対応。\nバイト単位で読み込むので、インタラクティブ問題にも多分対応出来る。\nタプルを直接渡せない為、専用の記法を用意している。","code":"fn take_token<R: std::io::BufRead>(cin: &mut R) -> String {\n    cin.bytes()\n        .map(|c| c.unwrap() as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect::<String>()\n}\n#[allow(unused)]\nmacro_rules! scan {\n    ($io:expr => $t:ty) => (take_token(&mut $io).parse::<$t>().unwrap());\n    ($io:expr => $t:tt * $n:expr) => ((0..$n).map(|_| scan!($io => $t)).collect::<Vec<_>>());\n    ($io:expr => $($t:tt),*) => (($(scan!($io => $t)),*));\n    ($io:expr => $($t:tt),* * $n:expr) => ((0..$n).map(|_| ($(scan!($io => $t)),*)).collect::<Vec<_>>());\n}","lang":"rust","path":"/src/rust/util/io.rs","require":"","references":[],"words":[],"verified":["https://yukicoder.me/submissions/650278"],"commits":[{"sha":"f99b2398bf57ee3b711e4dd21c0dca846c7b3fae","date":"2021-04-24 00:01:15 +0000","message":"add basic features of rust"}],"tested_by":[]},{"title":"XorShift による 一様分布乱数","overview":"乱数を生成する。\nC++STL風に書いてしまったが、広く使われている rand Crate とはインターフェースが異なり、\nDistoとGeneratorの依存関係が逆。早いうちに書き直したい…","code":"struct IntegerUniformDistoribution {\n    end: u64,\n    lim: u64,\n}\nimpl IntegerUniformDistoribution {\n    #[allow(dead_code)]\n    // [0, high)\n    fn new(end: u64) -> Self {\n        assert!(end != 0);\n        Self {\n            end,\n            lim: u64::MAX / (end - 1) * (end - 1),\n        }\n    }\n    #[inline]\n    #[allow(dead_code)]\n    fn f(&self, rng: &mut Xorshift) -> u64 {\n        loop {\n            let r = rng.next();\n            if r <= self.lim {\n                return r % self.end;\n            }\n        }\n    }\n}\n\nstruct IntegerUniformDistoributionI32 {\n    begin: i32,\n    du64: IntegerUniformDistoribution,\n}\nimpl IntegerUniformDistoributionI32 {\n    #[allow(dead_code)]\n    // [0, high)\n    fn new(end: i32) -> Self {\n        Self::new2(0, end)\n    }\n    // [begin, high)\n    fn new2(begin: i32, end: i32) -> Self {\n        assert!(begin < end);\n        Self {\n            begin,\n            du64: IntegerUniformDistoribution::new((end - begin) as u64),\n        }\n    }\n    #[inline]\n    #[allow(dead_code)]\n    fn f(&self, rng: &mut Xorshift) -> i32 {\n        self.du64.f(rng) as i32 + self.begin\n    }\n}\n\n#[allow(dead_code)]\nstruct Xorshift {\n    seed: u64,\n}\nimpl Xorshift {\n    #[allow(dead_code)]\n    pub fn new_with_seed(seed: u64) -> Self {\n        Self { seed: seed } // 88172645463325252\n    }\n    #[inline]\n    #[allow(dead_code)]\n    pub fn next(&mut self) -> u64 {\n        self.seed = self.seed ^ (self.seed << 13);\n        self.seed = self.seed ^ (self.seed >> 7);\n        self.seed = self.seed ^ (self.seed << 17);\n        self.seed\n    }\n    #[inline]\n    #[allow(dead_code)]\n    // [0.0,1.0]\n    // https://qiita.com/hatoo@github/items/652b81e8e83b0680bc0a\n    pub fn randf(&mut self) -> f64 {\n        use std::mem;\n        const UPPER_MASK: u64 = 0x3FF0000000000000;\n        const LOWER_MASK: u64 = 0xFFFFFFFFFFFFF;\n        let tmp = UPPER_MASK | (self.next() & LOWER_MASK);\n        let result: f64 = unsafe { mem::transmute(tmp) };\n        result - 1.0\n    }\n}\n\n#[test]\nfn test_generate_randomized_value() {\n    let mut rng = Xorshift::new_with_seed(88172645463325252);\n    let u = IntegerUniformDistoributionI32::new2(-500, 500);\n    let mut bucket = [0; 1000];\n    for _ in 0..(2000 * 1000) {\n        let v = u.f(&mut rng);\n        assert!(-500 <= v && v < 500, \"{} in [-500, 500)\", v);\n        bucket[(v + 500) as usize] += 1;\n    }\n    for (i, cnt) in bucket.iter().enumerate() {\n        assert!(1800 < *cnt && *cnt < 2200, \"{} ~ 2000, idx={}\", *cnt, i);\n    }\n}","lang":"rust","path":"/src/rust/util/xorshift.rs","require":"","references":["https://ja.wikipedia.org/wiki/Xorshift","https://qiita.com/hatoo@github/items/652b81e8e83b0680bc0a"],"words":[],"verified":[],"commits":[{"sha":"1456ec6616373163824ae70f0b7cdbdc93055d3d","date":"2021-05-09 13:29:54 +0000","message":"add grid, xorshift"}],"tested_by":[]}]